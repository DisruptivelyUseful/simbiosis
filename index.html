<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar Builder & Simulator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* ============================================
           SOLAR BUILDER & SIMULATOR - UNIFIED STYLES
           ============================================ */
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            font-family: Arial, sans-serif; 
            background-color: #2d2d2d; 
            color: #e8e8e8; 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            height: 100vh;
        }
        
        /* ============================================
           TOOLBAR
           ============================================ */
        .toolbar { 
            background: linear-gradient(135deg, #1a2b3c 0%, #2a3b4c 100%);
            border-bottom: 3px solid #ffdd57;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 12px 20px; 
            display: flex; 
            gap: 15px; 
            align-items: center; 
            justify-content: space-between;
            flex-shrink: 0; 
            z-index: 1001;
            position: relative;
        }
        
        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 0 0 auto;
        }
        
        .toolbar-center {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1 1 auto;
            justify-content: center;
        }
        
        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 0 0 auto;
        }
        
        .toolbar button { 
            padding: 8px 14px; 
            background: rgba(0, 0, 0, 0.3);
            color: #fff; 
            border: 2px solid rgba(255, 221, 87, 0.3); 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .toolbar button:hover { 
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 221, 87, 0.6);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 221, 87, 0.3);
        }
        
        .toolbar button.active {
            background: rgba(255, 221, 87, 0.3);
            border-color: #ffdd57;
        }
        
        .toolbar .mode-toggle {
            display: flex;
            gap: 0;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .toolbar .mode-toggle button {
            border-radius: 0;
            border-right: none;
            min-width: 100px;
            padding: 8px 16px;
        }
        
        .toolbar .mode-toggle button:first-child {
            border-radius: 6px 0 0 6px;
        }
        
        .toolbar .mode-toggle button:last-child {
            border-radius: 0 6px 6px 0;
            border-right: 2px solid rgba(255, 221, 87, 0.3);
        }
        
        .toolbar .mode-toggle button.active {
            background: rgba(255, 221, 87, 0.2);
            border-color: rgba(255, 221, 87, 0.6);
            color: #ffdd57;
            font-weight: bold;
        }
        
        .toolbar .mode-toggle button:hover {
            background: rgba(255, 221, 87, 0.15);
            color: #ffdd57;
        }
        
        #liveViewModeBtn {
            background: rgba(240, 173, 78, 0.2);
            border-color: rgba(240, 173, 78, 0.4);
        }
        
        #liveViewModeBtn:hover {
            background: rgba(240, 173, 78, 0.3);
            color: #f0ad4e;
        }
        
        #liveViewModeBtn.active {
            background: rgba(240, 173, 78, 0.3);
            border-color: rgba(240, 173, 78, 0.6);
            color: #f0ad4e;
            font-weight: bold;
        }
        
        .toolbar .time-display { 
            font-size: 1.1em; 
            color: #ffdd57; 
            font-weight: 600;
            text-shadow: 0 0 10px rgba(255, 221, 87, 0.5);
        }
        
        .toolbar .play-controls { 
            display: flex; 
            align-items: center; 
            gap: 12px;
        }
        
        .toolbar .play-controls button#playPauseButton { 
            font-size: 1.4em; 
            padding: 8px 16px;
            min-width: 50px;
        }
        
        .toolbar input[type="range"] { 
            width: 150px; 
            cursor: pointer; 
            margin: 0;
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            outline: none;
        }
        
        .toolbar input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ffdd57;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 221, 87, 0.6);
        }
        
        .toolbar .speed-label { 
            font-size: 0.95em; 
            color: #ffdd57; 
            font-weight: 600;
            min-width: 45px;
        }
        
        /* ============================================
           MAIN CONTENT AREA
           ============================================ */
        #main-content { 
            display: flex; 
            flex-grow: 1; 
            overflow: hidden; 
            position: relative;
        }
        
        #canvas-container { 
            flex-grow: 1; 
            position: relative; 
            overflow: hidden;
            transition: background-color 1s ease-in-out;
        }
        
        svg { 
            width: 100%; 
            height: 100%; 
            background-color: #1a2b3c; 
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px); 
            background-size: 35px 35px; 
            position: relative;
            transition: background-color 1s ease-in-out;
        }
        
        /* ============================================
           LEFT SIDEBAR - Component Library & Scores
           ============================================ */
        #left-sidebar {
            width: 280px;
            background-color: #3a3a3a;
            padding: 15px;
            padding-bottom: 80px;
            box-sizing: border-box;
            overflow-y: auto;
            border-right: 1px solid #555;
            color: #e8e8e8;
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            z-index: 1000;
            transition: width 0.3s ease, opacity 0.3s ease;
        }
        
        #left-sidebar.collapsed {
            width: 0 !important;
            padding: 0 !important;
            overflow: visible;
            border-right: none;
        }
        
        #left-sidebar.collapsed > *:not(#left-sidebar-toggle) {
            opacity: 0;
            pointer-events: none;
        }
        
        #left-sidebar-toggle {
            position: fixed !important;
            left: 0 !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            width: 30px !important;
            height: 60px !important;
            background-color: #3a3a3a !important;
            border: 1px solid #555 !important;
            border-left: none !important;
            border-radius: 0 4px 4px 0 !important;
            cursor: pointer;
            display: flex !important;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 18px;
            z-index: 10000 !important;
            transition: background-color 0.2s ease, left 0.3s ease;
            pointer-events: auto !important;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        #left-sidebar-toggle:hover {
            background-color: #4a4a4a;
        }
        
        #left-sidebar:not(.collapsed) #left-sidebar-toggle {
            left: 280px;
        }
        
        /* ============================================
           RIGHT SIDEBAR - Inspector/Editor
           ============================================ */
        #right-sidebar {
            width: 320px;
            background-color: #3a3a3a;
            padding: 15px;
            padding-bottom: 80px;
            box-sizing: border-box;
            overflow-y: auto;
            border-left: 1px solid #555;
            color: #e8e8e8;
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            z-index: 1000;
            transition: width 0.3s ease, transform 0.3s ease;
            transform: translateX(100%);
        }
        
        #right-sidebar.open {
            transform: translateX(0);
        }
        
        #right-sidebar-toggle {
            position: fixed !important;
            right: 0 !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            width: 30px !important;
            height: 60px !important;
            background-color: #3a3a3a !important;
            border: 1px solid #555 !important;
            border-right: none !important;
            border-radius: 4px 0 0 4px !important;
            cursor: pointer;
            display: flex !important;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 18px;
            z-index: 10000 !important;
            transition: background-color 0.2s ease, right 0.3s ease;
            pointer-events: auto !important;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        #right-sidebar.open #right-sidebar-toggle {
            right: 320px;
        }
        
        /* ============================================
           SIDEBAR COMMON STYLES
           ============================================ */
        .sidebar-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #555;
        }
        
        .sidebar-section:last-child {
            border-bottom: none;
        }
        
        .sidebar-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #ffdd57;
        }
        
        .sidebar-section h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #aaa;
        }
        
        .sidebar-section label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            color: #ccc;
        }
        
        .sidebar-section input[type="text"],
        .sidebar-section input[type="number"],
        .sidebar-section select {
            width: 100%;
            padding: 8px;
            background-color: #4a4a4a;
            color: #fff;
            border: 1px solid #666;
            border-radius: 4px;
            margin-top: 4px;
        }
        
        .sidebar-section input:focus,
        .sidebar-section select:focus {
            outline: none;
            border-color: #ffdd57;
        }
        
        .sidebar-section button {
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: 1px solid #777;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
            width: 100%;
            transition: background-color 0.2s ease;
        }
        
        .sidebar-section button:hover {
            background-color: #6a6a6a;
        }
        
        /* ============================================
           SCORE BAR (Vertical in Left Sidebar)
           ============================================ */
        .score-bar {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(255, 221, 87, 0.2);
        }
        
        .score-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .score-value {
            font-size: 14px;
            font-weight: bold;
            color: #ffdd57;
        }
        
        .score-value.good { color: #5cb85c; }
        .score-value.warning { color: #f0ad4e; }
        .score-value.error { color: #d9534f; }
        
        /* ============================================
           COMPONENT LIBRARY
           ============================================ */
        .component-library {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .component-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .component-item:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: #ffdd57;
        }
        
        .component-item img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            object-fit: contain;
            border-radius: 4px;
            background: #333;
        }
        
        .component-item .component-info {
            flex: 1;
        }
        
        .component-item .component-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }
        
        .component-item .component-specs {
            font-size: 10px;
            color: #aaa;
            margin-top: 2px;
        }
        
        /* ============================================
           CANVAS ELEMENTS - Panels, Batteries, Controllers
           ============================================ */
        .item-group { 
            cursor: grab; 
        }
        
        .item-group:active { 
            cursor: grabbing; 
        }
        
        .item-group.selected .item-rect {
            stroke: #ffdd57;
            stroke-width: 3px;
        }
        
        /* Solar Panel */
        .panel .item-rect {
            fill: #2a4a6a;
            stroke: #4a7aaa;
            stroke-width: 2px;
        }
        
        .panel .panel-cells {
            stroke: #1a3a5a;
            stroke-width: 1px;
        }
        
        .panel .panel-label {
            fill: #fff;
            font-size: 14px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .panel .panel-specs {
            fill: #ccc;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
        }
        
        /* Battery */
        .battery .item-rect {
            fill: #4a5a4a;
            stroke: #6a8a6a;
            stroke-width: 2px;
        }
        
        .battery .battery-terminal-pos {
            fill: #d9534f;
        }
        
        .battery .battery-terminal-neg {
            fill: #222;
            stroke: #111;
            stroke-width: 1px;
        }
        
        .battery .battery-label {
            fill: #fff;
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .battery .battery-specs {
            fill: #ccc;
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
        }
        
        /* Controller */
        .controller .item-rect {
            fill: #4a4a5a;
            stroke: #7a7a9a;
            stroke-width: 2px;
        }
        
        .controller.operational .item-rect {
            stroke: #5cb85c;
            stroke-width: 3px;
        }
        
        .controller.error .item-rect {
            stroke: #d9534f;
            stroke-width: 3px;
            fill: #4a2020 !important;
            animation: pulse-error 0.5s infinite;
        }
        
        @keyframes pulse-error {
            0%, 100% { stroke: #d9534f; }
            50% { stroke: #ff0000; }
        }
        
        .spark {
            pointer-events: none;
        }
        
        .overload-flash {
            pointer-events: none;
        }
        
        .controller .controller-label {
            fill: #fff;
            font-size: 13px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .controller .controller-specs {
            fill: #ccc;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .controller .port-label {
            fill: #aaa;
            font-size: 9px;
            text-anchor: middle;
            pointer-events: none;
        }
        
        /* Breaker */
        .breaker .item-rect {
            fill: #3a3a4a;
            stroke: #6a6a8a;
            stroke-width: 2px;
        }
        
        .breaker.open .item-rect {
            stroke: #d9534f;
        }
        
        .breaker.closed .item-rect {
            stroke: #5cb85c;
        }
        
        /* Combiner */
        .combiner .item-rect {
            fill: #4a4a3a;
            stroke: #8a8a6a;
            stroke-width: 2px;
        }
        
        /* Solar Combiner Box */
        .solarcombiner .item-rect {
            fill: #3a4a4a;
            stroke: #f0ad4e;
            stroke-width: 2px;
        }
        
        .solarcombiner.selected .item-rect {
            stroke: #ffdd57;
            stroke-width: 3px;
        }
        
        /* Handles (connection points) */
        .handle {
            stroke-width: 2px;
            cursor: pointer;
            transition: r 0.2s ease;
        }
        
        .handle:hover {
            r: 12px;
        }
        
        .handle.positive {
            fill: #d9534f;
            stroke: #b94a48;
        }
        
        .handle.negative {
            fill: #333;
            stroke: #222;
        }
        
        .handle.pv-positive {
            fill: #d9534f;
            stroke: #b94a48;
        }
        
        .handle.pv-negative {
            fill: #333;
            stroke: #222;
        }
        
        .handle.ac {
            fill: #5bc0de;
            stroke: #46b8da;
        }
        
        .handle.smart-battery {
            fill: #5cb85c;
            stroke: #4cae4c;
        }
        
        /* Wires/Connections */
        .wire {
            fill: none;
            stroke-width: 4px;
            pointer-events: stroke;
            cursor: pointer;
        }
        
        .wire:hover {
            stroke-width: 6px;
        }
        
        .wire.positive {
            stroke: #d9534f;
            filter: drop-shadow(0 0 2px rgba(217, 83, 79, 0.4));
        }
        
        .wire.negative {
            stroke: #333;
            filter: drop-shadow(0 0 2px rgba(200, 200, 200, 0.4));
        }
        
        .wire.mixed {
            stroke: #888;
        }
        
        .wire.smart-battery {
            stroke: #5cb85c;
            stroke-width: 6px;
        }
        
        .wire.parallel {
            stroke: #00a8e8;
            stroke-width: 6px;
        }
        
        .wire.ac {
            stroke: #f0ad4e;
            stroke-width: 4px;
        }
        
        .wire.temp {
            stroke: #ffdd57;
            stroke-dasharray: 5, 5;
            pointer-events: none;
        }
        
        .wire.load {
            /* Color is determined dynamically based on load voltage - see getWireStyle() */
            stroke-width: 4px;
        }
        
        /* ============================================
           HINTS AND POPUPS
           ============================================ */
        .hint-popup {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffdd57;
            border-radius: 12px;
            padding: 20px 30px;
            max-width: 500px;
            z-index: 10000;
            animation: slideUp 0.3s ease;
            pointer-events: auto;
            visibility: visible;
        }
        
        .hint-popup.hidden {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
            opacity: 0 !important;
        }
        
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        .hint-popup h3 {
            margin: 0 0 10px 0;
            color: #ffdd57;
            font-size: 16px;
        }
        
        .hint-popup p {
            margin: 0;
            color: #ccc;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .hint-popup button {
            margin-top: 15px;
            padding: 8px 20px;
            background: #ffdd57;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
        }
        
        .hint-popup button:hover {
            background: #ffed87;
        }
        
        .hint-popup button:active {
            background: #e6c547;
        }
        
        /* Achievement Popup */
        .achievement-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10001;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }
        
        .achievement-overlay.visible {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .achievement-content {
            background: linear-gradient(135deg, #1a2b3c 0%, #2a3b4c 100%);
            border: 3px solid #5cb85c;
            border-radius: 16px;
            padding: 30px 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 50px rgba(92, 184, 92, 0.5);
        }
        
        .achievement-content h1 {
            color: #5cb85c;
            font-size: 28px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px rgba(92, 184, 92, 0.8);
        }
        
        .achievement-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .achievement-stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
        }
        
        .achievement-stat .label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .achievement-stat .value {
            font-size: 24px;
            font-weight: bold;
            color: #ffdd57;
            margin-top: 5px;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* ============================================
           LIVE VIEW STYLES
           ============================================ */
        .live-view-controls-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .live-view-reset-btn {
            background: rgba(240, 173, 78, 0.3);
            border: 1px solid #f0ad4e;
            color: #f0ad4e;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .live-view-reset-btn:hover {
            background: rgba(240, 173, 78, 0.4);
        }
        
        .live-view-power-summary {
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: 13px;
        }
        
        .live-view-power-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
        }
        
        .live-view-power-item.dc {
            background: rgba(217, 83, 79, 0.15);
            border: 1px solid rgba(217, 83, 79, 0.4);
        }
        
        .live-view-power-item.ac {
            background: rgba(240, 173, 78, 0.15);
            border: 1px solid rgba(240, 173, 78, 0.4);
        }
        
        .live-view-power-item.battery {
            background: rgba(92, 184, 92, 0.15);
            border: 1px solid rgba(92, 184, 92, 0.4);
        }
        
        .live-view-power-label {
            font-weight: bold;
        }
        
        .live-view-power-label.dc {
            color: #d9534f;
        }
        
        .live-view-power-label.ac {
            color: #f0ad4e;
        }
        
        .live-view-power-label.battery {
            color: #5cb85c;
        }
        
        .live-view-power-value {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }
        
        .live-view-power-unit {
            color: #888;
            font-size: 11px;
        }
        
        /* ============================================
           SYSTEM REVIEW STYLES
           ============================================ */
        .system-review-stat-disabled {
            color: #888;
        }
    </style>
</head>
<body>
    <!-- TOOLBAR -->
    <div class="toolbar">
        <div class="toolbar-left">
            <div class="mode-toggle">
                <button id="buildModeBtn" class="active">Build</button>
                <button id="liveViewModeBtn">Live View</button>
                <button id="simulateModeBtn">Simulate</button>
            </div>
        </div>
        
        <div class="toolbar-center">
            <!-- Build Mode Controls -->
            <div id="buildControls">
                <button id="addPanelBtn">+ Panel</button>
                <button id="addBatteryBtn">+ Battery</button>
                <button id="resetBtn">Reset</button>
            </div>
            
            <!-- Simulate Mode Controls (hidden by default) -->
            <div id="simulateControls" class="hidden">
                <div class="play-controls">
                    <button id="playPauseButton">â–¶</button>
                    <input type="range" id="speedSlider" min="1" max="100" value="10">
                    <span class="speed-label" id="speedLabel">1x</span>
                </div>
                <span class="time-display" id="timeDisplay">0 hours (Day 1, 00:00)</span>
            </div>
            
            <!-- Live View Mode Controls (hidden by default) -->
            <div id="liveViewControls" class="hidden">
                <div class="live-view-controls-container">
                    <button id="resetAllLoadsBtn" class="live-view-reset-btn">Reset All Loads</button>
                    <button id="resetAllBreakersBtn" class="live-view-reset-btn">Reset All Breakers</button>
                    <div id="liveViewPowerSummary" class="live-view-power-summary">
                        <div class="live-view-power-item dc">
                            <span class="live-view-power-label dc">DC:</span>
                            <span id="liveViewDCWatts" class="live-view-power-value">0</span>
                            <span class="live-view-power-unit">W</span>
                        </div>
                        <div class="live-view-power-item ac">
                            <span class="live-view-power-label ac">AC:</span>
                            <span id="liveViewACWatts" class="live-view-power-value">0</span>
                            <span class="live-view-power-unit">W</span>
                        </div>
                        <div class="live-view-power-item battery">
                            <span class="live-view-power-label battery">ðŸ”‹</span>
                            <span id="liveViewBatteryLevel" class="live-view-power-value">0</span>
                            <span class="live-view-power-unit">kWh</span>
                            <span class="live-view-power-unit">(</span>
                            <span id="liveViewBatteryPercent" class="live-view-power-label battery">0</span>
                            <span class="live-view-power-unit">%)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="toolbar-right">
            <button id="systemReviewBtn" style="background: rgba(91, 192, 222, 0.3); border: 1px solid #5bc0de; color: #5bc0de; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 10px;">ðŸ“Š System Review</button>
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #aaa; cursor: pointer;">
                <input type="checkbox" id="showHintsToggle" checked style="cursor: pointer;">
                Show Hints
            </label>
            <button id="simulateBtn" style="background: rgba(92, 184, 92, 0.3); border-color: #5cb85c;">â–¶ Simulate</button>
            <button id="saveBtn">Save</button>
            <button id="loadBtn">Load</button>
        </div>
    </div>
    
    <!-- MAIN CONTENT -->
    <div id="main-content">
        <!-- LEFT SIDEBAR - Component Library & Scores -->
        <div id="left-sidebar">
            <button id="left-sidebar-toggle">â—€</button>
            
            <!-- Score Bar Section -->
            <div class="sidebar-section">
                <h3>System Scores</h3>
                <div class="score-bar">
                    <div class="score-item">
                        <span class="score-label">Array Wmp</span>
                        <span class="score-value" id="scoreArrayWmp">0 W</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Array Voc</span>
                        <span class="score-value" id="scoreArrayVoc">0 V</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Array Imp</span>
                        <span class="score-value" id="scoreArrayImp">0 A</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Array Config</span>
                        <span class="score-value" id="scoreArrayConfig">-</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery</span>
                        <span class="score-value" id="scoreBatteryKwh">0 kWh</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery Config</span>
                        <span class="score-value" id="scoreBatteryConfig">-</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery Voltage</span>
                        <span class="score-value" id="scoreBatteryVoltage">-</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Optimization</span>
                        <span class="score-value" id="scoreOptimization">0%</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">K<sub>micro</sub></span>
                        <span class="score-value" id="scoreKMicro">0.000</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Total Cost</span>
                        <span class="score-value" id="scoreTotalCost">$0</span>
                    </div>
                </div>
            </div>
            
            <!-- Simulation Stats (shown in simulate mode) -->
            <div class="sidebar-section" id="simStatsSection" style="display: none;">
                <h3>Simulation Stats</h3>
                <div class="score-bar">
                    <div class="score-item">
                        <span class="score-label">Solar Generated</span>
                        <span class="score-value" id="simSolarGenerated">0.00 kWh</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Energy Used</span>
                        <span class="score-value" id="simEnergyUsed">0.00 kWh</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery Charge</span>
                        <span class="score-value" id="simBatteryCharge">0%</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Peak Power</span>
                        <span class="score-value" id="simPeakPower">0 kW</span>
                    </div>
                </div>
            </div>
            
            <!-- Component Library Section -->
            <div class="sidebar-section">
                <h3>Solar Panels</h3>
                <div class="component-library" id="panelLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Batteries</h3>
                <div class="component-library" id="batteryLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Controllers</h3>
                <div class="component-library" id="controllerLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Protection &amp; Combining</h3>
                <div class="component-library" id="breakerLibrary">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="component-library" id="combinerLibrary" style="margin-top: 10px;">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="component-library" id="solarCombinerLibrary" style="margin-top: 10px;">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>EcoFlow Ecosystem</h3>
                <div class="component-library" id="ecoflowLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>AC Distribution</h3>
                <div class="component-library" id="acBreakerLibrary">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="component-library" id="acOutletLibrary" style="margin-top: 10px;">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <!-- Custom Component Section -->
            <div class="sidebar-section">
                <h3>Add Custom</h3>
                <button id="addCustomPanelBtn">Custom Panel</button>
                <button id="addCustomBatteryBtn">Custom Battery</button>
                <button id="addCustomControllerBtn">Custom Controller</button>
            </div>
        </div>
        
        <!-- CANVAS -->
        <div id="canvas-container">
            <svg id="canvas"></svg>
        </div>
        
        <!-- RIGHT SIDEBAR - Inspector/Editor (opens when selecting) -->
        <div id="right-sidebar">
            <button id="right-sidebar-toggle">â–¶</button>
            
            <div class="sidebar-section" id="inspectorSection">
                <h3>Inspector</h3>
                <p id="inspectorEmpty">Select a component to edit</p>
                
                <!-- Panel Inspector -->
                <div id="panelInspector" class="hidden">
                    <h4>Solar Panel</h4>
                    <label>Name: <input type="text" id="panelName"></label>
                    <label>Wmp (W): <input type="number" id="panelWmp" min="0"></label>
                    <label>Vmp (V): <input type="number" id="panelVmp" min="0" step="0.1"></label>
                    <label>Voc (V): <input type="number" id="panelVoc" min="0" step="0.1"></label>
                    <label>Isc (A): <input type="number" id="panelIsc" min="0" step="0.01"></label>
                    <label>Cost ($): <input type="number" id="panelCost" min="0" step="0.01"></label>
                    <p style="font-size: 11px; color: #f0ad4e; margin-top: 10px;">
                        Note: Editing this panel will update ALL panels in the array.
                    </p>
                    <button id="applyPanelChanges">Apply to All Panels</button>
                </div>
                
                <!-- Battery Inspector -->
                <div id="batteryInspector" class="hidden">
                    <h4>Battery</h4>
                    <label>Name: <input type="text" id="batteryName"></label>
                    <label>Voltage (V): <input type="number" id="batteryVoltage" min="0" step="0.1"></label>
                    <label>Capacity (Ah): <input type="number" id="batteryAh" min="0" step="0.1"></label>
                    <label>Max Discharge (A): <input type="number" id="batteryMaxDischarge" min="0" step="0.1"></label>
                    <label>Cost ($): <input type="number" id="batteryCost" min="0" step="0.01"></label>
                    <p style="font-size: 11px; color: #f0ad4e; margin-top: 10px;">
                        Note: Editing this battery will update ALL batteries in the bank.
                    </p>
                    <button id="applyBatteryChanges">Apply to All Batteries</button>
                </div>
                
                <!-- Controller Inspector -->
                <div id="controllerInspector" class="hidden">
                    <h4>Controller</h4>
                    <label>Name: <input type="text" id="controllerName"></label>
                    <label>Type: 
                        <select id="controllerType">
                            <option value="charge_controller">Charge Controller</option>
                            <option value="hybrid_inverter">Hybrid Inverter</option>
                            <option value="all_in_one">All-in-One System</option>
                        </select>
                    </label>
                    <label>Max PV Voc (V): <input type="number" id="controllerMaxVoc" min="0"></label>
                    <label>Min PV Vmp (V): <input type="number" id="controllerMinVmp" min="0"></label>
                    <label>MPP Range (V): 
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <input type="number" id="controllerMppMin" min="0" style="width: 60px;"> - 
                            <input type="number" id="controllerMppMax" min="0" style="width: 60px;">
                        </div>
                    </label>
                    <label>Max PV Isc (A): <input type="number" id="controllerMaxIsc" min="0" step="0.1"></label>
                    <label>Max PV Wmp (W): <input type="number" id="controllerMaxWmp" min="0"></label>
                    <label>Charge Current (A): <input type="number" id="controllerChargeCurrent" min="0" step="0.1"></label>
                    <div id="controllerACOutput" class="hidden">
                        <label>AC Output (W): <input type="number" id="controllerACOutputW" min="0"></label>
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="font-size: 12px; color: #aaa;">Compatible Voltages:</span>
                        <div id="controllerVoltages" style="display: flex; gap: 10px; margin-top: 5px;">
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV12" value="12"> 12V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV24" value="24"> 24V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV36" value="36"> 36V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV48" value="48"> 48V
                            </label>
                        </div>
                    </div>
                    <label>Cost ($): <input type="number" id="controllerCost" min="0" step="0.01"></label>
                    <button id="applyControllerChanges">Apply Changes</button>
                </div>
                
                <!-- Breaker Inspector -->
                <div id="breakerInspector" class="hidden">
                    <h4>DC Breaker</h4>
                    <label>Rating (A): 
                        <select id="breakerRating">
                            <option value="5">5A</option>
                            <option value="10">10A</option>
                            <option value="16">16A</option>
                            <option value="20">20A</option>
                            <option value="30">30A</option>
                            <option value="40">40A</option>
                            <option value="50">50A</option>
                            <option value="63">63A</option>
                            <option value="80">80A</option>
                            <option value="100">100A</option>
                        </select>
                    </label>
                    <label>Max Voltage (V): <input type="number" id="breakerMaxVoltage" min="0"></label>
                    <label>Cost ($): <input type="number" id="breakerCost" min="0" step="0.01"></label>
                    <div style="margin-top: 10px;">
                        <button id="toggleBreaker" style="width: 100%;">Toggle Breaker</button>
                    </div>
                    <p id="breakerStatus" style="text-align: center; font-weight: bold; margin-top: 10px;"></p>
                    <button id="applyBreakerChanges">Apply Changes</button>
                    <button id="autosizeBreaker" style="margin-top: 5px;">Auto-Size Breaker</button>
                </div>
                
                <!-- Combiner Inspector -->
                <div id="combinerInspector" class="hidden">
                    <h4>Combiner Box</h4>
                    <p id="combinerInfo">Combines multiple parallel strings into one output.</p>
                    <label>Number of Inputs: <span id="combinerInputCount">4</span></label>
                    <label>Max Amps/Input: <input type="number" id="combinerMaxAmps" min="0" step="0.1"></label>
                    <label>Cost ($): <input type="number" id="combinerCost" min="0" step="0.01"></label>
                    <button id="applyCombinerChanges">Apply Changes</button>
                </div>
                
                <!-- Solar Combiner Inspector -->
                <div id="solarCombinerInspector" class="hidden">
                    <h4>Solar Combiner Box</h4>
                    <p style="font-size: 11px; color: #aaa;">Combines PV strings with individual breaker protection.</p>
                    <label>Number of Inputs: <span id="solarCombinerInputCount">4</span></label>
                    <label>Breaker Rating (A): 
                        <select id="solarCombinerBreakerRating">
                            <option value="10">10A</option>
                            <option value="15">15A</option>
                            <option value="20">20A</option>
                            <option value="30">30A</option>
                        </select>
                    </label>
                    <label>Max Voltage (V): <input type="number" id="solarCombinerMaxVoltage" min="0"></label>
                    <label>Cost ($): <input type="number" id="solarCombinerCost" min="0" step="0.01"></label>
                    <div style="margin-top: 10px;">
                        <h5 style="margin: 5px 0; color: #ffdd57;">Input Breakers:</h5>
                        <div id="solarCombinerBreakers"></div>
                    </div>
                    <button id="applySolarCombinerChanges">Apply Changes</button>
                </div>
                
                <!-- Wire Inspector -->
                <div id="wireInspector" class="hidden">
                    <h4>Wire Connection</h4>
                    <p id="wireInfo">Connection details here</p>
                    <p id="wireCurrentInfo" style="font-size: 11px; color: #f0ad4e;"></p>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Wire Specifications</h5>
                    
                    <label>Wire Gauge (AWG):
                        <input type="text" id="wireGaugeDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Operating Amperage:
                        <input type="text" id="wireAmpsDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Estimated Length (feet):
                        <input type="number" id="wireLengthInput" min="0" step="0.1" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <button id="recalculateWireLength" style="margin-top: 5px; width: 100%; padding: 5px; background: #5bc0de; border: none; color: white; border-radius: 3px; cursor: pointer;">Recalculate Length</button>
                    
                    <label>Cost per Foot ($):
                        <input type="number" id="wireCostPerFootInput" min="0" step="0.01" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    
                    <label>Total Wire Cost:
                        <input type="text" id="wireTotalCostDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #f0ad4e; border: 1px solid #444; font-weight: bold;">
                    </label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <button id="deleteWire">Delete Connection</button>
                    <button id="addBreakerToWire" style="margin-top: 5px;">Add Breaker to Circuit</button>
                </div>
                
                <!-- Spider Box Inspector -->
                <div id="spiderboxInspector" class="hidden">
                    <h4>CEP Spider Box</h4>
                    <p style="font-size: 11px; color: #f0ad4e;">Portable power distribution unit</p>
                    <label>Input: <span style="color: #d9534f; font-weight: bold;">240V 50A</span></label>
                    <label>Max Power: <span id="spiderboxMaxPower">12,000W</span></label>
                    <label>Cost ($): <input type="number" id="spiderboxCost" min="0" step="1"></label>
                    <div style="margin-top: 15px;">
                        <h5 style="margin: 5px 0; color: #f0ad4e;">Circuit Breakers:</h5>
                        <div id="spiderboxBreakers" style="max-height: 200px; overflow-y: auto;"></div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="spiderboxAllOn" style="flex: 1;">All On</button>
                        <button id="spiderboxAllOff" style="flex: 1;">All Off</button>
                    </div>
                    <button id="applySpiderboxChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- Breaker Panel Inspector -->
                <div id="breakerpanelInspector" class="hidden">
                    <h4>Main Breaker Panel</h4>
                    <p style="font-size: 11px; color: #888;">Residential/commercial distribution panel</p>
                    <label>Main Input: <span style="color: #d9534f; font-weight: bold;">240V 100A</span></label>
                    <label>Max Power: <span id="panelMaxPower">24,000W</span></label>
                    <label>Cost ($): <input type="number" id="breakerpanelCost" min="0" step="1"></label>
                    <div style="margin-top: 15px;">
                        <h5 style="margin: 5px 0; color: #f0ad4e;">Circuit Breakers:</h5>
                        <div id="breakerpanelBreakers" style="max-height: 250px; overflow-y: auto;"></div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="breakerpanelAllOn" style="flex: 1;">All On</button>
                        <button id="breakerpanelAllOff" style="flex: 1;">All Off</button>
                    </div>
                    <button id="applyBreakerpanelChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- AC Load Inspector -->
                <div id="acloadInspector" class="hidden">
                    <h4>Appliance / Load</h4>
                    
                    <!-- Live View Toggle (only shown in live view mode) -->
                    <div id="loadToggleSection" class="hidden" style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px; border: 1px solid #444;">
                        <label style="display: flex; align-items: center; justify-content: space-between;">
                            <span>Power:</span>
                            <button id="loadToggleBtn" style="padding: 5px 15px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold;">
                                OFF
                            </button>
                        </label>
                        <p id="loadStatusText" style="font-size: 10px; color: #888; margin: 5px 0 0 0;"></p>
                    </div>
                    
                    <label>Preset:
                        <select id="loadPreset" style="width: 100%; padding: 5px; margin-top: 3px;">
                            <!-- Populated by JavaScript -->
                        </select>
                    </label>
                    <label>Name: <input type="text" id="loadName"></label>
                    <label>Voltage (V): 
                        <select id="loadVoltage">
                            <option value="120">120V</option>
                            <option value="240">240V</option>
                        </select>
                    </label>
                    <label>Max Watts: <input type="number" id="loadMaxWatts" min="0"></label>
                    <label>Icon: <input type="text" id="loadIcon" maxlength="2" style="width: 50px;"></label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Behavior</h5>
                    <label>Type:
                        <select id="loadBehaviorType" style="width: 100%; padding: 5px; margin-top: 3px;">
                            <option value="constant">Constant</option>
                            <option value="scheduled">Scheduled</option>
                            <option value="batch">Batch / Recipes</option>
                            <option value="thermostat">Thermostat</option>
                            <option value="charging">Charging</option>
                        </select>
                    </label>
                    
                    <!-- Constant behavior (default) -->
                    <div id="behaviorConstant" class="behavior-section">
                        <label>Avg Watts: <input type="number" id="loadAvgWatts" min="0"></label>
                        <p style="font-size: 10px; color: #888; margin: 5px 0;">Draws constant power when on.</p>
                    </div>
                    
                    <!-- Scheduled behavior -->
                    <div id="behaviorScheduled" class="behavior-section hidden">
                        <label>Turn On:
                            <select id="scheduleOn" style="width: 100%;">
                                <option value="sunrise">Sunrise</option>
                                <option value="sunset">Sunset</option>
                                <option value="06:00">6:00 AM</option>
                                <option value="08:00">8:00 AM</option>
                                <option value="12:00">12:00 PM</option>
                                <option value="18:00">6:00 PM</option>
                                <option value="20:00">8:00 PM</option>
                                <option value="22:00">10:00 PM</option>
                            </select>
                        </label>
                        <label>Turn Off:
                            <select id="scheduleOff" style="width: 100%;">
                                <option value="sunrise">Sunrise</option>
                                <option value="sunset">Sunset</option>
                                <option value="06:00">6:00 AM</option>
                                <option value="08:00">8:00 AM</option>
                                <option value="12:00">12:00 PM</option>
                                <option value="18:00">6:00 PM</option>
                                <option value="22:00">10:00 PM</option>
                                <option value="23:00">11:00 PM</option>
                            </select>
                        </label>
                    </div>
                    
                    <!-- Batch / Recipe behavior -->
                    <div id="behaviorBatch" class="behavior-section hidden">
                        <p style="font-size: 10px; color: #888; margin: 5px 0 8px 0;">Recipes define tasks this appliance can perform.</p>
                        <div id="recipeList" style="max-height: 200px; overflow-y: auto; background: #1a1a1a; border-radius: 4px; padding: 5px;">
                            <!-- Populated by JS -->
                        </div>
                        <button id="addRecipeBtn" style="margin-top: 8px; font-size: 11px;">+ Add Recipe</button>
                        <div id="dailyEnergyTotal" style="margin-top: 8px; padding: 6px; background: #2a3a2a; border-radius: 4px; font-size: 11px; color: #5cb85c;"></div>
                    </div>
                    
                    <!-- Thermostat behavior -->
                    <div id="behaviorThermostat" class="behavior-section hidden">
                        <label>Setpoint (Â°F): <input type="number" id="thermostatSetpoint" min="0" max="212"></label>
                        <label>Deadband (Â±Â°F): <input type="number" id="thermostatDeadband" min="1" max="10"></label>
                        <label>Duty Cycle (%): <input type="number" id="thermostatDuty" min="0" max="100"></label>
                        <p style="font-size: 10px; color: #888; margin: 5px 0;">Cycles on/off to maintain temperature. Duty % is avg time running.</p>
                    </div>
                    
                    <!-- Charging behavior -->
                    <div id="behaviorCharging" class="behavior-section hidden">
                        <label>Battery (kWh): <input type="number" id="chargingBatteryKwh" min="0" step="0.01"></label>
                        <label>Charge Rate (kW): <input type="number" id="chargingRateKw" min="0" step="0.01"></label>
                        <label>Daily Use (kWh): <input type="number" id="chargingDailyUse" min="0" step="0.01"></label>
                        <p style="font-size: 10px; color: #888; margin: 5px 0;">Charges battery, tapers as it fills. Daily use is energy consumed per day.</p>
                    </div>
                    
                    <button id="applyLoadChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- HINT POPUP -->
    <div id="hintPopup" class="hint-popup hidden">
        <h3 id="hintTitle">Hint</h3>
        <p id="hintText"></p>
        <button id="hintDismiss">Got it!</button>
    </div>
    
    <!-- ACHIEVEMENT OVERLAY -->
    <div id="achievementOverlay" class="achievement-overlay">
        <div class="achievement-content">
            <h1 id="achievementTitle">System Operational!</h1>
            <div class="achievement-stats" id="achievementStats">
                <!-- Populated by JavaScript -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="achievementClose">Continue Building</button>
                <button id="startSimulation" style="background: #5cb85c;">â–¶ Start Simulation</button>
            </div>
        </div>
    </div>
    
    <!-- BILL OF MATERIALS OVERLAY -->
    <div id="bomOverlay" class="achievement-overlay" style="display: none;">
        <div class="achievement-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h1>Bill of Materials</h1>
            <div id="bomContent">
                <!-- Populated by JavaScript -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="bomExportBtn" style="background: #5bc0de;">Export BOM</button>
                <button id="bomCloseBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SOLAR BUILDER & SIMULATOR - MAIN SCRIPT
        // ============================================
        
        // ============================================
        // CONSTANTS AND PRESETS
        // ============================================
        
        const PANEL_WIDTH = 100;
        const PANEL_HEIGHT = 60;
        const BATTERY_WIDTH = 80;
        const BATTERY_HEIGHT = 120;
        const CONTROLLER_WIDTH = 140;
        const CONTROLLER_HEIGHT = 100;
        const BREAKER_WIDTH = 60;
        const BREAKER_HEIGHT = 80;
        const COMBINER_WIDTH = 100;
        const COMBINER_HEIGHT = 80;
        const SOLAR_COMBINER_WIDTH = 120;
        const SOLAR_COMBINER_HEIGHT = 100;
        const HANDLE_RADIUS = 10;
        
        // Common breaker sizes (Amps)
        const BREAKER_SIZES = [5, 10, 16, 20, 30, 40, 50, 63, 80, 100];
        
        // Wire gauge specifications (AWG size, ampacity, visual width, name)
        const WIRE_GAUGE_SPECS = {
            '18': { gauge: '18', amps: 14, width: 1, name: '18 AWG' },
            '16': { gauge: '16', amps: 18, width: 1.5, name: '16 AWG' },
            '14': { gauge: '14', amps: 20, width: 2, name: '14 AWG' },
            '12': { gauge: '12', amps: 25, width: 2.5, name: '12 AWG' },
            '10': { gauge: '10', amps: 30, width: 3, name: '10 AWG' },
            '8': { gauge: '8', amps: 40, width: 3.5, name: '8 AWG' },
            '6': { gauge: '6', amps: 55, width: 4, name: '6 AWG' },
            '4': { gauge: '4', amps: 70, width: 4.5, name: '4 AWG' },
            '2': { gauge: '2', amps: 95, width: 5, name: '2 AWG' },
            '1/0': { gauge: '1/0', amps: 125, width: 5.5, name: '1/0 AWG' },
            '2/0': { gauge: '2/0', amps: 145, width: 6, name: '2/0 AWG' },
            '3/0': { gauge: '3/0', amps: 165, width: 6.5, name: '3/0 AWG' },
            '4/0': { gauge: '4/0', amps: 195, width: 7, name: '4/0 AWG' }
        };
        
        // Wire cost per foot by AWG size (default prices, user can override)
        const WIRE_COST_PER_FOOT = {
            '18': 0.15,
            '16': 0.18,
            '14': 0.22,
            '12': 0.28,
            '10': 0.35,
            '8': 0.50,
            '6': 0.75,
            '4': 1.10,
            '2': 1.60,
            '1/0': 2.20,
            '2/0': 2.80,
            '3/0': 3.50,
            '4/0': 4.20
        };
        
        // Safety margin for wire sizing (amps)
        const WIRE_SAFETY_MARGIN_AMPS = 5;
        
        // Function to auto-size breaker based on expected current
        function autosizeBreaker(expectedAmps) {
            // Add 5-10A margin (use 25% above expected, minimum 5A margin)
            const targetAmps = expectedAmps * 1.25;
            const minTarget = expectedAmps + 5;
            const withMargin = Math.max(targetAmps, minTarget);
            
            // Find nearest breaker size that's >= withMargin
            for (const size of BREAKER_SIZES) {
                if (size >= withMargin) return size;
            }
            return BREAKER_SIZES[BREAKER_SIZES.length - 1]; // Return largest if exceeded
        }
        
        // Function to get wire gauge for given amperage
        function getWireGaugeForAmps(amps) {
            if (!amps || amps <= 0) {
                return { gauge: '10', amps: 30, width: 3, name: '10 AWG' }; // Default to 10 AWG for zero/negative amps
            }
            
            // Add safety margin
            const requiredAmps = amps + WIRE_SAFETY_MARGIN_AMPS;
            
            // Sort gauges by ampacity in ascending order (smallest first)
            const sortedGauges = Object.entries(WIRE_GAUGE_SPECS)
                .sort((a, b) => a[1].amps - b[1].amps);
            
            // Find the smallest gauge that can handle the required current
            for (const [gauge, spec] of sortedGauges) {
                if (requiredAmps <= spec.amps) {
                    return { gauge, ...spec };
                }
            }
            
            // If amps exceed all ratings, return the largest gauge
            const largestGauge = sortedGauges[sortedGauges.length - 1];
            return { gauge: largestGauge[0], ...largestGauge[1] };
        }
        
        // Component presets
        const PANEL_PRESETS = [
            { name: "Generic 250W", wmp: 250, vmp: 30.5, voc: 37.5, isc: 8.8, imp: 8.2, cost: 120 },
            { name: "Alrska Flexible 100W", wmp: 100, vmp: 18.0, voc: 21.6, isc: 6.1, imp: 5.56, cost: 80 },
            { name: "Ecoflow 400W", wmp: 400, vmp: 41.0, voc: 48.0, isc: 11.0, imp: 9.76, cost: 300 },
            { name: "Trina Solar 260W", wmp: 260, vmp: 32.5, voc: 39.5, isc: 9.75, imp: 8.0, cost: 150 },
            { name: "REC Alpha 410W", wmp: 410, vmp: 33.2, voc: 40.1, isc: 12.8, imp: 12.35, cost: 280 }
        ];
        
        const BATTERY_PRESETS = [
            { name: "12V 100Ah LiFePO4", voltage: 12.8, ah: 100, maxDischarge: 100, cost: 400 },
            { name: "12V 200Ah LiFePO4", voltage: 12.8, ah: 200, maxDischarge: 200, cost: 700 },
            { name: "12V 100Ah AGM", voltage: 12.0, ah: 100, maxDischarge: 50, cost: 200 },
            { name: "48V 100Ah LiFePO4", voltage: 51.2, ah: 100, maxDischarge: 100, cost: 1500 }
        ];
        
        const CONTROLLER_PRESETS = [
            { 
                name: "Generic MPPT 150/50", 
                type: "charge_controller",
                maxVoc: 150, maxIsc: 50, maxWmp: 2400,
                minVmp: 15, mppVoltageMin: 18, mppVoltageMax: 145,
                ratedChargeCurrent: 50, 
                supportedVoltages: [12, 24, 48],
                cost: 250
            },
            { 
                name: "Victron SmartSolar 150/35", 
                type: "charge_controller",
                maxVoc: 150, maxIsc: 35, maxWmp: 2000,
                minVmp: 15, mppVoltageMin: 18, mppVoltageMax: 145,
                ratedChargeCurrent: 35, 
                supportedVoltages: [12, 24, 36, 48],
                cost: 400
            },
            { 
                name: "PowMR 5000W", 
                type: "hybrid_inverter",
                maxVoc: 145, maxIsc: 80, maxWmp: 5000,
                minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 115,
                ratedChargeCurrent: 80, 
                supportedVoltages: [48],
                maxACOutputW: 5000,
                cost: 600
            },
            { 
                name: "EcoFlow DELTA Pro", 
                type: "all_in_one",
                maxVoc: 150, maxIsc: 15, maxWmp: 1600,
                minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 145,
                ratedChargeCurrent: 30, 
                supportedVoltages: [48],
                internalBatteryKWh: 3.6,
                maxACOutputW: 3600,
                smartBatteryPorts: 2,
                smartBatteryKWh: 3.6,
                parallelCapable: true,
                ecosystemType: 'ecoflow',
                cost: 3500
            },
            { 
                name: "EcoFlow DELTA 2", 
                type: "all_in_one",
                maxVoc: 60, maxIsc: 15, maxWmp: 500,
                minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 60,
                ratedChargeCurrent: 15, 
                supportedVoltages: [48],
                internalBatteryKWh: 1.0,
                maxACOutputW: 1800,
                smartBatteryPorts: 1,
                smartBatteryKWh: 1.0,
                ecosystemType: 'ecoflow',
                cost: 1000
            },
            { 
                name: "EcoFlow DELTA 2 Max", 
                type: "all_in_one",
                maxVoc: 60, maxIsc: 15, maxWmp: 500,
                minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 60,
                ratedChargeCurrent: 15, 
                supportedVoltages: [48],
                internalBatteryKWh: 2.0,
                maxACOutputW: 2400,
                smartBatteryPorts: 2,
                smartBatteryKWh: 2.0,
                ecosystemType: 'ecoflow',
                cost: 2100
            },
            { 
                name: "EcoFlow RIVER 2", 
                type: "all_in_one",
                maxVoc: 60, maxIsc: 10, maxWmp: 220,
                minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 60,
                ratedChargeCurrent: 8, 
                supportedVoltages: [48],
                internalBatteryKWh: 0.256,
                maxACOutputW: 300,
                ecosystemType: 'ecoflow',
                cost: 250
            },
            { 
                name: "EcoFlow RIVER 2 Max", 
                type: "all_in_one",
                maxVoc: 60, maxIsc: 13, maxWmp: 220,
                minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 60,
                ratedChargeCurrent: 10, 
                supportedVoltages: [48],
                internalBatteryKWh: 0.512,
                maxACOutputW: 500,
                smartBatteryPorts: 1,
                smartBatteryKWh: 0.512,
                ecosystemType: 'ecoflow',
                cost: 450
            },
            { 
                name: "EcoFlow RIVER 2 Pro", 
                type: "all_in_one",
                maxVoc: 60, maxIsc: 13, maxWmp: 220,
                minVmp: 11, mppVoltageMin: 11, mppVoltageMax: 60,
                ratedChargeCurrent: 10, 
                supportedVoltages: [48],
                internalBatteryKWh: 0.768,
                maxACOutputW: 800,
                smartBatteryPorts: 1,
                smartBatteryKWh: 0.768,
                ecosystemType: 'ecoflow',
                cost: 600
            },
            { 
                name: "Generic MPPT 100/20", 
                type: "charge_controller",
                maxVoc: 100, maxIsc: 20, maxWmp: 520,
                minVmp: 15, mppVoltageMin: 18, mppVoltageMax: 95,
                ratedChargeCurrent: 20, 
                supportedVoltages: [12, 24],
                cost: 80
            }
        ];
        
        const BREAKER_PRESETS = [
            { name: "DC Breaker 10A", rating: 10, maxVoltage: 150, cost: 15 },
            { name: "DC Breaker 20A", rating: 20, maxVoltage: 150, cost: 18 },
            { name: "DC Breaker 30A", rating: 30, maxVoltage: 150, cost: 22 },
            { name: "DC Breaker 40A", rating: 40, maxVoltage: 150, cost: 25 },
            { name: "DC Breaker 50A", rating: 50, maxVoltage: 150, cost: 30 },
            { name: "DC Breaker 63A", rating: 63, maxVoltage: 150, cost: 35 }
        ];
        
        const COMBINER_PRESETS = [
            { name: "2-String Combiner", inputs: 2, maxAmpsPerInput: 15, cost: 30 },
            { name: "4-String Combiner", inputs: 4, maxAmpsPerInput: 15, cost: 50 },
            { name: "6-String Combiner", inputs: 6, maxAmpsPerInput: 15, cost: 70 }
        ];
        
        const SOLAR_COMBINER_PRESETS = [
            { name: "2-String Solar Combiner Box", inputs: 2, breakerRating: 15, maxVoltage: 150, cost: 60 },
            { name: "4-String Solar Combiner Box", inputs: 4, breakerRating: 15, maxVoltage: 150, cost: 100 },
            { name: "6-String Solar Combiner Box", inputs: 6, breakerRating: 15, maxVoltage: 150, cost: 140 }
        ];
        
        // Calculate max watts based on battery voltage and charge current
        // Charging voltage is typically ~1.2x nominal (14.4V for 12V, 28.8V for 24V, 57.6V for 48V)
        // Also respects the controller's maxWmp (max PV input) if specified
        function getMaxWattsForController(controller, batteryVoltage) {
            const chargingVoltage = batteryVoltage * 1.2;
            const calculatedMax = Math.round(controller.specs.ratedChargeCurrent * chargingVoltage);
            
            // If controller has a maxWmp limit, use the lower of the two
            if (controller.specs.maxWmp && controller.specs.maxWmp > 0) {
                return Math.min(calculatedMax, controller.specs.maxWmp);
            }
            return calculatedMax;
        }
        
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentMode = 'build'; // 'build', 'live', or 'simulate'
        
        // ============================================
        // LIVE VIEW MODULE
        // ============================================
        const LiveView = {
            // State management
            state: {
                active: false,
                loadStates: {},      // { loadId: true/false }
                breakerStates: {},   // { breakerId: { isClosed: true/false, wasTripped: false } }
                powerFlow: {},       // { connectionId: { watts, amps, voltage, direction } }
                powerFlowCache: {}   // Cache for power flow calculations
            },
            
            // Power flow calculations
            PowerFlow: {
                calculate: function() {
                    LiveView.state.powerFlow = {};
                    
                    // Calculate DC power flow (solar â†’ controller â†’ battery)
                    const controllers = allItems.filter(i => i.type === 'controller');
                    controllers.forEach(controller => {
                        // Calculate array output
                        const arraySpecs = calculateConnectedArraySpecs(controller);
                        const arrayWatts = arraySpecs.wmp || 0;
                        
                        // Find connections from panels to controller
                        if (controller.handles?.pvPositive?.connectedTo && controller.handles?.pvNegative?.connectedTo) {
                            controller.handles.pvPositive.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Estimate current based on array specs
                                    const voltage = arraySpecs.vmp || arraySpecs.voc || 48;
                                    const amps = arrayWatts / voltage;
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: arrayWatts / (controller.handles.pvPositive.connectedTo.length || 1),
                                        amps: amps / (controller.handles.pvPositive.connectedTo.length || 1),
                                        voltage: voltage,
                                        direction: 'to-controller'
                                    };
                                }
                            });
                        }
                        
                        // Calculate AC output from controller
                        if (controller.handles?.acOutput) {
                            controller.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // AC output is limited by controller max AC output
                                    const maxACWatts = controller.specs.maxACOutputW || 0;
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: maxACWatts,
                                        amps: maxACWatts / 120, // Default 120V
                                        voltage: 120,
                                        direction: 'from-controller'
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate AC power flow (controller â†’ breaker â†’ outlet â†’ load)
                    const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                    acBreakers.forEach(breaker => {
                        // Use unified breaker state checking
                        if (!LiveView.BreakerManager.isBreakerClosed(breaker)) return;
                        
                        // Verify breaker is connected to a power source
                        if (!hasPowerSourceConnection(breaker)) return;
                        
                        // Calculate circuit amperage
                        const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                        
                        // Update connections from breaker to outlets
                        // Show power flow even when no loads are connected (circuit is live)
                        if (breaker.handles?.loadOut) {
                            breaker.handles.loadOut.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const voltage = breaker.specs.voltage || 120;
                                    const totalWatts = circuitInfo.totalWatts;
                                    // Set power flow even if watts is 0 - circuit is live
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: totalWatts,
                                        amps: circuitInfo.totalAmps,
                                        voltage: voltage,
                                        direction: 'from-breaker',
                                        isLive: true // Mark as live circuit
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate AC power flow for breaker panel circuits
                    const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                    breakerPanels.forEach(panel => {
                        if (panel.mainBreakerOn === false) return;
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        
                        for (let i = 0; i < 8; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = panel.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) continue;
                            
                            // Verify panel is connected to a power source
                            if (!hasPowerSourceConnection(panel)) continue;
                            
                            const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, circuitHandle);
                            
                            // Update connections from circuit handle to outlets
                            if (circuitHandle.connectedTo) {
                                circuitHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        const voltage = circuitHandle.voltage || 120;
                                        const totalWatts = circuitInfo.totalWatts;
                                        // Set power flow even if watts is 0 - circuit is live
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: totalWatts,
                                            amps: circuitInfo.totalAmps,
                                            voltage: voltage,
                                            direction: 'from-breaker',
                                            isLive: true // Mark as live circuit
                                        };
                                    }
                                });
                            }
                        }
                    });
                    
                    // Calculate AC power flow for spider box circuits
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    spiderBoxes.forEach(spiderbox => {
                        if (!spiderbox.handles) return;
                        
                        // Check each circuit
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) continue;
                            
                            // Verify spider box is connected to a power source
                            if (!hasPowerSourceConnection(spiderbox)) continue;
                            
                            // Calculate circuit info (spider box circuits work like breaker panel circuits)
                            const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, circuitHandle);
                            
                            // Update connections from circuit handle to outlets
                            if (circuitHandle.connectedTo) {
                                circuitHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        const voltage = circuitHandle.voltage || 120;
                                        const totalWatts = circuitInfo.totalWatts;
                                        // Set power flow even if watts is 0 - circuit is live
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: totalWatts,
                                            amps: circuitInfo.totalAmps,
                                            voltage: voltage,
                                            direction: 'from-breaker',
                                            isLive: true // Mark as live circuit
                                        };
                                    }
                                });
                            }
                        }
                    });
                    
                    // Calculate power flow for outlet-to-load connections
                    const outlets = allItems.filter(i => i.type === 'acoutlet');
                    outlets.forEach(outlet => {
                        // Check if outlet is live
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) return;
                        
                        const outletVoltage = outlet.specs.voltage || 120;
                        
                        // Check connections from outlet to loads
                        if (outlet.handles?.load) {
                            outlet.handles.load.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Find the load
                                    const load = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acload'
                                    );
                                    if (load) {
                                        const loadWatts = LiveView.state.loadStates[load.id] ? getLoadWatts(load) : 0;
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: loadWatts,
                                            amps: loadWatts / outletVoltage,
                                            voltage: outletVoltage,
                                            direction: 'to-load',
                                            isLive: true
                                        };
                                    }
                                }
                            });
                        }
                        
                        // Check daisy-chain connections (outlet to outlet)
                        if (outlet.handles?.output) {
                            outlet.handles.output.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Check if this connects to another outlet's input
                                    const otherOutlet = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acoutlet' &&
                                        i.id !== outlet.id
                                    );
                                    if (otherOutlet) {
                                        // Calculate total power downstream from this outlet
                                        const downstreamInfo = LiveView.PowerFlow.calculateDownstreamPower(otherOutlet);
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: downstreamInfo.totalWatts,
                                            amps: downstreamInfo.totalAmps,
                                            voltage: outletVoltage,
                                            direction: 'to-outlet',
                                            isLive: true
                                        };
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for parallel connections (Delta Pro to double voltage hub)
                    controllers.forEach(controller => {
                        if (controller.handles?.parallelPort) {
                            controller.handles.parallelPort.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const targetItem = allItems.find(i => 
                                        i.id === connObj.targetItemId || i.id === connObj.sourceItemId
                                    );
                                    if (targetItem && targetItem.type === 'doublevoltagehub') {
                                        // Calculate AC output from controller (parallel connection)
                                        const arraySpecs = calculateConnectedArraySpecs(controller);
                                        const dcInputWatts = arraySpecs.wmp || 0;
                                        const acOutputWatts = Math.min(dcInputWatts, controller.specs.maxACOutputW || 0);
                                        
                                        // Mark as live when connected (controller has power capability or internal battery)
                                        const hasPowerSource = dcInputWatts > 0 || controller.specs.internalBatteryKWh > 0;
                                        
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: acOutputWatts,
                                            amps: acOutputWatts / 120,
                                            voltage: 120, // Each unit outputs 120V
                                            direction: 'to-hub',
                                            isLive: true // Always live when connected to hub
                                        };
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for double voltage hub AC output (240V to breaker panel/spiderbox)
                    const hubs = allItems.filter(i => i.type === 'doublevoltagehub');
                    hubs.forEach(hub => {
                        // Check if hub has both inputs connected (both Delta Pros connected)
                        const input1Connected = hub.handles?.input1?.connectedTo?.length > 0;
                        const input2Connected = hub.handles?.input2?.connectedTo?.length > 0;
                        
                        if (input1Connected && input2Connected && hub.handles?.acOutput) {
                            // Calculate total power from both inputs
                            let totalWatts = 0;
                            let hasLiveInput = false;
                            
                            hub.handles.input1.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const powerFlow = LiveView.state.powerFlow[connObj.id];
                                    if (powerFlow) {
                                        totalWatts += powerFlow.watts || 0;
                                        if (powerFlow.isLive) hasLiveInput = true;
                                    }
                                }
                            });
                            hub.handles.input2.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const powerFlow = LiveView.state.powerFlow[connObj.id];
                                    if (powerFlow) {
                                        totalWatts += powerFlow.watts || 0;
                                        if (powerFlow.isLive) hasLiveInput = true;
                                    }
                                }
                            });
                            
                            // Mark as live if both inputs are connected and at least one has live power
                            hub.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: totalWatts,
                                        amps: totalWatts / 240, // 240V split-phase
                                        voltage: 240,
                                        direction: 'from-hub',
                                        isLive: hasLiveInput || (input1Connected && input2Connected) // Live when both inputs connected
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for controller/hub to breaker panel connections
                    // Reuse controllers variable from DC power flow calculation above
                    controllers.forEach(controller => {
                        // Check AC output connections
                        if (controller.handles?.acOutput) {
                            controller.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const targetItem = allItems.find(i => 
                                        i.id === connObj.targetItemId || i.id === connObj.sourceItemId
                                    );
                                    if (targetItem && (targetItem.type === 'breakerpanel' || targetItem.type === 'acbreaker' || targetItem.type === 'spiderbox')) {
                                        // Calculate AC output from controller
                                        const arraySpecs = calculateConnectedArraySpecs(controller);
                                        const dcInputWatts = arraySpecs.wmp || 0;
                                        const acOutputWatts = Math.min(dcInputWatts, controller.specs.maxACOutputW || 0);
                                        
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: acOutputWatts,
                                            amps: acOutputWatts / 120, // Assume 120V for calculation
                                            voltage: 120,
                                            direction: 'from-controller',
                                            isLive: acOutputWatts > 0
                                        };
                                    }
                                }
                            });
                        }
                    });
                },
                
                // Helper function to calculate downstream power from an outlet
                calculateDownstreamPower: function(outlet) {
                    let totalWatts = 0;
                    let totalAmps = 0;
                    const outletVoltage = outlet.specs.voltage || 120;
                    const visited = new Set();
                    
                    function traceDownstream(currentOutlet) {
                        if (visited.has(currentOutlet.id)) return;
                        visited.add(currentOutlet.id);
                        
                        // Check loads connected to this outlet
                        if (currentOutlet.handles?.load) {
                            currentOutlet.handles.load.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const load = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acload'
                                    );
                                    if (load && LiveView.state.loadStates[load.id]) {
                                        totalWatts += getLoadWatts(load);
                                    }
                                }
                            });
                        }
                        
                        // Check downstream outlets
                        if (currentOutlet.handles?.output) {
                            currentOutlet.handles.output.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const nextOutlet = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acoutlet' &&
                                        i.id !== currentOutlet.id
                                    );
                                    if (nextOutlet) {
                                        traceDownstream(nextOutlet);
                                    }
                                }
                            });
                        }
                    }
                    
                    traceDownstream(outlet);
                    totalAmps = totalWatts / outletVoltage;
                    return { totalWatts, totalAmps };
                },
                
                // Calculate AC circuit amperage for a breaker
                calculateACCircuit: function(breaker) {
                    // Use unified breaker state checking - must be closed AND not tripped
                    if (!breaker || !LiveView.BreakerManager.isBreakerClosed(breaker)) {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    // Get circuit voltage from breaker specs
                    let circuitVoltage = breaker.specs.voltage || 120;
                    
                    // For breaker panels and spider boxes, check the circuit voltage
                    if (breaker.handles?.circuitName) {
                        // This is a circuit from a breaker panel or spider box
                        const circuitHandle = Object.values(breaker.handles).find(h => h.circuitName);
                        if (circuitHandle && circuitHandle.voltage) {
                            circuitVoltage = circuitHandle.voltage;
                        }
                    }
                    
                    let totalWatts = 0;
                    const contributingLoads = [];
                    
                    // Trace from breaker output through all connected outlets
                    function traceCircuitFromHandle(handle, visited = new Set(), currentVoltage = circuitVoltage) {
                        if (!handle || !handle.connectedTo) return;
                        
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // Find the item on the other end of this connection
                            // Check which item contains this handle
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            
                            let nextItem = null;
                            // Check if this handle belongs to the source item
                            if (sourceItem && sourceItem.handles && 
                                (connObj.sourceHandleId === handle.id || 
                                 Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                                // This handle is on the source item, so next item is the target
                                nextItem = targetItem;
                            } else if (targetItem && targetItem.handles && 
                                       (connObj.targetHandleId === handle.id ||
                                        Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                                // This handle is on the target item, so next item is the source
                                nextItem = sourceItem;
                            }
                            
                            if (!nextItem || visited.has(nextItem.id)) return;
                            visited.add(nextItem.id);
                            
                            // If it's an outlet, check for loads connected to it
                            if (nextItem.type === 'acoutlet') {
                                // Use outlet's voltage if specified, otherwise use circuit voltage
                                const outletVoltage = nextItem.specs?.voltage || nextItem.handles?.input?.voltage || currentVoltage;
                                
                                // Check load port for connected loads
                                if (nextItem.handles?.load) {
                                    nextItem.handles.load.connectedTo.forEach(loadConn => {
                                        const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                        if (loadConnObj) {
                                            // Find the load - could be source or target
                                            let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                            if (!load || load.type !== 'acload') {
                                                load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                            }
                                            
                                            if (load && load.type === 'acload') {
                                                // Check if load is ON
                                                if (LiveView.state.loadStates[load.id]) {
                                                    // Verify load voltage matches outlet voltage (or is compatible)
                                                    const loadVoltage = load.specs.voltage || 120;
                                                    if (loadVoltage === outletVoltage || (outletVoltage === 240 && loadVoltage === 120)) {
                                                        const loadWatts = getLoadWatts(load);
                                                        totalWatts += loadWatts;
                                                        contributingLoads.push({
                                                            id: load.id,
                                                            name: load.specs.name,
                                                            watts: loadWatts,
                                                            voltage: loadVoltage
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also trace through outlet output (daisy-chained outlets)
                                if (nextItem.handles?.output) {
                                    traceCircuitFromHandle(nextItem.handles.output, visited, outletVoltage);
                                }
                            }
                        });
                    }
                    
                    // Start tracing from breaker output
                    if (breaker.handles?.loadOut) {
                        traceCircuitFromHandle(breaker.handles.loadOut);
                    }
                    
                    // Calculate amps based on circuit voltage
                    // For 240V circuits, use 240V. For 120V circuits, use 120V.
                    // For split-phase (120V from 240V), still use 120V for calculation
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    
                    return {
                        totalWatts: totalWatts,
                        totalAmps: totalAmps,
                        loads: contributingLoads,
                        voltage: circuitVoltage
                    };
                },
                
                // Calculate AC circuit amperage for a breaker panel or spider box circuit handle
                calculateBreakerPanelCircuit: function(panel, circuitHandle) {
                    if (!panel || !circuitHandle || !circuitHandle.connectedTo) {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    // Use unified breaker state checking - must be closed AND not tripped
                    const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                    
                    // Check if it's a breaker panel or spider box
                    if (panel.type === 'breakerpanel') {
                        if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, circuitIndex)) {
                            return { totalWatts: 0, totalAmps: 0, loads: [] };
                        }
                    } else if (panel.type === 'spiderbox') {
                        if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(panel, circuitIndex)) {
                            return { totalWatts: 0, totalAmps: 0, loads: [] };
                        }
                    } else {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    const circuitVoltage = circuitHandle.voltage || 120;
                    let totalWatts = 0;
                    const contributingLoads = [];
                    const visited = new Set();
                    const visitedItems = new Set(); // Track visited items to prevent cross-circuit contamination
                    
                    // Track the original circuit handle ID to prevent tracing back to other circuits
                    const originalCircuitHandleId = circuitHandle.id;
                    
                    // Trace from circuit handle through all connected outlets
                    // IMPORTANT: Only trace from the specific circuit handle we're checking
                    function traceCircuitFromHandle(handle, currentVoltage = circuitVoltage) {
                        if (!handle || !handle.connectedTo || visited.has(handle.id)) return;
                        visited.add(handle.id);
                        
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // CRITICAL: Verify this connection is actually from our circuit handle
                            // The connection must have our handle ID on one end, and it must be the EXACT handle we're tracing from
                            const isFromOurHandle = (connObj.sourceHandleId === handle.id || connObj.targetHandleId === handle.id);
                            if (!isFromOurHandle) return;
                            
                            // Double-check: ensure the handle ID matches exactly (not just a substring match)
                            if (connObj.sourceHandleId !== handle.id && connObj.targetHandleId !== handle.id) return;
                            
                            // CRITICAL: If this is the initial circuit handle and the connection leads to another circuit handle, STOP
                            // This prevents any possibility of cross-circuit contamination at the source
                            if (handle.id === originalCircuitHandleId) {
                                const otherHandleId = connObj.sourceHandleId === handle.id ? connObj.targetHandleId : connObj.sourceHandleId;
                                if (otherHandleId && otherHandleId.startsWith(`${panel.id}-circuit-`) && otherHandleId !== originalCircuitHandleId) {
                                    return; // This connection goes to another circuit - don't follow it
                                }
                            }
                            
                            // CRITICAL: If this connection leads to another circuit handle on the same panel, STOP
                            // This prevents cross-circuit contamination
                            if (connObj.sourceHandleId !== handle.id && connObj.sourceHandleId.startsWith(`${panel.id}-circuit-`)) {
                                // This is a different circuit handle - don't follow it
                                if (connObj.sourceHandleId !== originalCircuitHandleId) return;
                            }
                            if (connObj.targetHandleId !== handle.id && connObj.targetHandleId.startsWith(`${panel.id}-circuit-`)) {
                                // This is a different circuit handle - don't follow it
                                if (connObj.targetHandleId !== originalCircuitHandleId) return;
                            }
                            
                            // Find the item on the other end of this connection (not the panel)
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            
                            let nextItem = null;
                            // The circuit handle is on the panel, so the next item is the one that's NOT the panel
                            if (sourceItem && sourceItem.id === panel.id) {
                                nextItem = targetItem;
                            } else if (targetItem && targetItem.id === panel.id) {
                                nextItem = sourceItem;
                            } else {
                                // Neither is the panel - this shouldn't happen, but handle it
                                if (sourceItem && sourceItem.handles && 
                                    (connObj.sourceHandleId === handle.id || 
                                     Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                                    nextItem = targetItem;
                                } else if (targetItem && targetItem.handles && 
                                           (connObj.targetHandleId === handle.id ||
                                            Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                                    nextItem = sourceItem;
                                }
                            }
                            
                            // CRITICAL: If nextItem is the panel itself, skip it (we're already past the circuit handle)
                            if (nextItem && nextItem.id === panel.id) return;
                            
                            // CRITICAL: If nextItem is another circuit handle on the panel, skip it
                            if (nextItem && nextItem.type === 'breakerpanel' && nextItem.id === panel.id) {
                                // Check if any of the handles on this item are other circuit handles
                                const otherCircuitHandle = Object.values(nextItem.handles || {}).find(h => 
                                    h.id && h.id.startsWith(`${panel.id}-circuit-`) && h.id !== originalCircuitHandleId
                                );
                                if (otherCircuitHandle) return; // Don't follow connections to other circuits
                            }
                            
                            if (!nextItem || visitedItems.has(nextItem.id)) return;
                            visitedItems.add(nextItem.id);
                            
                            // If it's an outlet, check for loads connected to it
                            if (nextItem.type === 'acoutlet') {
                                // CRITICAL: Verify this outlet is actually connected to our circuit
                                // We should only reach this outlet by tracing from our circuit handle
                                // Double-check that the outlet's input is connected to a handle we've visited (part of our circuit)
                                const outletInputHandle = nextItem.handles?.input;
                                if (!outletInputHandle) return;
                                
                                // Verify the outlet input is connected to our circuit path
                                // If we reached here through tracing, the connection should be valid, but verify anyway
                                let outletConnectedToOurPath = false;
                                if (outletInputHandle.connectedTo) {
                                    for (const outletConn of outletInputHandle.connectedTo) {
                                        const outletConnObj = connections.find(c => c.id === outletConn.connectionId);
                                        if (outletConnObj) {
                                            // Check if either end of this connection is a handle we've visited (part of our circuit)
                                            if (visited.has(outletConnObj.sourceHandleId) || visited.has(outletConnObj.targetHandleId)) {
                                                outletConnectedToOurPath = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // If we can't verify the outlet is connected to our circuit path, skip it
                                if (!outletConnectedToOurPath) return;
                                
                                const outletVoltage = nextItem.specs?.voltage || nextItem.handles?.input?.voltage || currentVoltage;
                                
                                // Check load port for connected loads
                                if (nextItem.handles?.load) {
                                    nextItem.handles.load.connectedTo.forEach(loadConn => {
                                        const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                        if (loadConnObj) {
                                            let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                            if (!load || load.type !== 'acload') {
                                                load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                            }
                                            
                                            if (load && load.type === 'acload') {
                                                if (LiveView.state.loadStates[load.id]) {
                                                    const loadVoltage = load.specs.voltage || 120;
                                                    if (loadVoltage === outletVoltage || (outletVoltage === 240 && loadVoltage === 120)) {
                                                        const loadWatts = getLoadWatts(load);
                                                        totalWatts += loadWatts;
                                                        contributingLoads.push({
                                                            id: load.id,
                                                            name: load.specs.name,
                                                            watts: loadWatts,
                                                            voltage: loadVoltage
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also trace through outlet output (daisy-chained outlets)
                                // IMPORTANT: Only trace if this outlet's output is actually connected
                                // and we haven't already visited it from a different circuit
                                if (nextItem.handles?.output && !visited.has(nextItem.handles.output.id)) {
                                    // Verify the outlet's output is connected to something
                                    if (nextItem.handles.output.connectedTo && nextItem.handles.output.connectedTo.length > 0) {
                                        // CRITICAL: Check that the output doesn't connect back to another circuit handle
                                        let connectsToOtherCircuit = false;
                                        for (const outputConn of nextItem.handles.output.connectedTo) {
                                            const outputConnObj = connections.find(c => c.id === outputConn.connectionId);
                                            if (outputConnObj) {
                                                // Check if this connection leads to another circuit handle on the panel
                                                if (outputConnObj.sourceHandleId && outputConnObj.sourceHandleId.startsWith(`${panel.id}-circuit-`)) {
                                                    if (outputConnObj.sourceHandleId !== originalCircuitHandleId) {
                                                        connectsToOtherCircuit = true;
                                                        break;
                                                    }
                                                }
                                                if (outputConnObj.targetHandleId && outputConnObj.targetHandleId.startsWith(`${panel.id}-circuit-`)) {
                                                    if (outputConnObj.targetHandleId !== originalCircuitHandleId) {
                                                        connectsToOtherCircuit = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        
                                        // Only trace if it doesn't connect to another circuit
                                        if (!connectsToOtherCircuit) {
                                            traceCircuitFromHandle(nextItem.handles.output, outletVoltage);
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Start tracing from circuit handle - ONLY trace from this specific handle
                    // Clear visited sets to ensure we start fresh for each circuit calculation
                    visited.clear();
                    visitedItems.clear();
                    traceCircuitFromHandle(circuitHandle);
                    
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    
                    return {
                        totalWatts: totalWatts,
                        totalAmps: totalAmps,
                        loads: contributingLoads,
                        voltage: circuitVoltage
                    };
                }
            },
            
            // Breaker management
            BreakerManager: {
                // Helper function to get breaker state from LiveView.state
                getBreakerState: function(breakerId) {
                    return LiveView.state.breakerStates[breakerId] || null;
                },
                
                // Check if a regular AC breaker is closed and not tripped
                isBreakerClosed: function(breaker) {
                    if (!breaker) return false;
                    const breakerState = LiveView.state.breakerStates[breaker.id];
                    // Breaker must be closed AND not tripped
                    return breaker.isClosed === true && !(breakerState && breakerState.wasTripped);
                },
                
                // Check if a breaker panel circuit is closed and not tripped
                isBreakerPanelCircuitClosed: function(panel, circuitIndex) {
                    if (!panel) return false;
                    // Check main breaker first
                    if (panel.mainBreakerOn === false) return false;
                    // Check circuit breaker state
                    const circuitOn = panel.breakerStates && panel.breakerStates[circuitIndex] !== false;
                    if (!circuitOn) return false;
                    // Check if tripped in live view state
                    const breakerId = `${panel.id}-circuit-${circuitIndex + 1}`;
                    const breakerState = LiveView.state.breakerStates[breakerId];
                    return !(breakerState && breakerState.wasTripped);
                },
                
                // Check if a spider box circuit is closed and not tripped
                isSpiderBoxCircuitClosed: function(spiderbox, circuitIndex) {
                    if (!spiderbox || !spiderbox.handles) return false;
                    const handleKey = `circuit${circuitIndex + 1}`;
                    const circuitHandle = spiderbox.handles[handleKey];
                    if (!circuitHandle) return false;
                    // Check if circuit breaker is closed
                    const circuitOn = circuitHandle.isClosed !== false;
                    if (!circuitOn) return false;
                    // Check if tripped in live view state
                    const breakerId = `${spiderbox.id}-circuit-${circuitIndex + 1}`;
                    const breakerState = LiveView.state.breakerStates[breakerId];
                    return !(breakerState && breakerState.wasTripped);
                },
                
                checkTripping: function() {
                    // PHASE 1: Collect all breakers/circuits that need checking (before any state changes)
                    const acBreakersToCheck = [];
                    const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                    
                    acBreakers.forEach(breaker => {
                        // Only check if breaker is currently closed and not tripped
                        if (LiveView.BreakerManager.isBreakerClosed(breaker)) {
                            acBreakersToCheck.push(breaker);
                        }
                    });
                    
                    const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                    const panelCircuitsToCheck = [];
                    
                    breakerPanels.forEach(panel => {
                        // Check main breaker first
                        if (panel.mainBreakerOn === false) return;
                        
                        // Initialize breaker states if needed
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        
                        // Collect all circuits that need to be checked
                        for (let i = 0; i < 8; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = panel.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified helper to check if circuit is closed
                            if (LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) {
                                panelCircuitsToCheck.push({
                                    panel: panel,
                                    index: i,
                                    handle: circuitHandle,
                                    breakerId: `${panel.id}-circuit-${i + 1}`
                                });
                            }
                        }
                    });
                    
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    const spiderBoxCircuitsToCheck = [];
                    
                    spiderBoxes.forEach(spiderbox => {
                        if (!spiderbox.handles || !spiderbox.specs.circuits) return;
                        
                        // Collect all circuits that need to be checked
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified helper to check if circuit is closed
                            if (LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) {
                                spiderBoxCircuitsToCheck.push({
                                    spiderbox: spiderbox,
                                    index: i,
                                    handle: circuitHandle,
                                    breakerId: `${spiderbox.id}-circuit-${i + 1}`
                                });
                            }
                        }
                    });
                    
                    // PHASE 2: Calculate all circuit info (before any state changes)
                    const acBreakerResults = [];
                    acBreakersToCheck.forEach(breaker => {
                        const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                        const breakerRating = breaker.specs.rating || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            acBreakerResults.push({
                                breaker: breaker,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    const panelCircuitResults = [];
                    panelCircuitsToCheck.forEach(({ panel, index, handle, breakerId }) => {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, handle);
                        const breakerRating = handle.maxAmps || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            panelCircuitResults.push({
                                panel: panel,
                                index: index,
                                handle: handle,
                                breakerId: breakerId,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    const spiderBoxCircuitResults = [];
                    spiderBoxCircuitsToCheck.forEach(({ spiderbox, index, handle, breakerId }) => {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, handle);
                        const breakerRating = handle.maxAmps || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            spiderBoxCircuitResults.push({
                                spiderbox: spiderbox,
                                index: index,
                                handle: handle,
                                breakerId: breakerId,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    // PHASE 3: Apply state changes (all calculations done, now apply trips)
                    let anyTrips = false;
                    
                    acBreakerResults.forEach(({ breaker, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip the breaker - update both isClosed and LiveView.state atomically
                        breaker.isClosed = false;
                        if (!LiveView.state.breakerStates[breaker.id]) {
                            LiveView.state.breakerStates[breaker.id] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breaker.id].isClosed = false;
                            LiveView.state.breakerStates[breaker.id].wasTripped = true;
                        }
                        
                        // Show notification
                        showHint("âš ï¸ Breaker Tripped", 
                            `Circuit breaker (${breakerRating}A) has tripped due to overcurrent (${circuitInfo.totalAmps.toFixed(1)}A). All loads on this circuit have been turned off.`);
                        
                        // Turn off all loads on this circuit
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    panelCircuitResults.forEach(({ panel, index, handle, breakerId, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip ONLY this specific circuit breaker - update both states atomically
                        panel.breakerStates[index] = false;
                        
                        if (!LiveView.state.breakerStates[breakerId]) {
                            LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breakerId].isClosed = false;
                            LiveView.state.breakerStates[breakerId].wasTripped = true;
                        }
                        
                        // Show notification
                        showHint("âš ï¸ Breaker Tripped", 
                            `Circuit ${handle.circuitName} (${breakerRating}A) has tripped due to overcurrent (${circuitInfo.totalAmps.toFixed(1)}A). All loads on this circuit have been turned off.`);
                        
                        // Turn off all loads on this circuit ONLY
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    spiderBoxCircuitResults.forEach(({ spiderbox, index, handle, breakerId, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip ONLY this specific circuit breaker - update both states atomically
                        handle.isClosed = false;
                        
                        if (!LiveView.state.breakerStates[breakerId]) {
                            LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breakerId].isClosed = false;
                            LiveView.state.breakerStates[breakerId].wasTripped = true;
                        }
                        
                        // Show notification
                        showHint("âš ï¸ Breaker Tripped", 
                            `Spider Box Circuit ${handle.circuitName} (${breakerRating}A) has tripped due to overcurrent (${circuitInfo.totalAmps.toFixed(1)}A). All loads on this circuit have been turned off.`);
                        
                        // Turn off all loads on this circuit ONLY
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    // Schedule update if any breakers tripped
                    if (anyTrips) {
                        // Immediately recalculate power flow to clear isLive for tripped circuits
                        LiveView.PowerFlow.calculate();
                        LiveView.Animation.scheduleUpdate();
                    }
                }
            },
            
            // Display updates
            Display: {
                update: function() {
                    if (!LiveView.state.active) return;
                    
                    // Calculate total DC and AC power
                    let totalDCWatts = 0;
                    let totalACWatts = 0;
                    
                    // Sum DC power from all controllers
                    const controllers = allItems.filter(i => i.type === 'controller');
                    controllers.forEach(controller => {
                        const arraySpecs = calculateConnectedArraySpecs(controller);
                        totalDCWatts += arraySpecs.wmp || 0;
                    });
                    
                    // Helper function to check if a load's circuit is live (breaker is on and not tripped)
                    // Reuse checkLoadCircuitStatus for consistency
                    function isLoadCircuitLive(load) {
                        const circuitStatus = checkLoadCircuitStatus(load);
                        return circuitStatus.isLive;
                    }
                    
                    // Sum AC power from all ON loads that are on live circuits
                    // (Load shutdown is now handled in event handlers for immediate response)
                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                        if (LiveView.state.loadStates[loadId]) {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                // Check if circuit is live
                                if (isLoadCircuitLive(load)) {
                                    // Circuit is live - count power
                                    totalACWatts += getLoadWatts(load);
                                }
                            }
                        }
                    });
                    
                    // Update power summary (only if values changed)
                    const dcWattsEl = document.getElementById('liveViewDCWatts');
                    const acWattsEl = document.getElementById('liveViewACWatts');
                    if (dcWattsEl) {
                        const newText = totalDCWatts.toFixed(0);
                        if (dcWattsEl.textContent !== newText) {
                            dcWattsEl.textContent = newText;
                        }
                    }
                    if (acWattsEl) {
                        const newText = totalACWatts.toFixed(0);
                        if (acWattsEl.textContent !== newText) {
                            acWattsEl.textContent = newText;
                        }
                    }
                    
                    // Calculate battery level
                    let maxBatteryKwh = 0;
                    controllers.forEach(controller => {
                        const batterySpecs = calculateConnectedBatterySpecs(controller);
                        maxBatteryKwh += batterySpecs.kWh || 0;
                    });
                    
                    // For now, assume battery starts at 50% and changes based on net power
                    const batteryPercent = maxBatteryKwh > 0 ? 50 : 0; // Simplified
                    
                    const batteryLevelEl = document.getElementById('liveViewBatteryLevel');
                    const batteryPercentEl = document.getElementById('liveViewBatteryPercent');
                    if (batteryLevelEl) {
                        const newText = (maxBatteryKwh * 0.5).toFixed(1);
                        if (batteryLevelEl.textContent !== newText) {
                            batteryLevelEl.textContent = newText;
                        }
                    }
                    if (batteryPercentEl) {
                        const newText = batteryPercent.toFixed(0);
                        if (batteryPercentEl.textContent !== newText) {
                            batteryPercentEl.textContent = newText;
                        }
                    }
                }
            },
            
            // Animation (event-driven updates)
            Animation: {
                updateScheduled: false,
                updateTimeout: null,
                
                start: function() {
                    // No continuous loop - updates will be triggered by events
                    // Perform initial update
                    LiveView.Animation.update();
                },
                
                stop: function() {
                    // Clear any pending updates
                    if (LiveView.Animation.updateTimeout) {
                        clearTimeout(LiveView.Animation.updateTimeout);
                        LiveView.Animation.updateTimeout = null;
                    }
                    LiveView.Animation.updateScheduled = false;
                },
                
                // Perform a full update cycle
                update: function() {
                    if (!LiveView.state.active) return;
                    
                    // Calculate power flow
                    LiveView.PowerFlow.calculate();
                    
                    // Check breaker tripping
                    LiveView.BreakerManager.checkTripping();
                    
                    // Update displays
                    LiveView.Display.update();
                    
                    // Re-render to show changes
                    render();
                    
                    LiveView.Animation.updateScheduled = false;
                },
                
                // Schedule an update (debounced to prevent excessive renders)
                scheduleUpdate: function() {
                    if (!LiveView.state.active) return;
                    
                    // If already scheduled, don't schedule again
                    if (LiveView.Animation.updateScheduled) return;
                    
                    LiveView.Animation.updateScheduled = true;
                    
                    // Clear any existing timeout
                    if (LiveView.Animation.updateTimeout) {
                        clearTimeout(LiveView.Animation.updateTimeout);
                    }
                    
                    // Schedule update on next frame (debounced)
                    LiveView.Animation.updateTimeout = requestAnimationFrame(() => {
                        LiveView.Animation.update();
                    });
                }
            },
            
            // Main functions
            initialize: function() {
                // Validate system
                const controllers = allItems.filter(i => i.type === 'controller');
                if (controllers.length === 0) {
                    showHint("âš ï¸ No Controller", "You need at least one controller to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                // Check for panels and batteries
                const panels = allItems.filter(i => i.type === 'panel');
                const batteries = allItems.filter(i => i.type === 'battery' || i.type === 'smartbattery');
                
                let hasPanels = false;
                let hasBatteries = false;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    if (arraySpecs.wmp > 0) hasPanels = true;
                    if (batterySpecs.kWh > 0) hasBatteries = true;
                });
                
                if (!hasPanels && panels.length === 0) {
                    showHint("âš ï¸ No Solar Panels", "You need connected solar panels to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                if (!hasBatteries && batteries.length === 0) {
                    showHint("âš ï¸ No Batteries", "You need connected batteries to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                // Initialize live view state
                LiveView.state.active = true;
                LiveView.state.loadStates = {};
                LiveView.state.breakerStates = {};
                LiveView.state.powerFlow = {};
                LiveView.state.powerFlowCache = {};
                
                // Initialize all loads to OFF
                allItems.filter(i => i.type === 'acload').forEach(load => {
                    LiveView.state.loadStates[load.id] = false;
                });
                
                // Initialize breaker states (use current state, but track separately)
                allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker').forEach(breaker => {
                    LiveView.state.breakerStates[breaker.id] = {
                        isClosed: breaker.isClosed !== false,
                        wasTripped: false
                    };
                });
                
                // Start live view (initial update)
                LiveView.Animation.start();
            },
            
            stop: function() {
                LiveView.Animation.stop();
                LiveView.state.active = false;
            }
        };
        
        // Legacy state variables - synced with LiveView.state for backward compatibility
        // These are getters/setters that proxy to LiveView.state
        Object.defineProperty(window, 'liveViewActive', {
            get: function() { return LiveView.state.active; },
            set: function(val) { LiveView.state.active = val; }
        });
        Object.defineProperty(window, 'liveViewLoadStates', {
            get: function() { return LiveView.state.loadStates; },
            set: function(val) { LiveView.state.loadStates = val; }
        });
        Object.defineProperty(window, 'liveViewBreakerStates', {
            get: function() { return LiveView.state.breakerStates; },
            set: function(val) { LiveView.state.breakerStates = val; }
        });
        Object.defineProperty(window, 'liveViewPowerFlow', {
            get: function() { return LiveView.state.powerFlow; },
            set: function(val) { LiveView.state.powerFlow = val; }
        });
        let allItems = [];
        let connections = [];
        let selectedItem = null;
        let selectedConnection = null;
        let itemIdCounter = 0;
        let connectionIdCounter = 0;
        
        // Simulation state
        let isPlaying = false;
        let simulationSpeed = 1;
        let elapsedHours = 0;
        let animationFrameId = null;
        let lastTimestamp = 0;
        
        // Drag state
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        let dragOffset = { x: 0, y: 0 };
        let tempWire = null;
        let draggingHandle = null;
        
        // Tutorial state
        let tutorialStep = 0;
        let tutorialCompleted = false;
        
        const TUTORIAL_STEPS = [
            {
                id: 'connect-battery',
                title: 'ðŸ”‹ Connect the Battery',
                text: 'Drag from the controller\'s BATT+ handle (red, bottom) to the battery\'s + terminal (red, top). Then connect BATT- to the battery\'s - terminal.',
                successTitle: 'âœ¨ Nice work!',
                successText: 'Now connect the solar panel to the controller. Drag from the panel\'s + terminal to the controller\'s PV+ handle (orange, top).',
                check: (controller) => {
                    return controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                           controller.handles?.batteryNegative?.connectedTo?.length > 0;
                }
            },
            {
                id: 'connect-solar',
                title: 'â˜€ï¸ Connect the Solar Panel',
                text: 'Drag from the panel\'s + terminal to the controller\'s PV+ handle (orange, top), and - to PV- (blue).',
                successTitle: 'ðŸŽ‰ System Operational!',
                successText: 'Excellent! Try adding more panels by dragging from a panel terminal to empty space.',
                check: (controller) => {
                    return controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                           controller.handles?.pvNegative?.connectedTo?.length > 0;
                }
            }
        ];
        
        // Track if user connected solar before battery (out of order)
        let connectedSolarFirst = false;
        
        // Track series hint state
        let seriesHintShown = false;
        let seriesVoltageInterval = null;
        
        // Track if optimal array hint was shown
        let optimalArrayHintShown = false;
        
        // Track last connected array wattage to detect new parallel strings
        let lastConnectedArrayWmp = 0;
        
        // ============================================
        // D3 SETUP
        // ============================================
        
        const svg = d3.select("#canvas");
        let svgWidth, svgHeight;
        
        const zoomBehavior = d3.zoom()
            .scaleExtent([0.25, 4])
            .filter(event => {
                // Don't zoom on double-click
                if (event.type.includes('dblclick')) return false;
                // Don't pan when clicking on items or handles
                if (event.target.closest('.item-group') || event.target.closest('.handle')) return false;
                return true;
            })
            .on("zoom", (event) => {
                zoomGroup.attr("transform", event.transform);
            });
        
        svg.call(zoomBehavior);
        
        // Add SVG filters for wire glow effects
        const defs = svg.append("defs");
        
        // Yellow glow filter for 120V AC - creates a bright yellow glow
        const yellowGlow = defs.append("filter")
            .attr("id", "yellow-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        yellowGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        yellowGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1 0 0 0 0  0 1 0.5 0 0  0 0 1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const yellowMerge = yellowGlow.append("feMerge");
        yellowMerge.append("feMergeNode").attr("in", "coloredBlur");
        yellowMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Red glow filter for 240V AC - creates a darker red glow
        const redGlow = defs.append("filter")
            .attr("id", "red-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        redGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        redGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1.2 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const redMerge = redGlow.append("feMerge");
        redMerge.append("feMergeNode").attr("in", "coloredBlur");
        redMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Blue glow filter for parallel connections - creates a bright blue glow
        const blueGlow = defs.append("filter")
            .attr("id", "blue-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        blueGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        blueGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "0 0 0 0 0  0.3 0.5 1 0 0  0.5 0.8 1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const blueMerge = blueGlow.append("feMerge");
        blueMerge.append("feMergeNode").attr("in", "coloredBlur");
        blueMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        const zoomGroup = svg.append("g").attr("class", "zoom-group");
        const wiresGroup = zoomGroup.append("g").attr("class", "wires-layer");
        const itemsGroup = zoomGroup.append("g").attr("class", "items-layer");
        const tempGroup = zoomGroup.append("g").attr("class", "temp-layer");
        
        function updateSvgDimensions() {
            const container = document.getElementById('canvas-container');
            svgWidth = container.clientWidth;
            svgHeight = container.clientHeight;
        }
        
        // ============================================
        // COMPONENT CREATION
        // ============================================
        
        function createPanel(x, y, specs = PANEL_PRESETS[0]) {
            const id = `panel-${++itemIdCounter}`;
            return {
                id,
                type: 'panel',
                x, y,
                width: PANEL_WIDTH,
                height: PANEL_HEIGHT,
                specs: { ...specs },
                handles: {
                    // Positive on left side, negative on right side (standard convention)
                    positive: { id: `${id}-pos`, polarity: 'positive', x: 0, y: PANEL_HEIGHT / 2, side: 'left', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: PANEL_WIDTH, y: PANEL_HEIGHT / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        function createBattery(x, y, specs = BATTERY_PRESETS[0]) {
            const id = `battery-${++itemIdCounter}`;
            const kWh = (specs.voltage * specs.ah) / 1000;
            return {
                id,
                type: 'battery',
                x, y,
                width: BATTERY_WIDTH,
                height: BATTERY_HEIGHT,
                specs: { ...specs, kWh },
                handles: {
                    // Terminals on top (like real batteries)
                    positive: { id: `${id}-pos`, polarity: 'positive', x: BATTERY_WIDTH * 0.25, y: -5, side: 'top', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: BATTERY_WIDTH * 0.75, y: -5, side: 'top', connectedTo: [] }
                }
            };
        }
        
        const SMART_BATTERY_WIDTH = 100;
        const SMART_BATTERY_HEIGHT = 80;
        
        function createSmartBattery(x, y, kWh = 3.6, parentControllerId = null) {
            const id = `smartbattery-${++itemIdCounter}`;
            return {
                id,
                type: 'smartbattery',
                x, y,
                width: SMART_BATTERY_WIDTH,
                height: SMART_BATTERY_HEIGHT,
                parentControllerId,
                specs: { 
                    name: 'Smart Battery',
                    kWh,
                    voltage: 48,
                    cost: 2700
                },
                handles: {
                    // Smart battery ports on both sides for daisy-chaining
                    smartPort1: { id: `${id}-smart-1`, polarity: 'smart-battery', x: SMART_BATTERY_WIDTH + 5, y: SMART_BATTERY_HEIGHT * 0.5, side: 'right', connectedTo: [] },
                    smartPort2: { id: `${id}-smart-2`, polarity: 'smart-battery', x: -5, y: SMART_BATTERY_HEIGHT * 0.5, side: 'left', connectedTo: [] }
                }
            };
        }
        
        const ALL_IN_ONE_HEIGHT = 140; // Taller for all-in-one with internal battery
        
        function createController(x, y, specs = CONTROLLER_PRESETS[0]) {
            const id = `controller-${++itemIdCounter}`;
            const isHybrid = specs.type === 'hybrid_inverter' || specs.type === 'all_in_one';
            const isAllInOne = specs.type === 'all_in_one';
            const nodeHeight = isAllInOne ? ALL_IN_ONE_HEIGHT : CONTROLLER_HEIGHT;
            
            const handles = {
                // PV inputs on top - positive left, negative right (same as combiner outputs)
                pvPositive: { id: `${id}-pv-pos`, polarity: 'pv-positive', x: CONTROLLER_WIDTH * 0.20, y: -5, side: 'top', connectedTo: [] },
                pvNegative: { id: `${id}-pv-neg`, polarity: 'pv-negative', x: CONTROLLER_WIDTH * 0.45, y: -5, side: 'top', connectedTo: [] }
            };
            
            // All-in-one units have internal battery, so no external battery handles
            // Regular controllers and hybrid inverters need external battery connections
            if (!isAllInOne) {
                handles.batteryPositive = { id: `${id}-batt-pos`, polarity: 'positive', x: CONTROLLER_WIDTH * 0.55, y: nodeHeight + 5, side: 'bottom', connectedTo: [] };
                handles.batteryNegative = { id: `${id}-batt-neg`, polarity: 'negative', x: CONTROLLER_WIDTH * 0.80, y: nodeHeight + 5, side: 'bottom', connectedTo: [] };
            }
            
            // Add AC output for hybrid inverters and all-in-ones
            if (isHybrid) {
                handles.acOutput = { id: `${id}-ac-out`, polarity: 'ac', x: CONTROLLER_WIDTH + 5, y: nodeHeight * 0.5, side: 'right', connectedTo: [] };
            }
            
            // Add smart battery ports for all-in-one units with expansion capability
            if (isAllInOne && specs.smartBatteryPorts) {
                for (let i = 0; i < specs.smartBatteryPorts; i++) {
                    const portY = nodeHeight * 0.35 + (i * 35);
                    handles[`smartBattery${i + 1}`] = { 
                        id: `${id}-smart-batt-${i + 1}`, 
                        polarity: 'smart-battery', 
                        x: -5, 
                        y: portY, 
                        side: 'left', 
                        connectedTo: [],
                        portIndex: i + 1
                    };
                }
            }
            
            // Add parallel port for units that support hub connection (e.g., Delta Pro)
            if (specs.parallelCapable) {
                handles.parallelPort = { 
                    id: `${id}-parallel`, 
                    polarity: 'parallel', 
                    x: CONTROLLER_WIDTH + 5, 
                    y: nodeHeight * 0.25, 
                    side: 'right', 
                    connectedTo: [] 
                };
            }
            
            return {
                id,
                type: 'controller',
                subtype: specs.type,
                x, y,
                width: CONTROLLER_WIDTH,
                height: nodeHeight,
                specs: { ...specs },
                handles
            };
        }
        
        function createBreaker(x, y, specs = BREAKER_PRESETS[1]) {
            const id = `breaker-${++itemIdCounter}`;
            return {
                id,
                type: 'breaker',
                x, y,
                width: BREAKER_WIDTH,
                height: BREAKER_HEIGHT,
                isClosed: true, // Breaker state: true = closed (conducting), false = open (tripped/off)
                specs: { ...specs },
                handles: {
                    // Line side (input) on top
                    linePositive: { id: `${id}-line-pos`, polarity: 'positive', x: BREAKER_WIDTH * 0.3, y: -5, side: 'top', connectedTo: [] },
                    lineNegative: { id: `${id}-line-neg`, polarity: 'negative', x: BREAKER_WIDTH * 0.7, y: -5, side: 'top', connectedTo: [] },
                    // Load side (output) on bottom
                    loadPositive: { id: `${id}-load-pos`, polarity: 'positive', x: BREAKER_WIDTH * 0.3, y: BREAKER_HEIGHT + 5, side: 'bottom', connectedTo: [] },
                    loadNegative: { id: `${id}-load-neg`, polarity: 'negative', x: BREAKER_WIDTH * 0.7, y: BREAKER_HEIGHT + 5, side: 'bottom', connectedTo: [] }
                }
            };
        }
        
        function createCombiner(x, y, specs = COMBINER_PRESETS[1]) {
            const id = `combiner-${++itemIdCounter}`;
            const numInputs = specs.inputs || 4;
            const handles = {};
            
            // Create input handles on top (one pair per string)
            for (let i = 0; i < numInputs; i++) {
                const xRatio = (i + 0.5) / numInputs;
                handles[`input${i}Positive`] = { 
                    id: `${id}-in${i}-pos`, 
                    polarity: 'positive', 
                    x: COMBINER_WIDTH * xRatio - 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
                handles[`input${i}Negative`] = { 
                    id: `${id}-in${i}-neg`, 
                    polarity: 'negative', 
                    x: COMBINER_WIDTH * xRatio + 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
            }
            
            // Combined output on bottom - positive left, negative right
            handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: COMBINER_WIDTH * 0.30, y: COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: COMBINER_WIDTH * 0.70, y: COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            
            return {
                id,
                type: 'combiner',
                x, y,
                width: COMBINER_WIDTH,
                height: COMBINER_HEIGHT,
                specs: { ...specs },
                handles
            };
        }
        
        function createSolarCombinerBox(x, y, specs = SOLAR_COMBINER_PRESETS[1]) {
            const id = `solarcombiner-${++itemIdCounter}`;
            const numInputs = specs.inputs || 4;
            const handles = {};
            
            // Create input handles on top (one pair per string, each with its own breaker)
            for (let i = 0; i < numInputs; i++) {
                const xRatio = (i + 0.5) / numInputs;
                handles[`input${i}Positive`] = { 
                    id: `${id}-in${i}-pos`, 
                    polarity: 'pv-positive', 
                    x: SOLAR_COMBINER_WIDTH * xRatio - 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i,
                    breakerClosed: true // Each input has its own breaker
                };
                handles[`input${i}Negative`] = { 
                    id: `${id}-in${i}-neg`, 
                    polarity: 'pv-negative', 
                    x: SOLAR_COMBINER_WIDTH * xRatio + 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
            }
            
            // Combined output on bottom - positive left, negative right
            handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: SOLAR_COMBINER_WIDTH * 0.30, y: SOLAR_COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: SOLAR_COMBINER_WIDTH * 0.70, y: SOLAR_COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            
            return {
                id,
                type: 'solarcombiner',
                x, y,
                width: SOLAR_COMBINER_WIDTH,
                height: SOLAR_COMBINER_HEIGHT,
                specs: { ...specs },
                breakerStates: new Array(numInputs).fill(true), // All breakers closed by default
                handles
            };
        }
        
        // EcoFlow Double Voltage Hub - connects two Delta Pro units for 240V split-phase output
        const DOUBLE_VOLTAGE_HUB_WIDTH = 100;
        const DOUBLE_VOLTAGE_HUB_HEIGHT = 60;
        
        function createDoubleVoltageHub(x, y) {
            const id = `hub-${++itemIdCounter}`;
            return {
                id,
                type: 'doublevoltagehub',
                x, y,
                width: DOUBLE_VOLTAGE_HUB_WIDTH,
                height: DOUBLE_VOLTAGE_HUB_HEIGHT,
                specs: {
                    name: 'Double Voltage Hub',
                    maxInputControllers: 2,
                    outputVoltage: '120V/240V',
                    maxOutputW: 7200,
                    cost: 400
                },
                handles: {
                    // Two parallel inputs on left side
                    input1: { id: `${id}-in1`, polarity: 'parallel', x: -5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.33, side: 'left', connectedTo: [] },
                    input2: { id: `${id}-in2`, polarity: 'parallel', x: -5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.67, side: 'left', connectedTo: [] },
                    // Combined AC output on right
                    acOutput: { id: `${id}-ac-out`, polarity: 'ac', x: DOUBLE_VOLTAGE_HUB_WIDTH + 5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.5, side: 'right', connectedTo: [] }
                }
            };
        }
        
        // AC Circuit Components
        const AC_BREAKER_WIDTH = 50;
        const AC_BREAKER_HEIGHT = 40;
        const AC_OUTLET_WIDTH = 50;
        const AC_OUTLET_HEIGHT = 50;
        
        const AC_BREAKER_PRESETS = [
            { name: "AC 15A", rating: 15, voltage: 120, maxWatts: 1800, cost: 10 },
            { name: "AC 20A", rating: 20, voltage: 120, maxWatts: 2400, cost: 12 },
            { name: "AC 30A", rating: 30, voltage: 120, maxWatts: 3600, cost: 18 },
            { name: "AC 30A 240V", rating: 30, voltage: 240, maxWatts: 7200, cost: 25 },
            { name: "AC 50A 240V", rating: 50, voltage: 240, maxWatts: 12000, cost: 35 }
        ];
        
        function createACBreaker(x, y, specs = AC_BREAKER_PRESETS[0]) {
            const id = `acbreaker-${++itemIdCounter}`;
            return {
                id,
                type: 'acbreaker',
                x, y,
                width: AC_BREAKER_WIDTH,
                height: AC_BREAKER_HEIGHT,
                isClosed: true,
                specs: { ...specs },
                handles: {
                    // Line (input) on left
                    lineIn: { id: `${id}-line`, polarity: 'ac', x: -5, y: AC_BREAKER_HEIGHT / 2, side: 'left', connectedTo: [] },
                    // Load (output) on right
                    loadOut: { id: `${id}-load`, polarity: 'ac', x: AC_BREAKER_WIDTH + 5, y: AC_BREAKER_HEIGHT / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        function createACOutlet(x, y, voltage = 120) {
            const id = `outlet-${++itemIdCounter}`;
            const is240V = voltage === 240;
            return {
                id,
                type: 'acoutlet',
                x, y,
                width: AC_OUTLET_WIDTH,
                height: AC_OUTLET_HEIGHT,
                specs: {
                    name: is240V ? '240V Outlet' : '120V Outlet',
                    voltage: voltage,
                    maxAmps: is240V ? 30 : 15,
                    cost: is240V ? 25 : 5
                },
                handles: {
                    // Input on left (for daisy-chaining)
                    input: { id: `${id}-in`, polarity: 'ac', x: -5, y: AC_OUTLET_HEIGHT / 2, side: 'left', connectedTo: [], voltage: voltage },
                    // Output on right (for daisy-chaining to next outlet)
                    output: { id: `${id}-out`, polarity: 'ac', x: AC_OUTLET_WIDTH + 5, y: AC_OUTLET_HEIGHT / 2, side: 'right', connectedTo: [], voltage: voltage },
                    // Load port on bottom (for connecting appliances)
                    load: { id: `${id}-load`, polarity: 'load', x: AC_OUTLET_WIDTH / 2, y: AC_OUTLET_HEIGHT + 5, side: 'bottom', connectedTo: [], voltage: voltage }
                }
            };
        }
        
        // AC Load / Appliance component
        const AC_LOAD_WIDTH = 90;
        const AC_LOAD_HEIGHT = 95; // Increased from 75 to prevent button overlap with name label
        
        const APPLIANCE_PRESETS = [
            { 
                name: "Custom Load", voltage: 120, maxWatts: 100, avgWatts: 50, icon: "âš¡",
                behavior: { type: "constant" }
            },
            { 
                name: "LED Light", voltage: 120, maxWatts: 15, avgWatts: 10, icon: "ðŸ’¡",
                behavior: { type: "scheduled", schedule: { onTrigger: "sunset", offTrigger: "sunrise" } }
            },
            { 
                name: "CFL Light", voltage: 120, maxWatts: 23, avgWatts: 20, icon: "ðŸ’¡",
                behavior: { type: "scheduled", schedule: { onTrigger: "sunset", offTrigger: "sunrise" } }
            },
            { 
                name: "Laptop", voltage: 120, maxWatts: 65, avgWatts: 45, icon: "ðŸ’»",
                behavior: { type: "charging", batteryKwh: 0.06, chargeRateKw: 0.065, dailyDepletionKwh: 0.04 }
            },
            { 
                name: "Desktop PC", voltage: 120, maxWatts: 500, avgWatts: 200, icon: "ðŸ–¥ï¸",
                behavior: { type: "scheduled", schedule: { onTrigger: "08:00", offTrigger: "22:00" } }
            },
            { 
                name: "TV (LED 55\")", voltage: 120, maxWatts: 120, avgWatts: 80, icon: "ðŸ“º",
                behavior: { type: "scheduled", schedule: { onTrigger: "18:00", offTrigger: "23:00" } }
            },
            { 
                name: "Refrigerator", voltage: 120, maxWatts: 400, avgWatts: 150, icon: "ðŸ§Š",
                behavior: { type: "thermostat", setpoint: 37, deadband: 3, dutyPercent: 35 }
            },
            { 
                name: "Microwave", voltage: 120, maxWatts: 1200, avgWatts: 1200, icon: "ðŸ“¦",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Popcorn", inputs: "1 bag popcorn", outputs: "popped popcorn", energyWh: 66, durationMin: 4, batchesPerDay: 0.3 },
                        { name: "Burrito", inputs: "1 frozen burrito", outputs: "hot burrito", energyWh: 33, durationMin: 2, batchesPerDay: 0.5 },
                        { name: "Reheat Leftovers", inputs: "1 plate food", outputs: "hot meal", energyWh: 50, durationMin: 3, batchesPerDay: 1 }
                    ]
                }
            },
            { 
                name: "Coffee Maker", voltage: 120, maxWatts: 1000, avgWatts: 800, icon: "â˜•",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Single Cup", inputs: "water + grounds", outputs: "1 cup coffee", energyWh: 30, durationMin: 2, batchesPerDay: 3 },
                        { name: "Full Pot", inputs: "water + grounds", outputs: "12 cups coffee", energyWh: 100, durationMin: 8, batchesPerDay: 1 }
                    ]
                }
            },
            { 
                name: "Toaster", voltage: 120, maxWatts: 1400, avgWatts: 1200, icon: "ðŸž",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Toast (2 slices)", inputs: "2 slices bread", outputs: "toast", energyWh: 35, durationMin: 2, batchesPerDay: 2 },
                        { name: "Bagel", inputs: "1 bagel", outputs: "toasted bagel", energyWh: 40, durationMin: 2.5, batchesPerDay: 0.5 }
                    ]
                }
            },
            { 
                name: "Hair Dryer", voltage: 120, maxWatts: 1800, avgWatts: 1500, icon: "ðŸ’¨",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Dry Hair", inputs: "wet hair", outputs: "dry hair", energyWh: 250, durationMin: 10, batchesPerDay: 1 }
                    ]
                }
            },
            { 
                name: "Space Heater", voltage: 120, maxWatts: 1500, avgWatts: 1500, icon: "ðŸ”¥",
                behavior: { type: "thermostat", setpoint: 68, deadband: 2, dutyPercent: 50 }
            },
            { 
                name: "Window AC", voltage: 120, maxWatts: 1400, avgWatts: 1000, icon: "â„ï¸",
                behavior: { type: "thermostat", setpoint: 72, deadband: 2, dutyPercent: 40 }
            },
            { 
                name: "Washing Machine", voltage: 120, maxWatts: 500, avgWatts: 350, icon: "ðŸ§º",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Normal Cycle", inputs: "dirty clothes", outputs: "clean clothes", energyWh: 500, durationMin: 45, batchesPerDay: 0.5 },
                        { name: "Quick Wash", inputs: "lightly soiled", outputs: "clean clothes", energyWh: 250, durationMin: 20, batchesPerDay: 0.3 }
                    ]
                }
            },
            { 
                name: "Electric Dryer", voltage: 240, maxWatts: 5000, avgWatts: 3000, icon: "ðŸŒ€",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Normal Dry", inputs: "wet clothes", outputs: "dry clothes", energyWh: 2500, durationMin: 50, batchesPerDay: 0.5 },
                        { name: "Quick Dry", inputs: "damp clothes", outputs: "dry clothes", energyWh: 1500, durationMin: 30, batchesPerDay: 0.3 }
                    ]
                }
            },
            { 
                name: "Electric Oven", voltage: 240, maxWatts: 5000, avgWatts: 2500, icon: "ðŸ³",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Bake (350Â°F 1hr)", inputs: "raw food", outputs: "baked food", energyWh: 2000, durationMin: 60, batchesPerDay: 0.5 },
                        { name: "Broil (15min)", inputs: "raw food", outputs: "broiled food", energyWh: 1000, durationMin: 15, batchesPerDay: 0.3 },
                        { name: "Roast (2hr)", inputs: "raw meat", outputs: "roasted meat", energyWh: 4000, durationMin: 120, batchesPerDay: 0.2 }
                    ]
                }
            },
            { 
                name: "EV Charger (L2)", voltage: 240, maxWatts: 7200, avgWatts: 6000, icon: "ðŸš—",
                behavior: { type: "charging", batteryKwh: 60, chargeRateKw: 7.2, dailyDepletionKwh: 20 }
            },
            { 
                name: "Well Pump", voltage: 240, maxWatts: 2000, avgWatts: 1000, icon: "ðŸ’§",
                behavior: { type: "thermostat", setpoint: 40, deadband: 10, dutyPercent: 25 }
            },
            { 
                name: "Hot Tub", voltage: 240, maxWatts: 6000, avgWatts: 4000, icon: "ðŸ›",
                behavior: { type: "thermostat", setpoint: 102, deadband: 2, dutyPercent: 30 }
            },
            { 
                name: "Central AC", voltage: 240, maxWatts: 5000, avgWatts: 3500, icon: "ðŸ ",
                behavior: { type: "thermostat", setpoint: 72, deadband: 2, dutyPercent: 40 }
            },
            { 
                name: "Phone Charger", voltage: 120, maxWatts: 20, avgWatts: 15, icon: "ðŸ“±",
                behavior: { type: "charging", batteryKwh: 0.015, chargeRateKw: 0.02, dailyDepletionKwh: 0.01 }
            },
            { 
                name: "Tablet Charger", voltage: 120, maxWatts: 30, avgWatts: 20, icon: "ðŸ“²",
                behavior: { type: "charging", batteryKwh: 0.04, chargeRateKw: 0.03, dailyDepletionKwh: 0.02 }
            },
            { 
                name: "Plastic Shredder", voltage: 120, maxWatts: 600, avgWatts: 600, icon: "â™»ï¸",
                behavior: { 
                    type: "batch", 
                    recipes: [
                        { name: "Shred 1kg HDPE", inputs: "1kg plastic bottles", outputs: "shredded HDPE", energyWh: 100, durationMin: 10, batchesPerDay: 5 },
                        { name: "Shred 1kg PET", inputs: "1kg PET bottles", outputs: "shredded PET", energyWh: 80, durationMin: 8, batchesPerDay: 3 }
                    ]
                }
            }
        ];
        
        function createACLoad(x, y, preset = APPLIANCE_PRESETS[0]) {
            const id = `load-${++itemIdCounter}`;
            // Deep copy behavior to avoid shared references
            const behavior = preset.behavior ? JSON.parse(JSON.stringify(preset.behavior)) : { type: 'constant' };
            return {
                id,
                type: 'acload',
                x, y,
                width: AC_LOAD_WIDTH,
                height: AC_LOAD_HEIGHT,
                specs: { 
                    name: preset.name,
                    voltage: preset.voltage,
                    maxWatts: preset.maxWatts,
                    avgWatts: preset.avgWatts,
                    icon: preset.icon,
                    behavior: behavior,
                    cost: 0 
                },
                handles: {
                    // Cord input on top (connects to outlet load port)
                    cord: { id: `${id}-cord`, polarity: 'load', x: AC_LOAD_WIDTH / 2, y: -5, side: 'top', connectedTo: [] }
                }
            };
        }
        
        // Auto-size breaker based on source watts
        function getAutoSizedACBreaker(sourceWatts, voltage = 120) {
            // Find smallest breaker that can handle the load with 80% safety margin
            const requiredAmps = (sourceWatts / voltage) * 1.25;
            const preset = AC_BREAKER_PRESETS.find(b => b.voltage === voltage && b.rating >= requiredAmps) 
                || AC_BREAKER_PRESETS.find(b => b.voltage === voltage);
            return preset || AC_BREAKER_PRESETS[0];
        }
        
        // CEP Spider Box - Portable power distribution for job sites
        // Takes 240V 50A input, breaks out to multiple 120V/240V circuits
        const SPIDERBOX_WIDTH = 220;
        const SPIDERBOX_HEIGHT = 150;
        
        function createSpiderBox(x, y) {
            const id = `spiderbox-${++itemIdCounter}`;
            const handles = {
                // 240V 50A input on left
                input: { id: `${id}-in`, polarity: 'ac', x: -5, y: SPIDERBOX_HEIGHT / 2, side: 'left', connectedTo: [], voltage: 240 }
            };
            
            // 6 output circuits on right side
            // 4x 120V 20A circuits (from split-phase)
            // 2x 240V 30A circuits
            const circuits = [
                { name: '120V-1', voltage: 120, amps: 20 },
                { name: '120V-2', voltage: 120, amps: 20 },
                { name: '120V-3', voltage: 120, amps: 20 },
                { name: '120V-4', voltage: 120, amps: 20 },
                { name: '240V-1', voltage: 240, amps: 30 },
                { name: '240V-2', voltage: 240, amps: 30 }
            ];
            
            circuits.forEach((circuit, i) => {
                const yPos = 50 + (i * 18); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: SPIDERBOX_WIDTH + 5,
                    y: yPos,
                    side: 'right',
                    connectedTo: [],
                    voltage: circuit.voltage,
                    maxAmps: circuit.amps,
                    circuitName: circuit.name,
                    isClosed: true
                };
            });
            
            return {
                id,
                type: 'spiderbox',
                x, y,
                width: SPIDERBOX_WIDTH,
                height: SPIDERBOX_HEIGHT,
                specs: {
                    name: 'CEP Spider Box',
                    inputVoltage: 240,
                    inputAmps: 50,
                    maxInputWatts: 12000,
                    circuits: circuits,
                    cost: 450
                },
                handles
            };
        }
        
        // Household Main Breaker Panel - 100A service
        // Takes 240V input, provides multiple circuits
        const BREAKER_PANEL_WIDTH = 200;
        const BREAKER_PANEL_HEIGHT = 240;
        
        function createBreakerPanel(x, y) {
            const id = `panel-${++itemIdCounter}`;
            const handles = {
                // Main 240V input on top
                mainInput: { id: `${id}-main-in`, polarity: 'ac', x: BREAKER_PANEL_WIDTH / 2, y: -5, side: 'top', connectedTo: [], voltage: 240 }
            };
            
            // 8 circuit outputs - mix of 120V and 240V
            const circuits = [
                { name: 'Circuit 1', voltage: 120, amps: 15 },
                { name: 'Circuit 2', voltage: 120, amps: 15 },
                { name: 'Circuit 3', voltage: 120, amps: 20 },
                { name: 'Circuit 4', voltage: 120, amps: 20 },
                { name: 'Circuit 5', voltage: 120, amps: 20 },
                { name: 'Circuit 6', voltage: 120, amps: 20 },
                { name: '240V-A', voltage: 240, amps: 30 },
                { name: '240V-B', voltage: 240, amps: 50 }
            ];
            
            // Left side circuits (1-4) - match visual breaker positions
            for (let i = 0; i < 4; i++) {
                const yPos = 75 + (i * 42); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: -5,
                    y: yPos,
                    side: 'left',
                    connectedTo: [],
                    voltage: circuits[i].voltage,
                    maxAmps: circuits[i].amps,
                    circuitName: circuits[i].name
                };
            }
            
            // Right side circuits (5-8) - match visual breaker positions
            for (let i = 4; i < 8; i++) {
                const yPos = 75 + ((i - 4) * 42); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: BREAKER_PANEL_WIDTH + 5,
                    y: yPos,
                    side: 'right',
                    connectedTo: [],
                    voltage: circuits[i].voltage,
                    maxAmps: circuits[i].amps,
                    circuitName: circuits[i].name
                };
            }
            
            return {
                id,
                type: 'breakerpanel',
                x, y,
                width: BREAKER_PANEL_WIDTH,
                height: BREAKER_PANEL_HEIGHT,
                specs: {
                    name: '100A Breaker Panel',
                    inputVoltage: 240,
                    inputAmps: 100,
                    maxInputWatts: 24000,
                    circuits: circuits,
                    cost: 250
                },
                handles,
                mainBreakerOn: true, // Main breaker state
                breakerStates: new Array(8).fill(true) // Individual breakers on by default
            };
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        function render() {
            renderItems();
            renderWires();
            updateScores();
        }
        
        function renderItems() {
            const itemGroups = itemsGroup.selectAll(".item-group")
                .data(allItems, d => d.id);
            
            // Remove old items
            itemGroups.exit().remove();
            
            // Add new items
            const newItems = itemGroups.enter()
                .append("g")
                .attr("class", d => `item-group ${d.type}`)
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded)
                )
                .on("click", (event, d) => {
                    event.stopPropagation();
                    // In live mode, toggle loads when clicked
                    if (currentMode === 'live' && LiveView.state.active && d.type === 'acload') {
                        toggleLoad(d);
                    }
                    // Always select the item to open inspector
                    selectItem(d);
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    // In live mode, toggle loads on double-click too
                    if (currentMode === 'live' && LiveView.state.active && d.type === 'acload') {
                        toggleLoad(d);
                    }
                    selectItem(d); // Also open inspector on double-click
                });
            
            // Render based on type
            newItems.each(function(d) {
                const g = d3.select(this);
                
                if (d.type === 'panel') {
                    renderPanel(g, d);
                } else if (d.type === 'battery') {
                    renderBattery(g, d);
                } else if (d.type === 'controller') {
                    renderController(g, d);
                } else if (d.type === 'breaker') {
                    renderBreaker(g, d);
                } else if (d.type === 'combiner') {
                    renderCombiner(g, d);
                } else if (d.type === 'solarcombiner') {
                    renderSolarCombiner(g, d);
                } else if (d.type === 'smartbattery') {
                    renderSmartBattery(g, d);
                } else if (d.type === 'doublevoltagehub') {
                    renderDoubleVoltageHub(g, d);
                } else if (d.type === 'acbreaker') {
                    renderACBreaker(g, d);
                } else if (d.type === 'acoutlet') {
                    renderACOutlet(g, d);
                } else if (d.type === 'spiderbox') {
                    renderSpiderBox(g, d);
                } else if (d.type === 'breakerpanel') {
                    renderBreakerPanel(g, d);
                } else if (d.type === 'acload') {
                    renderACLoad(g, d);
                }
            });
            
            // Update existing items
            itemGroups.attr("transform", d => `translate(${d.x}, ${d.y})`)
                .classed("selected", d => selectedItem && selectedItem.id === d.id);
            
            // Update item content
            itemGroups.each(function(d) {
                const g = d3.select(this);
                updateItemContent(g, d);
            });
        }
        
        function renderPanel(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4);
            
            // Panel cell lines (vertical grid)
            for (let i = 1; i < 6; i++) {
                g.append("line")
                    .attr("class", "panel-cells")
                    .attr("x1", (d.width / 6) * i)
                    .attr("y1", 4)
                    .attr("x2", (d.width / 6) * i)
                    .attr("y2", d.height - 4);
            }
            // Horizontal line
            g.append("line")
                .attr("class", "panel-cells")
                .attr("x1", 4)
                .attr("y1", d.height / 2)
                .attr("x2", d.width - 4)
                .attr("y2", d.height / 2);
            
            // Label - show real-time output in live view
            let panelOutputWatts = d.specs.wmp;
            if (liveViewActive) {
                // Calculate actual output (simplified - assume full output for now)
                panelOutputWatts = d.specs.wmp;
            }
            
            g.append("text")
                .attr("class", "panel-label wmp-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 - 8)
                .attr("dominant-baseline", "middle")
                .text(panelOutputWatts + "W");
            
            g.append("text")
                .attr("class", "panel-specs voc-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 12)
                .attr("dominant-baseline", "middle")
                .text(d.specs.voc.toFixed(1) + "V");
            
            // Polarity labels on sides
            g.append("text")
                .attr("class", "port-label")
                .attr("x", -15)
                .attr("y", d.height / 2)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .text("+");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width + 15)
                .attr("y", d.height / 2)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .text("-");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderBattery(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Terminal indicators (positioned to match handle locations)
            g.append("rect")
                .attr("class", "battery-terminal-pos")
                .attr("x", d.width * 0.25 - 10)
                .attr("y", -12)
                .attr("width", 20)
                .attr("height", 12)
                .attr("rx", 2);
            
            g.append("rect")
                .attr("class", "battery-terminal-neg")
                .attr("x", d.width * 0.75 - 10)
                .attr("y", -12)
                .attr("width", 20)
                .attr("height", 12)
                .attr("rx", 2);
            
            // Labels
            g.append("text")
                .attr("class", "battery-label voltage-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.35)
                .attr("dominant-baseline", "middle")
                .text(d.specs.voltage.toFixed(1) + "V");
            
            g.append("text")
                .attr("class", "battery-label ah-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.55)
                .attr("dominant-baseline", "middle")
                .text(d.specs.ah + "Ah");
            
            // Show real-time charge in live view
            if (liveViewActive) {
                // Find controller connected to this battery to get system battery specs
                const controllers = allItems.filter(i => i.type === 'controller');
                let batteryKwh = d.specs.kWh || 0;
                let batteryPercent = 50; // Simplified
                
                // Try to find connected controller
                controllers.forEach(controller => {
                    if (controller.handles?.batteryPositive) {
                        controller.handles.batteryPositive.connectedTo.forEach(conn => {
                            const batt = allItems.find(i => i.id === conn.itemId);
                            if (batt && batt.id === d.id) {
                                const batterySpecs = calculateConnectedBatterySpecs(controller);
                                batteryKwh = batterySpecs.kWh || batteryKwh;
                                batteryPercent = 50; // Would track actual charge
                            }
                        });
                    }
                });
                
                g.append("text")
                    .attr("class", "battery-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height * 0.75)
                    .attr("dominant-baseline", "middle")
                    .attr("fill", "#5cb85c")
                    .text(`${batteryKwh.toFixed(1)}kWh (${batteryPercent}%)`);
            } else {
                g.append("text")
                    .attr("class", "battery-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height * 0.75)
                    .attr("dominant-baseline", "middle")
                    .text(d.specs.kWh.toFixed(2) + " kWh");
            }
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderController(g, d) {
            const isHybrid = d.specs.type === 'hybrid_inverter' || d.specs.type === 'all_in_one';
            
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 8)
                .attr("ry", 8)
                .attr("fill", isHybrid ? "rgba(92, 107, 192, 0.3)" : "rgba(128, 128, 128, 0.3)");
            
            // Labels - different label for hybrid inverters
            // For all-in-one units, use the actual model name instead of "ALL-IN-ONE"
            let typeLabel;
            if (isHybrid) {
                if (d.specs.type === 'all_in_one') {
                    // Use the controller's name from specs (e.g., "EcoFlow DELTA Pro")
                    typeLabel = d.specs.name || 'EcoFlow';
                } else {
                    typeLabel = 'HYBRID INV';
                }
            } else {
                typeLabel = 'CONTROLLER';
            }
            g.append("text")
                .attr("class", "controller-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 - 15)
                .attr("dominant-baseline", "middle")
                .text(typeLabel);
            
            // Show real-time power in live view
            if (liveViewActive) {
                const arraySpecs = calculateConnectedArraySpecs(d);
                const dcInputWatts = arraySpecs.wmp || 0;
                const acOutputWatts = Math.min(dcInputWatts, d.specs.maxACOutputW || 0);
                
                g.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2 + 5)
                    .attr("dominant-baseline", "middle")
                    .attr("fill", "#f0ad4e")
                    .text(`DC: ${dcInputWatts}W`);
                
                g.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2 + 22)
                    .attr("dominant-baseline", "middle")
                    .attr("fill", "#f0ad4e")
                    .text(`AC: ${acOutputWatts}W`);
            } else {
                g.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2 + 5)
                    .attr("dominant-baseline", "middle")
                    .text(d.specs.maxWmp + "W max");
                
                g.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2 + 22)
                    .attr("dominant-baseline", "middle")
                    .text(d.specs.maxVoc + "V / " + d.specs.maxIsc + "A");
            }
            
            // PV label inside controller (near top handles)
            g.append("text")
                .attr("class", "port-label-internal")
                .attr("x", d.width * 0.325)
                .attr("y", 12)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .attr("font-size", "10px")
                .text("PV");
            
            const isAllInOne = d.specs.type === 'all_in_one';
            
            // For all-in-one units, show internal battery instead of external BATT label
            if (isAllInOne && d.specs.internalBatteryKWh) {
                // Internal battery box (increased height for better visibility)
                const battBoxWidth = d.width * 0.7;
                const battBoxHeight = 36;  // Increased from 28 to 36
                const battBoxX = (d.width - battBoxWidth) / 2;
                const battBoxY = d.height - battBoxHeight - 8;
                
                g.append("rect")
                    .attr("class", "internal-battery")
                    .attr("x", battBoxX)
                    .attr("y", battBoxY)
                    .attr("width", battBoxWidth)
                    .attr("height", battBoxHeight)
                    .attr("rx", 4)
                    .attr("fill", "rgba(92, 184, 92, 0.3)")
                    .attr("stroke", "#5cb85c")
                    .attr("stroke-width", 1);
                
                // Battery icon (small terminals)
                g.append("rect")
                    .attr("x", battBoxX + battBoxWidth * 0.25 - 4)
                    .attr("y", battBoxY - 3)
                    .attr("width", 8)
                    .attr("height", 4)
                    .attr("fill", "#5cb85c");
                g.append("rect")
                    .attr("x", battBoxX + battBoxWidth * 0.75 - 4)
                    .attr("y", battBoxY - 3)
                    .attr("width", 8)
                    .attr("height", 4)
                    .attr("fill", "#333");
                
                // Battery capacity text
                g.append("text")
                    .attr("class", "internal-battery-label")
                    .attr("x", d.width / 2)
                    .attr("y", battBoxY + battBoxHeight / 2)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text(`ðŸ”‹ ${d.specs.internalBatteryKWh} kWh`);
            } else {
                // BATT label inside controller (near bottom handles) - for non all-in-one
                g.append("text")
                    .attr("class", "port-label-internal")
                    .attr("x", d.width * 0.675)
                    .attr("y", d.height - 12)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-weight", "bold")
                    .attr("font-size", "10px")
                    .text("BATT");
            }
            
            // AC Output label removed for cleaner appearance
            // Smart battery port labels removed (EXT1, EXT2) for cleaner appearance
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderSmartBattery(g, d) {
            // Main rect with green tint
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#2a4a2a")
                .attr("stroke", "#5cb85c")
                .attr("stroke-width", 1.5);
            
            // Battery icon at top
            const iconY = 8;
            g.append("rect")
                .attr("x", d.width * 0.3 - 4)
                .attr("y", iconY)
                .attr("width", 8)
                .attr("height", 4)
                .attr("fill", "#5cb85c");
            g.append("rect")
                .attr("x", d.width * 0.7 - 4)
                .attr("y", iconY)
                .attr("width", 8)
                .attr("height", 4)
                .attr("fill", "#333");
            
            // Title
            g.append("text")
                .attr("class", "item-label")
                .attr("x", d.width / 2)
                .attr("y", 28)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#5cb85c")
                .attr("font-weight", "bold")
                .text("SMART BATTERY");
            
            // Capacity
            g.append("text")
                .attr("class", "item-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text(`ðŸ”‹ ${d.specs.kWh} kWh`);
            
            // Voltage
            g.append("text")
                .attr("class", "item-specs")
                .attr("x", d.width / 2)
                .attr("y", d.height - 12)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#888")
                .text(`${d.specs.voltage}V`);
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderDoubleVoltageHub(g, d) {
            // Main rect with blue/teal EcoFlow style
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#1a3a4a")
                .attr("stroke", "#00a8e8")
                .attr("stroke-width", 2);
            
            // Hub icon/label
            g.append("text")
                .attr("class", "item-label")
                .attr("x", d.width / 2)
                .attr("y", 18)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#00a8e8")
                .attr("font-weight", "bold")
                .text("ECOFLOW");
            
            g.append("text")
                .attr("class", "item-label")
                .attr("x", d.width / 2)
                .attr("y", 32)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text("VOLTAGE HUB");
            
            // Output specs
            g.append("text")
                .attr("class", "item-specs")
                .attr("x", d.width / 2)
                .attr("y", d.height - 10)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#888")
                .text(`${d.specs.outputVoltage} â€¢ ${d.specs.maxOutputW}W`);
            
            // Input labels
            g.append("text")
                .attr("x", 15)
                .attr("y", d.height * 0.33 + 3)
                .attr("font-size", "7px")
                .attr("fill", "#666")
                .text("IN1");
            
            g.append("text")
                .attr("x", 15)
                .attr("y", d.height * 0.67 + 3)
                .attr("font-size", "7px")
                .attr("fill", "#666")
                .text("IN2");
            
            // Output label
            g.append("text")
                .attr("x", d.width - 20)
                .attr("y", d.height * 0.5 + 3)
                .attr("font-size", "7px")
                .attr("fill", "#666")
                .text("AC");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderACBreaker(g, d) {
            // Determine breaker state
            const isTripped = LiveView.state.active && LiveView.state.breakerStates[d.id]?.wasTripped;
            const isClosed = d.isClosed;
            
            // Main rect with color based on state
            let fillColor = "#3a3020";
            let strokeColor = "#f0ad4e";
            if (isTripped) {
                fillColor = "#3a2020";
                strokeColor = "#d9534f";
            } else if (!isClosed) {
                fillColor = "#2a2a2a";
                strokeColor = "#888";
            }
            
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", 2);
            
            // Breaker switch clickable (only in live view mode)
            const switchGroup = g.append("g")
                .attr("class", "breaker-switch-group")
                .style("cursor", liveViewActive ? "pointer" : "default")
                .on("click", (event) => {
                    if (!LiveView.state.active) return;
                    event.stopPropagation();
                    d.isClosed = !d.isClosed;
                    // Update live view breaker state - always create/update to ensure wasTripped is cleared
                    LiveView.state.breakerStates[d.id] = {
                        isClosed: d.isClosed,
                        wasTripped: false // Always clear tripped flag when manually toggling
                    };
                    render();
                    
                    // Refresh inspector if a load is currently selected
                    if (selectedItem && selectedItem.type === 'acload') {
                        openInspector(selectedItem);
                    }
                });
            
            // Toggle indicator
            let toggleColor = "#f0ad4e";
            if (isTripped) {
                toggleColor = "#d9534f";
            } else if (!isClosed) {
                toggleColor = "#888";
            }
            
            switchGroup.append("rect")
                .attr("x", d.width * 0.2)
                .attr("y", d.height * 0.25)
                .attr("width", d.width * 0.6)
                .attr("height", d.height * 0.2)
                .attr("rx", 2)
                .attr("fill", toggleColor);
            
            // Rating label
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.7)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text(`${d.specs.rating}A`);
            
            // Voltage label or current amps (in live view)
            if (liveViewActive) {
                const circuitInfo = LiveView.PowerFlow.calculateACCircuit(d);
                const ampsText = circuitInfo.totalAmps > 0 ? 
                    `${circuitInfo.totalAmps.toFixed(1)}A / ${d.specs.rating}A` : 
                    `${d.specs.rating}A`;
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", circuitInfo.totalAmps > d.specs.rating ? "#d9534f" : 
                           circuitInfo.totalAmps > d.specs.rating * 0.8 ? "#f0ad4e" : "#888")
                    .text(ampsText);
                
                // Show TRIPPED text if tripped
                if (isTripped) {
                    g.append("text")
                        .attr("x", d.width / 2)
                        .attr("y", d.height * 0.5)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", "#d9534f")
                        .attr("font-weight", "bold")
                        .text("TRIPPED");
                }
            } else {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", "#888")
                    .text(`${d.specs.voltage}V`);
            }
            
            renderHandles(g, d);
        }
        
        // Helper function to check if a breaker/panel is connected to a power source
        function hasPowerSourceConnection(item) {
            if (!item) return false;
            const visited = new Set();
            
            const traceToPowerSource = (currentItem, handleId = null) => {
                if (visited.has(currentItem.id)) return false;
                visited.add(currentItem.id);
                
                // Check if this is a power source
                if (currentItem.type === 'doublevoltagehub') {
                    // Check if hub has both inputs connected and AC output exists
                    const input1Connected = currentItem.handles?.input1?.connectedTo?.length > 0;
                    const input2Connected = currentItem.handles?.input2?.connectedTo?.length > 0;
                    if (input1Connected && input2Connected && currentItem.handles?.acOutput) {
                        // If we're checking from the AC output side, this is a valid power source
                        if (handleId && currentItem.handles.acOutput.id === handleId) {
                            // Verify at least one input has power flow
                            let hasLiveInput = false;
                            for (const inputConnInfo of currentItem.handles.input1.connectedTo) {
                                const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                if (inputConn) {
                                    const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                    if (powerFlow && powerFlow.isLive) {
                                        hasLiveInput = true;
                                        break;
                                    }
                                }
                            }
                            if (!hasLiveInput) {
                                for (const inputConnInfo of currentItem.handles.input2.connectedTo) {
                                    const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                    if (inputConn) {
                                        const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                        if (powerFlow && powerFlow.isLive) {
                                            hasLiveInput = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            // If both inputs are connected, consider it a valid power source
                            // (the power flow calculation will set isLive based on actual power)
                            return hasLiveInput || (input1Connected && input2Connected);
                        }
                        // If checking from input side, verify inputs have power
                        let hasLiveInput = false;
                        for (const inputConnInfo of currentItem.handles.input1.connectedTo) {
                            const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                            if (inputConn) {
                                const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                if (powerFlow && powerFlow.isLive) {
                                    hasLiveInput = true;
                                    break;
                                }
                            }
                        }
                        if (!hasLiveInput) {
                            for (const inputConnInfo of currentItem.handles.input2.connectedTo) {
                                const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                if (inputConn) {
                                    const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                    if (powerFlow && powerFlow.isLive) {
                                        hasLiveInput = true;
                                        break;
                                    }
                                }
                            }
                        }
                        return hasLiveInput;
                    }
                }
                
                if (currentItem.type === 'controller' && handleId) {
                    // Check if controller AC output has power
                    const handle = Object.values(currentItem.handles).find(h => h.id === handleId);
                    if (handle && handle.polarity === 'ac') {
                        const arraySpecs = calculateConnectedArraySpecs(currentItem);
                        const dcInputWatts = arraySpecs.wmp || 0;
                        const hasPower = dcInputWatts > 0 || currentItem.specs.internalBatteryKWh > 0;
                        return hasPower;
                    }
                }
                
                // Trace back through connections
                const itemConnections = connections.filter(c => 
                    (c.sourceItemId === currentItem.id && (!handleId || c.sourceHandleId === handleId)) ||
                    (c.targetItemId === currentItem.id && (!handleId || c.targetHandleId === handleId))
                );
                
                for (const conn of itemConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                        i.id !== currentItem.id
                    );
                    if (!otherItem) continue;
                    
                    const otherHandleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                    if (traceToPowerSource(otherItem, otherHandleId)) {
                        return true;
                    }
                }
                
                return false;
            };
            
            // For breaker panels, check the input connection
            if (item.type === 'breakerpanel') {
                // Find the input connection (usually from double voltage hub or controller)
                const inputConnections = connections.filter(c => 
                    c.targetItemId === item.id || c.sourceItemId === item.id
                );
                for (const conn of inputConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                        i.id !== item.id
                    );
                    if (!otherItem) continue;
                    
                    // First, check if this connection has power flow set (most reliable)
                    const powerFlow = LiveView.state.powerFlow[conn.id];
                    if (powerFlow && powerFlow.isLive) {
                        return true;
                    }
                    
                    // For double voltage hub, check if hub has both inputs connected
                    if (otherItem.type === 'doublevoltagehub') {
                        const input1Connected = otherItem.handles?.input1?.connectedTo?.length > 0;
                        const input2Connected = otherItem.handles?.input2?.connectedTo?.length > 0;
                        if (input1Connected && input2Connected && otherItem.handles?.acOutput) {
                            // Check if the connection is from the hub's AC output
                            const hubAcOutputHandle = otherItem.handles.acOutput;
                            const isFromAcOutput = (conn.sourceItemId === otherItem.id && conn.sourceHandleId === hubAcOutputHandle.id) ||
                                                   (conn.targetItemId === otherItem.id && conn.targetHandleId === hubAcOutputHandle.id);
                            if (isFromAcOutput) {
                                // If hub has both inputs connected, it's a valid power source
                                // (power flow calculation will set isLive based on actual power)
                                return true;
                            }
                        }
                    }
                    
                    // For controllers, check if AC output has power
                    if (otherItem.type === 'controller') {
                        const handleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                        if (traceToPowerSource(otherItem, handleId)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // For AC breakers, check the line side connection
            if (item.type === 'acbreaker' || item.type === 'breaker') {
                const lineHandle = item.handles?.linePositive || item.handles?.lineIn;
                if (lineHandle && lineHandle.connectedTo) {
                    for (const connInfo of lineHandle.connectedTo) {
                        const conn = connections.find(c => c.id === connInfo.connectionId);
                        if (conn) {
                            const otherItem = allItems.find(i => 
                                (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                                i.id !== item.id
                            );
                            if (otherItem) {
                                const handleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                                if (traceToPowerSource(otherItem, handleId)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            return traceToPowerSource(item);
        }
        
        // Helper function to check if an outlet's circuit is live
        function checkOutletCircuitStatus(outlet) {
            if (!outlet || !allItems.find(i => i.id === outlet.id)) {
                return { isLive: false };
            }
            
            // Trace back through daisy-chained outlets to find the breaker
            const visitedOutlets = new Set();
            const traceToBreaker = (currentOutlet) => {
                if (visitedOutlets.has(currentOutlet.id)) return null;
                visitedOutlets.add(currentOutlet.id);
                
                // Check all connections from this outlet
                const outletConnections = connections.filter(c => 
                    c.sourceItemId === currentOutlet.id || c.targetItemId === currentOutlet.id
                );
                
                for (const outletConn of outletConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId) &&
                        i.id !== currentOutlet.id
                    );
                    if (!otherItem) continue;
                    
                    // Check if it's a regular AC breaker
                    if (otherItem.type === 'acbreaker') {
                        const breakerHandle = otherItem.handles?.loadOut;
                        const outletHandle = currentOutlet.handles?.input;
                        if (breakerHandle && outletHandle &&
                            (outletConn.sourceHandleId === breakerHandle.id || outletConn.targetHandleId === breakerHandle.id) &&
                            (outletConn.sourceHandleId === outletHandle.id || outletConn.targetHandleId === outletHandle.id)) {
                            if (!LiveView.BreakerManager.isBreakerClosed(otherItem)) {
                                return { isLive: false };
                            }
                            // Verify breaker is connected to a power source
                            if (!hasPowerSourceConnection(otherItem)) {
                                return { isLive: false };
                            }
                            return { isLive: true };
                        }
                    }
                    
                    // Check if it's a breaker panel
                    if (otherItem.type === 'breakerpanel') {
                        if (otherItem.mainBreakerOn === false) {
                            return { isLive: false };
                        }
                        
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < 8) {
                                if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false };
                                }
                                // Verify panel is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // Check if it's a spider box
                    if (otherItem.type === 'spiderbox') {
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < otherItem.specs.circuits.length) {
                                if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false };
                                }
                                // Verify spider box is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // If it's another outlet, trace through daisy-chain
                    if (otherItem.type === 'acoutlet') {
                        const currentOutletInput = currentOutlet.handles?.input;
                        const previousOutletOutput = otherItem.handles?.output;
                        if (currentOutletInput && previousOutletOutput &&
                            (outletConn.sourceHandleId === previousOutletOutput.id || outletConn.targetHandleId === previousOutletOutput.id) &&
                            (outletConn.sourceHandleId === currentOutletInput.id || outletConn.targetHandleId === currentOutletInput.id)) {
                            const result = traceToBreaker(otherItem);
                            if (result) return result;
                        }
                    }
                }
                return null;
            };
            
            const result = traceToBreaker(outlet);
            return result || { isLive: false };
        }
        
        function renderACOutlet(g, d) {
            const is240V = d.specs.voltage === 240;
            
            // Check if outlet is live (in live view mode)
            let isLive = false;
            if (liveViewActive && LiveView.state.active) {
                const circuitStatus = checkOutletCircuitStatus(d);
                isLive = circuitStatus.isLive;
            }
            
            // Main rect - show visual feedback when live
            const fillColor = isLive ? "#3a3a2a" : "#2a2a2a";
            const strokeColor = isLive ? (is240V ? "#ff6666" : "#ffd700") : (is240V ? "#d9534f" : "#f0ad4e");
            const strokeWidth = isLive ? 3 : 2;
            
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);
            
            // Add glow effect only when live (no default glow)
            // Glow is added/removed in updateItemContent based on live status
            
            // Outlet face plate
            g.append("rect")
                .attr("x", d.width * 0.15)
                .attr("y", d.height * 0.15)
                .attr("width", d.width * 0.7)
                .attr("height", d.height * 0.5)
                .attr("rx", 3)
                .attr("fill", "#f5f5dc");
            
            if (is240V) {
                // 240V outlet - horizontal slots
                g.append("rect")
                    .attr("x", d.width * 0.25)
                    .attr("y", d.height * 0.28)
                    .attr("width", d.width * 0.2)
                    .attr("height", 4)
                    .attr("fill", "#333");
                g.append("rect")
                    .attr("x", d.width * 0.55)
                    .attr("y", d.height * 0.28)
                    .attr("width", d.width * 0.2)
                    .attr("height", 4)
                    .attr("fill", "#333");
                // Ground
                g.append("circle")
                    .attr("cx", d.width * 0.5)
                    .attr("cy", d.height * 0.48)
                    .attr("r", 4)
                    .attr("fill", "#333");
            } else {
                // 120V NEMA 5-15 outlet - vertical slots
                g.append("rect")
                    .attr("x", d.width * 0.3)
                    .attr("y", d.height * 0.22)
                    .attr("width", 4)
                    .attr("height", d.height * 0.18)
                    .attr("fill", "#333");
                g.append("rect")
                    .attr("x", d.width * 0.65)
                    .attr("y", d.height * 0.22)
                    .attr("width", 4)
                    .attr("height", d.height * 0.18)
                    .attr("fill", "#333");
                // Ground (round)
                g.append("circle")
                    .attr("cx", d.width * 0.5)
                    .attr("cy", d.height * 0.52)
                    .attr("r", 3)
                    .attr("fill", "#333");
            }
            
            // Voltage label - show live status in live view
            if (liveViewActive && LiveView.state.active) {
                g.append("text")
                    .attr("class", "outlet-status")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", isLive ? "#ffd700" : "#888")
                    .attr("font-weight", isLive ? "bold" : "normal")
                    .text(isLive ? `LIVE ${d.specs.voltage}V` : `${d.specs.voltage}V`);
            } else {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", "#888")
                    .text(`${d.specs.voltage}V`);
            }
            
            // Port labels for daisy-chaining
            g.append("text")
                .attr("x", 3)
                .attr("y", d.height / 2 + 3)
                .attr("font-size", "6px")
                .attr("fill", "#666")
                .text("IN");
            
            g.append("text")
                .attr("x", d.width - 14)
                .attr("y", d.height / 2 + 3)
                .attr("font-size", "6px")
                .attr("fill", "#666")
                .text("OUT");
            
            renderHandles(g, d);
        }
        
        function renderACLoad(g, d) {
            // Check if load is ON in live view
            const isOn = LiveView.state.active && LiveView.state.loadStates[d.id] === true;
            
            // Check if load is on a tripped circuit
            let isOnTrippedCircuit = false;
            if (LiveView.state.active && isOn) {
                // Find the breaker for this load's circuit
                const loadConn = connections.find(c => c.targetItemId === d.id);
                if (loadConn) {
                    const outlet = allItems.find(i => i.id === loadConn.sourceItemId);
                    if (outlet && outlet.type === 'acoutlet') {
                        // Trace back to find breaker
                        const outletConn = connections.find(c => 
                            (c.targetItemId === outlet.id && outlet.handles?.input) ||
                            (c.sourceItemId === outlet.id && outlet.handles?.input)
                        );
                        if (outletConn) {
                            const breaker = allItems.find(i => 
                                i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId
                            );
                            if (breaker && (breaker.type === 'acbreaker' || breaker.type === 'breaker')) {
                                isOnTrippedCircuit = !breaker.isClosed && LiveView.state.breakerStates[breaker.id]?.wasTripped;
                            }
                        }
                    }
                }
            }
            
            // Main rect - appliance body with improved colors
            // Yellow when ON, red when tripped, dark gray when OFF
            const fillColor = isOn ? (isOnTrippedCircuit ? "#4a2a2a" : "#4a4a2a") : "#2a2a2a";
            const strokeColor = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
            const strokeWidth = isOn ? 4 : 2;
            
            const mainRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);
            
            // Make entire node clickable - in live mode: toggle + select, in build mode: just select
            // The item-group click handler will handle selection, we just need to add toggle for live mode
            if (currentMode === 'live' && LiveView.state.active) {
                g.style("cursor", "pointer");
                mainRect.style("cursor", "pointer");
            } else {
                mainRect.style("cursor", "default");
                g.style("cursor", "default");
            }
            
            // Add glow effect when ON (yellow glow) or tripped (red glow)
            if (isOn && liveViewActive) {
                const glowColor = isOnTrippedCircuit ? "#ff4444" : "#ffd700";
                g.append("rect")
                    .attr("width", d.width)
                    .attr("height", d.height)
                    .attr("rx", 10)
                    .attr("ry", 10)
                    .attr("fill", "none")
                    .attr("stroke", glowColor)
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6)
                    .style("filter", "blur(3px)");
            }
            
            // Icon - bigger and more visible
            g.append("text")
                .attr("class", "load-icon")
                .attr("x", d.width / 2)
                .attr("y", 28)
                .attr("text-anchor", "middle")
                .attr("font-size", "24px")
                .attr("opacity", isOn ? 1 : 0.5)
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                .text(d.specs.icon || "âš¡");
            
            // Name - bigger font
            g.append("text")
                .attr("class", "load-name")
                .attr("x", d.width / 2)
                .attr("y", 48)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff6666" : "#ffd700") : "#aaa")
                .attr("font-weight", "bold")
                .text(d.specs.name.length > 14 ? d.specs.name.substring(0, 13) + "â€¦" : d.specs.name);
            
            // Wattage or status - bigger and more prominent
            if (liveViewActive) {
                if (isOn) {
                    const loadWatts = getLoadWatts(d);
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", isOnTrippedCircuit ? "#ff4444" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(`${loadWatts}W`);
                } else {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#888")
                        .attr("font-weight", "bold")
                        .text("OFF");
                }
            } else {
                g.append("text")
                    .attr("class", "load-watts")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 12)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "11px")
                    .attr("fill", "#ffd700")
                    .attr("font-weight", "bold")
                    .text(`${getLoadWatts(d)}W`);
            }
            
            // Cord line visual (from top port down into unit)
            g.append("line")
                .attr("x1", d.width / 2)
                .attr("y1", 0)
                .attr("x2", d.width / 2)
                .attr("y2", 10)
                .attr("stroke", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#222")
                .attr("stroke-width", 4);
            
            // On/Off Toggle Switch - bigger and more prominent with red/yellow colors
            const switchGroup = g.append("g")
                .attr("class", "load-switch-group")
                .style("pointer-events", "none"); // Disable pointer events on switch since whole node is clickable
            
            // Switch background (track) - bigger and less cramped
            const switchWidth = 50;
            const switchHeight = 22;
            const switchX = (d.width - switchWidth) / 2; // Centered horizontally
            const switchY = d.height - switchHeight - 10; // Near bottom with more space (increased from 8 to 10 for better spacing)
            
            // Track colors: yellow when ON, red when tripped, gray when OFF
            const trackFill = isOn ? (isOnTrippedCircuit ? "#4a2020" : "#4a4a20") : "#3a3a3a";
            const trackStroke = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
            
            switchGroup.append("rect")
                .attr("class", "load-switch-track")
                .attr("x", switchX)
                .attr("y", switchY)
                .attr("width", switchWidth)
                .attr("height", switchHeight)
                .attr("rx", 9)
                .attr("ry", 9)
                .attr("fill", trackFill)
                .attr("stroke", trackStroke)
                .attr("stroke-width", 2);
            
            // Switch toggle (slider) - bigger and more visible
            const toggleSize = 18;
            const toggleX = isOn ? (switchX + switchWidth - toggleSize - 2) : (switchX + 2);
            const toggleY = switchY + 2;
            
            // Toggle colors: yellow when ON, red when tripped, gray when OFF
            const toggleFill = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888";
            const toggleStroke = isOn ? (isOnTrippedCircuit ? "#ff6666" : "#fff700") : "#aaa";
            
            switchGroup.append("rect")
                .attr("class", "load-switch-toggle")
                .attr("x", toggleX)
                .attr("y", toggleY)
                .attr("width", toggleSize)
                .attr("height", toggleSize)
                .attr("rx", 7)
                .attr("ry", 7)
                .attr("fill", toggleFill)
                .attr("stroke", toggleStroke)
                .attr("stroke-width", 1);
            
            // Switch label (ON/OFF text) - bigger and more visible
            switchGroup.append("text")
                .attr("class", "load-switch-label")
                .attr("x", switchX + switchWidth / 2)
                .attr("y", switchY - 4)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                .attr("font-weight", "bold")
                .text(isOn ? (isOnTrippedCircuit ? "TRIPPED" : "ON") : "OFF");
            
            renderHandles(g, d);
        }
        
        // Helper function to get the correct watts value for a load based on its behavior type
        function getLoadWatts(load) {
            if (!load || !load.specs) return 0;
            const behavior = load.specs.behavior || { type: 'constant' };
            // For constant loads, use avgWatts; for others, use maxWatts
            if (behavior.type === 'constant') {
                return load.specs.avgWatts || load.specs.maxWatts || 0;
            } else {
                return load.specs.maxWatts || load.specs.avgWatts || 0;
            }
        }
        
        // Helper function to check if a load's circuit is live (used by toggleLoad)
        function checkLoadCircuitStatus(load) {
            // Safety check: make sure load still exists
            if (!load || !allItems.find(i => i.id === load.id)) {
                return { isLive: false, message: "Load not found" };
            }
            
            // Find the connection from load to outlet
            const loadConn = connections.find(c => {
                const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                const targetItem = allItems.find(i => i.id === c.targetItemId);
                return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                       (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
            });
            if (!loadConn) return { isLive: false, message: "Load not connected to outlet" };
            
            // Find the outlet
            let outlet = allItems.find(i => 
                (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                i.type === 'acoutlet'
            );
            if (!outlet) return { isLive: false, message: "Outlet not found" };
            
            // Trace back through daisy-chained outlets to find the breaker
            const visitedOutlets = new Set();
            const traceToBreaker = (currentOutlet) => {
                if (visitedOutlets.has(currentOutlet.id)) return null;
                visitedOutlets.add(currentOutlet.id);
                
                // Check all connections from this outlet
                const outletConnections = connections.filter(c => 
                    c.sourceItemId === currentOutlet.id || c.targetItemId === currentOutlet.id
                );
                
                for (const outletConn of outletConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId) &&
                        i.id !== currentOutlet.id
                    );
                    if (!otherItem) continue;
                    
                    // Check if it's a regular AC breaker
                    if (otherItem.type === 'acbreaker') {
                        const breakerHandle = otherItem.handles?.loadOut;
                        const outletHandle = currentOutlet.handles?.input;
                        if (breakerHandle && outletHandle &&
                            (outletConn.sourceHandleId === breakerHandle.id || outletConn.targetHandleId === breakerHandle.id) &&
                            (outletConn.sourceHandleId === outletHandle.id || outletConn.targetHandleId === outletHandle.id)) {
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isBreakerClosed(otherItem)) {
                                return { isLive: false, message: "This circuit has no power. Check your breakers." };
                            }
                            // Verify breaker is connected to a power source
                            if (!hasPowerSourceConnection(otherItem)) {
                                return { isLive: false, message: "This circuit has no power. Check your breakers." };
                            }
                            return { isLive: true };
                        }
                    }
                    
                    // Check if it's a breaker panel
                    if (otherItem.type === 'breakerpanel') {
                        if (otherItem.mainBreakerOn === false) {
                            return { isLive: false, message: "Main breaker is off" };
                        }
                        
                        // Find which circuit handle this outlet is connected to
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < 8) {
                                // Use unified breaker state checking
                                if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                // Verify panel is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // Check if it's a spider box
                    if (otherItem.type === 'spiderbox') {
                        // Find which circuit handle this outlet is connected to
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < otherItem.specs.circuits.length) {
                                // Use unified breaker state checking
                                if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                // Verify spider box is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // If it's another outlet, check if we're tracing backwards through daisy-chain
                    // Current outlet's INPUT should be connected to previous outlet's OUTPUT
                    if (otherItem.type === 'acoutlet') {
                        const currentOutletInput = currentOutlet.handles?.input;
                        const previousOutletOutput = otherItem.handles?.output;
                        
                        // Check if this connection is: previousOutlet.output â†’ currentOutlet.input
                        if (currentOutletInput && previousOutletOutput &&
                            (outletConn.sourceHandleId === previousOutletOutput.id || outletConn.targetHandleId === previousOutletOutput.id) &&
                            (outletConn.sourceHandleId === currentOutletInput.id || outletConn.targetHandleId === currentOutletInput.id)) {
                            // This is a daisy-chain connection going backwards - trace through it
                            const result = traceToBreaker(otherItem);
                            if (result) return result;
                        }
                    }
                }
                
                return null;
            };
            
            const result = traceToBreaker(outlet);
            if (result) return result;
            
            return { isLive: false, message: "Circuit not found" };
        }
        
        // Check if turning on a load would trip a breaker
        function wouldLoadTripBreaker(load) {
            if (!LiveView.state.active) return false;
            const currentlyOn = LiveView.state.loadStates[load.id] === true;
            if (currentlyOn) return false; // Already on, can't trip by turning on
            
            // Find the breaker or circuit that protects this load
            const circuitStatus = checkLoadCircuitStatus(load);
            if (!circuitStatus.isLive) return false; // Circuit not live, can't trip
            
            // Temporarily turn on the load to check circuit amperage
            LiveView.state.loadStates[load.id] = true;
            
            let wouldTrip = false;
            let breakerInfo = null;
            
            // Check if load is connected to a breaker panel circuit
            const outlets = allItems.filter(i => i.type === 'acoutlet');
            const connectedOutlet = outlets.find(outlet => {
                if (!outlet.handles?.load) return false;
                return outlet.handles.load.connectedTo.some(conn => {
                    const connObj = connections.find(c => c.id === conn.connectionId);
                    if (!connObj) return false;
                    return (connObj.sourceItemId === load.id || connObj.targetItemId === load.id) &&
                           (connObj.sourceItemId === outlet.id || connObj.targetItemId === outlet.id);
                });
            });
            
            if (connectedOutlet) {
                // Find the breaker panel circuit this outlet is on
                const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                for (const panel of breakerPanels) {
                    if (panel.mainBreakerOn === false) continue;
                    for (let i = 0; i < 8; i++) {
                        const handleKey = `circuit${i + 1}`;
                        const circuitHandle = panel.handles[handleKey];
                        if (!circuitHandle || !circuitHandle.circuitName) continue;
                        
                        // Check if outlet is on this circuit
                        const outletOnCircuit = circuitHandle.connectedTo && circuitHandle.connectedTo.some(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return false;
                            return (connObj.sourceItemId === outlet.id || connObj.targetItemId === outlet.id) &&
                                   (connObj.sourceHandleId === circuitHandle.id || connObj.targetHandleId === circuitHandle.id);
                        });
                        
                        if (outletOnCircuit) {
                            // Check if circuit breaker is closed (not tripped)
                            if (LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) {
                                const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, circuitHandle);
                                const breakerRating = circuitHandle.maxAmps || 0;
                                if (circuitInfo.totalAmps > breakerRating) {
                                    wouldTrip = true;
                                    breakerInfo = { type: 'panel', panel: panel, index: i, handle: circuitHandle, rating: breakerRating, amps: circuitInfo.totalAmps };
                                    break;
                                }
                            }
                        }
                    }
                    if (wouldTrip) break;
                }
                
                // Check spider boxes too
                if (!wouldTrip) {
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    for (const spiderbox of spiderBoxes) {
                        if (!spiderbox.handles) continue;
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Check if outlet is on this circuit
                            const outletOnCircuit = circuitHandle.connectedTo && circuitHandle.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === outlet.id || connObj.targetItemId === outlet.id) &&
                                       (connObj.sourceHandleId === circuitHandle.id || connObj.targetHandleId === circuitHandle.id);
                            });
                            
                            if (outletOnCircuit) {
                                // Check if circuit breaker is closed (not tripped)
                                if (LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) {
                                    const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, circuitHandle);
                                    const breakerRating = circuitHandle.maxAmps || 0;
                                    if (circuitInfo.totalAmps > breakerRating) {
                                        wouldTrip = true;
                                        breakerInfo = { type: 'spiderbox', spiderbox: spiderbox, index: i, handle: circuitHandle, rating: breakerRating, amps: circuitInfo.totalAmps };
                                        break;
                                    }
                                }
                            }
                        }
                        if (wouldTrip) break;
                    }
                }
            }
            
            // Check standalone AC breakers
            if (!wouldTrip) {
                const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                for (const breaker of acBreakers) {
                    if (!LiveView.BreakerManager.isBreakerClosed(breaker)) continue;
                    
                    // Check if load is downstream of this breaker
                    const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                    const loadOnCircuit = circuitInfo.loads.some(l => l.id === load.id);
                    
                    if (loadOnCircuit) {
                        const breakerRating = breaker.specs.rating || 0;
                        if (circuitInfo.totalAmps > breakerRating) {
                            wouldTrip = true;
                            breakerInfo = { type: 'breaker', breaker: breaker, rating: breakerRating, amps: circuitInfo.totalAmps };
                            break;
                        }
                    }
                }
            }
            
            // Restore original state
            LiveView.state.loadStates[load.id] = false;
            
            return wouldTrip ? breakerInfo : false;
        }
        
        // Toggle load on/off
        function toggleLoad(load) {
            if (!LiveView.state.active) return;
            
            // Check if load's circuit is live
            const circuitStatus = checkLoadCircuitStatus(load);
            
            // If trying to turn ON but circuit is not live, show warning and don't toggle
            const currentlyOn = LiveView.state.loadStates[load.id] === true;
            if (!circuitStatus.isLive && !currentlyOn) {
                showHint("âš ï¸ Circuit Not Live", circuitStatus.message);
                return;
            }
            
            // If circuit is not live and load is on, it will be automatically turned off
            // by Display.update(), but we can still toggle it off manually
            if (!circuitStatus.isLive && currentlyOn) {
                // Circuit lost power - turn off the load
                LiveView.state.loadStates[load.id] = false;
                render();
                return;
            }
            
            // If trying to turn ON, check if it would trip a breaker
            if (!currentlyOn) {
                const breakerCheck = wouldLoadTripBreaker(load);
                if (breakerCheck) {
                    // Turn on the load briefly (200ms) to show visual feedback
                    LiveView.state.loadStates[load.id] = true;
                    // Recalculate power flow so wires glow during the brief on period
                    LiveView.PowerFlow.calculate();
                    render(); // Immediate visual feedback
                    
                    // After 200ms, trigger breaker check (load is still on, so breaker will trip)
                    setTimeout(() => {
                        // Trigger breaker check which will trip the breaker and turn off all loads
                        LiveView.BreakerManager.checkTripping();
                        // Power flow is already recalculated in checkTripping if breaker trips
                        render();
                        LiveView.Animation.scheduleUpdate();
                    }, 200);
                    return;
                }
            }
            
            // Circuit is live and won't trip - toggle normally
            LiveView.state.loadStates[load.id] = !LiveView.state.loadStates[load.id];
            LiveView.Animation.scheduleUpdate();
        }
        
        function renderSpiderBox(g, d) {
            // Main housing - yellow/black industrial look
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "#2a2a18")
                .attr("stroke", "#f0ad4e")
                .attr("stroke-width", 4);
            
            // Yellow warning stripes at top
            for (let i = 0; i < 5; i++) {
                g.append("rect")
                    .attr("x", 10 + i * 35)
                    .attr("y", 3)
                    .attr("width", 18)
                    .attr("height", 8)
                    .attr("fill", i % 2 === 0 ? "#f0ad4e" : "#222");
            }
            
            // Title bar
            g.append("rect")
                .attr("x", 5)
                .attr("y", 14)
                .attr("width", d.width - 10)
                .attr("height", 18)
                .attr("rx", 3)
                .attr("fill", "#f0ad4e");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 27)
                .attr("text-anchor", "middle")
                .attr("font-size", "11px")
                .attr("fill", "#000")
                .attr("font-weight", "bold")
                .text("âš¡ CEP SPIDER BOX");
            
            // Input section on left
            g.append("rect")
                .attr("x", 8)
                .attr("y", d.height / 2 - 18)
                .attr("width", 50)
                .attr("height", 36)
                .attr("rx", 4)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#d9534f")
                .attr("stroke-width", 2);
            
            g.append("text")
                .attr("x", 33)
                .attr("y", d.height / 2 - 4)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#d9534f")
                .attr("font-weight", "bold")
                .text("240V");
            g.append("text")
                .attr("x", 33)
                .attr("y", d.height / 2 + 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#d9534f")
                .attr("font-weight", "bold")
                .text("50A IN");
            
            // Circuit breaker section - larger and cleaner
            g.append("rect")
                .attr("x", 70)
                .attr("y", 40)
                .attr("width", d.width - 80)
                .attr("height", d.height - 50)
                .attr("rx", 5)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#333")
                .attr("stroke-width", 1);
            
            // Circuit breaker indicators with improved visual feedback
            d.specs.circuits.forEach((circuit, i) => {
                const yPos = 50 + (i * 18); // Increased spacing
                const handle = d.handles[`circuit${i + 1}`];
                const isClosed = handle.isClosed !== false;
                const is240 = circuit.voltage === 240;
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, handle);
                    circuitAmps = circuitInfo.totalAmps;
                    circuitWatts = circuitInfo.totalWatts;
                }
                
                // Breaker toggle group
                const breakerGroup = g.append("g")
                    .attr("class", "spider-breaker")
                    .style("cursor", "pointer")
                    .on("click", (event) => {
                        event.stopPropagation();
                        const wasOn = handle.isClosed !== false;
                        handle.isClosed = !handle.isClosed;
                        const isNowOn = handle.isClosed !== false;
                        
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${d.id}-circuit-${i + 1}`;
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: handle.isClosed,
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                            
                            // If breaker was turned off, immediately turn off all loads on this circuit
                            if (wasOn && !isNowOn) {
                                // Turn off all loads connected to this circuit
                                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                    const load = allItems.find(i => i.id === loadId);
                                    if (load && load.type === 'acload') {
                                        const circuitStatus = checkLoadCircuitStatus(load);
                                        if (!circuitStatus.isLive) {
                                            LiveView.state.loadStates[loadId] = false;
                                        }
                                    }
                                });
                            }
                        }
                        if (LiveView.state.active) {
                            LiveView.Animation.scheduleUpdate();
                        } else {
                            render();
                        }
                    });
                
                // Breaker body - improved colors: yellow when ON, red when OFF/TRIPPED
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 75)
                    .attr("y", yPos - 6)
                    .attr("width", d.width - 90)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("ry", 3)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = isClosed ? 78 : 90;
                const toggleSize = 10;
                const toggleY = yPos - 4;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "spider-toggle-track")
                    .attr("x", 75)
                    .attr("y", toggleY)
                    .attr("width", 20)
                    .attr("height", 12)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "spider-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 1)
                    .attr("width", toggleSize)
                    .attr("height", 10)
                    .attr("rx", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 1.5);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "spider-position-indicator")
                    .attr("x", 85)
                    .attr("y", toggleY + 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "7px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", 100)
                    .attr("y", yPos + 3)
                    .attr("text-anchor", "start")
                    .attr("font-size", "9px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view) - larger and more visible
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 25)
                        .attr("y", yPos + 4)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff6666" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width / 2)
                            .attr("y", yPos + 1)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "8px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 25)
                        .attr("y", yPos + 4)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", isClosed ? (is240 ? "#ff6666" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.voltage}V ${circuit.amps}A`);
                }
            });
            
            renderHandles(g, d);
        }
        
        function renderBreakerPanel(g, d) {
            // Main panel housing - gray metal enclosure
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#3a3a3a")
                .attr("stroke", "#666")
                .attr("stroke-width", 3);
            
            // Panel door with embossed look
            g.append("rect")
                .attr("x", 8)
                .attr("y", 22)
                .attr("width", d.width - 16)
                .attr("height", d.height - 32)
                .attr("rx", 3)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#555")
                .attr("stroke-width", 1);
            
            // Title plate
            g.append("rect")
                .attr("x", d.width / 2 - 50)
                .attr("y", 4)
                .attr("width", 100)
                .attr("height", 14)
                .attr("rx", 2)
                .attr("fill", "#444");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 14)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#ccc")
                .attr("font-weight", "bold")
                .text("âš¡ 100A MAIN PANEL");
            
            // Main breaker at top center (double-pole) - FUNCTIONAL
            const mainOn = d.mainBreakerOn !== false;
            const mainBreakerGroup = g.append("g")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        // Turn off all loads connected to this panel's circuits
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                // If this load is on a circuit from this panel, turn it off
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    } else {
                        render();
                    }
                });
            
            mainBreakerGroup.append("rect")
                .attr("x", d.width / 2 - 25)
                .attr("y", 28)
                .attr("width", 50)
                .attr("height", 22)
                .attr("rx", 3)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555")
                .attr("stroke-width", 2);
            
            // Main breaker toggle indicator
            mainBreakerGroup.append("rect")
                .attr("x", mainOn ? d.width / 2 - 22 : d.width / 2 - 14)
                .attr("y", 31)
                .attr("width", 10)
                .attr("height", 16)
                .attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 38)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", mainOn ? "#fff" : "#666")
                .attr("font-weight", "bold")
                .text("MAIN");
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 47)
                .attr("text-anchor", "middle")
                .attr("font-size", "7px")
                .attr("fill", mainOn ? "#f88" : "#555")
                .text("100A");
            
            // Center bus bar visual - dims when main is off
            g.append("rect")
                .attr("x", d.width / 2 - 3)
                .attr("y", 52)
                .attr("width", 6)
                .attr("height", d.height - 65)
                .attr("fill", mainOn ? "#b87333" : "#4a3a2a"); // Copper color or dimmed
            
            // Left side breakers (circuits 1-4)
            for (let i = 0; i < 4; i++) {
                const yPos = 65 + (i * 42); // Increased spacing for larger size
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn; // Respect main breaker
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${d.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    // Turn off all loads connected to this circuit
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            // Immediately recalculate power flow and re-render
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            // Refresh inspector if breaker panel or load is currently selected
                            if (selectedItem) {
                                if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel') {
                                    openInspector(selectedItem);
                                }
                            }
                        }
                    });
                
                // Breaker body - improved colors: yellow when ON, red when OFF/TRIPPED
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 15)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? 18 : 32;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", 15)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? "#ffd700" : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", 12)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", 26)
                    .attr("y", toggleY + 11)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", 42)
                    .attr("y", yPos + 12)
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : "#ffd700") : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view)
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "7px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", 45)
                            .attr("y", yPos + 9)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 18)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", isClosed ? "#ffd700" : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
            }
            
            // Right side breakers (circuits 5-8)
            for (let i = 4; i < 8; i++) {
                const yPos = 65 + ((i - 4) * 42); // Increased spacing for larger size
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn; // Respect main breaker
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                const is240 = circuit.voltage === 240;
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${d.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    // Turn off all loads connected to this circuit
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            // Immediately recalculate power flow and re-render
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            // Refresh inspector if breaker panel or load is currently selected
                            if (selectedItem) {
                                if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel') {
                                    openInspector(selectedItem);
                                }
                            }
                        }
                    });
                
                // Breaker body (240V breakers are taller - double pole) - improved colors
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", d.width - 90)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", is240 ? 38 : 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? d.width - 87 : d.width - 73;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                const toggleHeight = is240 ? 26 : 16;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", d.width - 90)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", toggleHeight)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", toggleHeight - 4)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", d.width - 79)
                    .attr("y", toggleY + (is240 ? 16 : 10))
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", d.width - 65)
                    .attr("y", yPos + (is240 ? 18 : 12))
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view)
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + (is240 ? 24 : 20))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff6666" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width - 45)
                            .attr("y", yPos + (is240 ? 14 : 9))
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + (is240 ? 28 : 22))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .attr("fill", isClosed ? (is240 ? "#ff6666" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
                
                if (is240) {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + 8)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "6px")
                        .attr("fill", "#888")
                        .text("240V");
                }
            }
            
            renderHandles(g, d);
        }
        
        function renderBreaker(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4);
            
            // Breaker switch clickable group
            const switchGroup = g.append("g")
                .attr("class", "breaker-switch-group")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.isClosed = !d.isClosed;
                    render();
                    validateSystem();
                });
            
            // Breaker switch visual (toggle indicator)
            switchGroup.append("rect")
                .attr("class", "breaker-switch")
                .attr("x", d.width * 0.25)
                .attr("y", d.height * 0.3)
                .attr("width", d.width * 0.5)
                .attr("height", d.height * 0.15)
                .attr("rx", 2)
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
            
            // Switch lever
            switchGroup.append("rect")
                .attr("class", "breaker-lever")
                .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25)
                .attr("y", d.height * 0.28)
                .attr("width", d.width * 0.25)
                .attr("height", d.height * 0.19)
                .attr("rx", 2)
                .attr("fill", "#ddd")
                .attr("stroke", "#999")
                .attr("stroke-width", 1);
            
            // Label
            g.append("text")
                .attr("class", "breaker-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.65)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(d.specs.rating + "A");
            
            g.append("text")
                .attr("class", "breaker-status")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.82)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
                .attr("font-size", "9px")
                .text(d.isClosed ? "CLOSED" : "OPEN");
            
            // Port labels
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", -18)
                .attr("text-anchor", "middle")
                .text("LINE");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", d.height + 22)
                .attr("text-anchor", "middle")
                .text("LOAD");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderCombiner(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4);
            
            // Internal busbar visualization (PV colors)
            g.append("rect")
                .attr("class", "combiner-busbar positive-bus")
                .attr("x", 8)
                .attr("y", d.height * 0.35)
                .attr("width", d.width - 16)
                .attr("height", 4)
                .attr("fill", "#f0ad4e");
            
            g.append("rect")
                .attr("class", "combiner-busbar negative-bus")
                .attr("x", 8)
                .attr("y", d.height * 0.55)
                .attr("width", d.width - 16)
                .attr("height", 4)
                .attr("fill", "#5bc0de");
            
            // Label
            g.append("text")
                .attr("class", "combiner-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.85)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "10px")
                .text(d.specs.inputs + "-STRING");
            
            // Input labels
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", -18)
                .attr("text-anchor", "middle")
                .text("INPUTS");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", d.height + 22)
                .attr("text-anchor", "middle")
                .text("OUTPUT");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderSolarCombiner(g, d) {
            // Main rect with distinct styling
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Individual breaker indicators for each input
            const numInputs = d.specs.inputs;
            for (let i = 0; i < numInputs; i++) {
                const xPos = ((i + 0.5) / numInputs) * d.width;
                const isClosed = d.breakerStates[i];
                
                // Breaker indicator
                g.append("rect")
                    .attr("class", `input-breaker input-breaker-${i}`)
                    .attr("x", xPos - 8)
                    .attr("y", d.height * 0.15)
                    .attr("width", 16)
                    .attr("height", 12)
                    .attr("rx", 2)
                    .attr("fill", isClosed ? "#5cb85c" : "#d9534f")
                    .attr("stroke", "#333")
                    .attr("stroke-width", 1);
            }
            
            // Internal busbars
            g.append("rect")
                .attr("class", "combiner-busbar positive-bus")
                .attr("x", 8)
                .attr("y", d.height * 0.4)
                .attr("width", d.width - 16)
                .attr("height", 4)
                .attr("fill", "#f0ad4e");
            
            g.append("rect")
                .attr("class", "combiner-busbar negative-bus")
                .attr("x", 8)
                .attr("y", d.height * 0.55)
                .attr("width", d.width - 16)
                .attr("height", 4)
                .attr("fill", "#5bc0de");
            
            // Label
            g.append("text")
                .attr("class", "solarcombiner-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.78)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "9px")
                .attr("font-weight", "bold")
                .text("SOLAR COMBINER");
            
            g.append("text")
                .attr("class", "solarcombiner-specs")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.92)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#aaa")
                .attr("font-size", "8px")
                .text(numInputs + "x " + d.specs.breakerRating + "A");
            
            // Port labels
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", -18)
                .attr("text-anchor", "middle")
                .text("PV STRINGS");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", d.height + 22)
                .attr("text-anchor", "middle")
                .text("TO CONTROLLER");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderHandles(g, d) {
            Object.values(d.handles).forEach(handle => {
                // Draw handle circle
                g.append("circle")
                    .attr("class", `handle ${handle.polarity}`)
                    .attr("cx", handle.x)
                    .attr("cy", handle.y)
                    .attr("r", HANDLE_RADIUS)
                    .attr("data-handle-id", handle.id)
                    .call(d3.drag()
                        .on("start", (event) => handleDragStart(event, d, handle))
                        .on("drag", handleDragMove)
                        .on("end", handleDragEnd)
                    );
                
                // Add +/- symbol centered on handle (for DC polarities)
                const normalizedPolarity = handle.polarity === 'pv-positive' ? 'positive' : 
                                          handle.polarity === 'pv-negative' ? 'negative' : 
                                          handle.polarity;
                if (normalizedPolarity === 'positive' || normalizedPolarity === 'negative') {
                    const symbol = normalizedPolarity === 'positive' ? '+' : 'âˆ’';
                    g.append("text")
                        .attr("class", "handle-symbol")
                        .attr("x", handle.x)
                        .attr("y", handle.y)
                        .attr("dominant-baseline", "central")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#fff")
                        .attr("font-weight", "bold")
                        .attr("font-size", "12px")
                        .attr("pointer-events", "none")
                        .text(symbol);
                } else if (handle.polarity === 'ac') {
                    // AC symbol
                    g.append("text")
                        .attr("class", "handle-symbol")
                        .attr("x", handle.x)
                        .attr("y", handle.y)
                        .attr("dominant-baseline", "central")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#fff")
                        .attr("font-weight", "bold")
                        .attr("font-size", "9px")
                        .attr("pointer-events", "none")
                        .text("~");
                }
            });
        }
        
        function updateItemContent(g, d) {
            // Update labels based on current specs
            if (d.type === 'panel') {
                g.select(".wmp-label").text(d.specs.wmp + "W");
                g.select(".voc-label").text(d.specs.voc.toFixed(1) + "V");
            } else if (d.type === 'battery') {
                g.select(".voltage-label").text(d.specs.voltage.toFixed(1) + "V");
                g.select(".ah-label").text(d.specs.ah + "Ah");
                // Update battery display - show live view data if active
                if (liveViewActive) {
                    const controllers = allItems.filter(i => i.type === 'controller');
                    let batteryKwh = d.specs.kWh || 0;
                    let batteryPercent = 50;
                    
                    controllers.forEach(controller => {
                        if (controller.handles?.batteryPositive) {
                            controller.handles.batteryPositive.connectedTo.forEach(conn => {
                                const batt = allItems.find(i => i.id === conn.itemId);
                                if (batt && batt.id === d.id) {
                                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                                    batteryKwh = batterySpecs.kWh || batteryKwh;
                                }
                            });
                        }
                    });
                    
                    g.select(".battery-specs")
                        .text(`${batteryKwh.toFixed(1)}kWh (${batteryPercent}%)`)
                        .attr("fill", "#5cb85c");
                } else {
                    g.select(".battery-specs").text(d.specs.kWh.toFixed(2) + " kWh");
                }
            } else if (d.type === 'controller') {
                // Update controller display - show live view data if active
                if (liveViewActive) {
                    const arraySpecs = calculateConnectedArraySpecs(d);
                    const dcInputWatts = arraySpecs.wmp || 0;
                    const acOutputWatts = Math.min(dcInputWatts, d.specs.maxACOutputW || 0);
                    
                    const specs = g.selectAll(".controller-specs").data([
                        `DC: ${dcInputWatts}W`,
                        `AC: ${acOutputWatts}W`
                    ]);
                    specs.text(t => t).attr("fill", "#f0ad4e");
                } else {
                    g.selectAll(".controller-specs").data([
                        d.specs.maxWmp + "W max",
                        d.specs.maxVoc + "V / " + d.specs.maxIsc + "A"
                    ]).text(t => t);
                }
            } else if (d.type === 'breaker') {
                // Update breaker switch visual
                g.select(".breaker-switch")
                    .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
                // Update lever position
                g.select(".breaker-lever")
                    .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25);
                // Update status text
                g.select(".breaker-status")
                    .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
                    .text(d.isClosed ? "CLOSED" : "OPEN");
            } else if (d.type === 'acoutlet') {
                // Update outlet display
                const is240V = d.specs.voltage === 240;
                let isLive = false;
                if (liveViewActive && LiveView.state.active) {
                    const circuitStatus = checkOutletCircuitStatus(d);
                    isLive = circuitStatus.isLive;
                }
                
                // Update main rect
                const mainRect = g.select(".item-rect");
                if (mainRect.node()) {
                    const fillColor = isLive ? "#3a3a2a" : "#2a2a2a";
                    const strokeColor = isLive ? (is240V ? "#ff6666" : "#ffd700") : (is240V ? "#d9534f" : "#f0ad4e");
                    const strokeWidth = isLive ? 3 : 2;
                    
                    mainRect
                        .attr("fill", fillColor)
                        .attr("stroke", strokeColor)
                        .attr("stroke-width", strokeWidth);
                }
                
                // Update outlet status text
                const statusText = g.select(".outlet-status");
                if (statusText.node()) {
                    if (liveViewActive && LiveView.state.active) {
                        statusText
                            .text(isLive ? `LIVE ${d.specs.voltage}V` : `${d.specs.voltage}V`)
                            .attr("fill", isLive ? "#ffd700" : "#888")
                            .attr("font-weight", isLive ? "bold" : "normal");
                    } else {
                        statusText.text(`${d.specs.voltage}V`).attr("fill", "#888");
                    }
                } else {
                    // Status text might not exist yet, check if we need to create it
                    if (liveViewActive && LiveView.state.active) {
                        g.select("text").filter(function() {
                            return this.textContent && this.textContent.includes("V");
                        }).each(function() {
                            const text = d3.select(this);
                            if (isLive) {
                                text
                                    .attr("class", "outlet-status")
                                    .text(`LIVE ${d.specs.voltage}V`)
                                    .attr("fill", "#ffd700")
                                    .attr("font-weight", "bold");
                            } else {
                                text
                                    .attr("class", "outlet-status")
                                    .text(`${d.specs.voltage}V`)
                                    .attr("fill", "#888")
                                    .attr("font-weight", "normal");
                            }
                        });
                    }
                }
                
                // Update glow effect - only show when live, remove when not live
                // Find glow rect by checking for rects with blur filter
                const glowRect = g.selectAll("rect").filter(function() {
                    const filter = this.style.filter || "";
                    return filter.includes("blur") && this.getAttribute("fill") === "none";
                });
                
                if (isLive) {
                    // Add or update glow effect when live
                    if (glowRect.empty()) {
                        const glowColor = is240V ? "#ff6666" : "#ffd700";
                        g.append("rect")
                            .attr("class", "outlet-glow")
                            .attr("width", d.width)
                            .attr("height", d.height)
                            .attr("rx", 6)
                            .attr("ry", 6)
                            .attr("fill", "none")
                            .attr("stroke", glowColor)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6)
                            .style("filter", "blur(3px)");
                    } else {
                        const glowColor = is240V ? "#ff6666" : "#ffd700";
                        glowRect
                            .attr("stroke", glowColor)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6);
                    }
                } else {
                    // Remove glow effect when not live
                    glowRect.remove();
                }
            } else if (d.type === 'acload') {
                // Update load display
                const isOn = LiveView.state.active && LiveView.state.loadStates[d.id] === true;
                
                // Check if load is on a tripped circuit
                let isOnTrippedCircuit = false;
                if (LiveView.state.active && isOn) {
                    const loadConn = connections.find(c => c.targetItemId === d.id);
                    if (loadConn) {
                        const outlet = allItems.find(i => i.id === loadConn.sourceItemId);
                        if (outlet && outlet.type === 'acoutlet') {
                            const outletConn = connections.find(c => 
                                (c.targetItemId === outlet.id && outlet.handles?.input) ||
                                (c.sourceItemId === outlet.id && outlet.handles?.input)
                            );
                            if (outletConn) {
                                const breaker = allItems.find(i => 
                                    i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId
                                );
                                if (breaker && (breaker.type === 'acbreaker' || breaker.type === 'breaker')) {
                                    isOnTrippedCircuit = !breaker.isClosed && LiveView.state.breakerStates[breaker.id]?.wasTripped;
                                }
                            }
                        }
                    }
                }
                
                // Update icon
                const icon = g.select(".load-icon");
                if (icon.node()) {
                    icon
                        .text(d.specs.icon || "âš¡")
                        .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                        .attr("opacity", isOn ? 1 : 0.5);
                }
                
                // Update name
                const name = g.select(".load-name");
                if (name.node()) {
                    name
                        .text(d.specs.name.length > 14 ? d.specs.name.substring(0, 13) + "â€¦" : d.specs.name)
                        .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff6666" : "#ffd700") : "#aaa");
                }
                
                // Update watts/status
                const watts = g.select(".load-watts");
                if (watts.node()) {
                    if (liveViewActive) {
                        if (isOn) {
                            const loadWatts = getLoadWatts(d);
                            watts
                                .text(`${loadWatts}W`)
                                .attr("fill", isOnTrippedCircuit ? "#ff4444" : "#ffd700");
                        } else {
                            watts
                                .text("OFF")
                                .attr("fill", "#888");
                        }
                    } else {
                        watts
                            .text(`${getLoadWatts(d)}W`)
                            .attr("fill", "#ffd700");
                    }
                }
                
                // Update main rect colors
                const mainRect = g.select(".item-rect");
                if (mainRect.node()) {
                    const fillColor = isOn ? (isOnTrippedCircuit ? "#4a2a2a" : "#4a4a2a") : "#2a2a2a";
                    const strokeColor = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
                    const strokeWidth = isOn ? 4 : 2;
                    
                    mainRect
                        .attr("fill", fillColor)
                        .attr("stroke", strokeColor)
                        .attr("stroke-width", strokeWidth);
                    
                    // Update cursor for live view
                    if (currentMode === 'live' && LiveView.state.active) {
                        mainRect
                            .style("cursor", "pointer")
                            .on("click", (event) => {
                                event.stopPropagation();
                                toggleLoad(d);
                            });
                        g.style("cursor", "pointer");
                    } else {
                        mainRect
                            .style("cursor", "default")
                            .on("click", null);
                        g.style("cursor", "default");
                    }
                }
                
                // Update cord line
                const cordLine = g.select("line").filter(function() {
                    return this.getAttribute("x1") === String(d.width / 2) && 
                           this.getAttribute("y1") === "0";
                });
                if (cordLine.node()) {
                    cordLine
                        .attr("stroke", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#222");
                }
                
                const switchGroup = g.select(".load-switch-group");
                
                // Update switch track (using larger dimensions)
                const switchWidth = 50;
                const switchHeight = 22;
                const switchX = (d.width - switchWidth) / 2;
                const switchY = d.height - switchHeight - 8;
                const switchTrack = switchGroup.select(".load-switch-track");
                if (switchTrack.node()) {
                    const trackFill = isOn ? (isOnTrippedCircuit ? "#4a2020" : "#4a4a20") : "#3a3a3a";
                    const trackStroke = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
                    switchTrack
                        .attr("x", switchX)
                        .attr("y", switchY)
                        .attr("width", switchWidth)
                        .attr("height", switchHeight)
                        .attr("fill", trackFill)
                        .attr("stroke", trackStroke);
                }
                
                // Update switch toggle position and color (using larger toggle)
                const switchToggle = switchGroup.select(".load-switch-toggle");
                if (switchToggle.node()) {
                    const toggleSize = 18;
                    const toggleX = isOn ? (switchX + switchWidth - toggleSize - 2) : (switchX + 2);
                    const toggleY = switchY + 2;
                    const toggleFill = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888";
                    const toggleStroke = isOn ? (isOnTrippedCircuit ? "#ff6666" : "#fff700") : "#aaa";
                    
                    switchToggle
                        .attr("x", toggleX)
                        .attr("y", toggleY)
                        .attr("width", toggleSize)
                        .attr("height", toggleSize)
                        .attr("fill", toggleFill)
                        .attr("stroke", toggleStroke);
                }
                
                // Update switch label
                const switchLabel = switchGroup.select(".load-switch-label");
                if (switchLabel.node()) {
                    switchLabel
                        .attr("x", switchX + switchWidth / 2)
                        .attr("y", switchY - 4)
                        .text(isOn ? (isOnTrippedCircuit ? "TRIPPED" : "ON") : "OFF")
                        .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888");
                }
            } else if (d.type === 'breakerpanel') {
                // Update breaker panel circuit switch visuals
                const mainOn = d.mainBreakerOn !== false;
                if (!d.breakerStates) d.breakerStates = Array(8).fill(true);
                
                // Update left side breakers (circuits 1-4)
                for (let i = 0; i < 4; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle || !circuitHandle.circuitName) continue;
                    
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    const breakerOn = d.breakerStates[i] !== false;
                    const isClosed = breakerOn && mainOn;
                    
                    const yPos = 65 + (i * 42);
                    const toggleY = yPos + 6;
                    const toggleX = breakerOn ? 18 : 32; // Use breakerOn, not isClosed, to match render logic
                    
                    // Find breaker group by y position (left side breakers are at x=15)
                    const allGroups = g.selectAll("g");
                    let breakerGroup = null;
                    allGroups.each(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectX = parseFloat(rect.attr("x")) || 0;
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            // Left side breakers are at x=15, and y should match
                            if (Math.abs(rectX - 15) < 1 && Math.abs(rectY - yPos) < 1) {
                                breakerGroup = group;
                            }
                        }
                    });
                    
                    if (breakerGroup && breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".breaker-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", isClosed ? (isTripped ? "#ff4444" : "#ffd700") : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".breaker-toggle-slider");
                        if (toggleSlider.node()) {
                            const toggleColor = breakerOn ? (isTripped ? "#ff4444" : "#ffd700") : "#ff4444";
                            const toggleStroke = breakerOn ? (isTripped ? "#ff6666" : "#fff700") : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".breaker-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(breakerOn ? "ON" : "OFF")
                                .attr("fill", breakerOn ? "#fff" : "#888");
                        }
                    }
                }
                
                // Update right side breakers (circuits 5-8)
                for (let i = 4; i < 8; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle || !circuitHandle.circuitName) continue;
                    
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    const breakerOn = d.breakerStates[i] !== false;
                    const isClosed = breakerOn && mainOn;
                    const circuit = d.specs.circuits[i];
                    const is240 = circuit && circuit.voltage === 240;
                    
                    const yPos = 65 + ((i - 4) * 42);
                    const toggleY = yPos + 6;
                    const toggleX = breakerOn ? d.width - 87 : d.width - 73; // Match render code exactly
                    
                    // Find breaker group by y position (right side breakers are at x=d.width-90)
                    const allGroups = g.selectAll("g");
                    let breakerGroup = null;
                    allGroups.each(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectX = parseFloat(rect.attr("x")) || 0;
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            // Right side breakers are at x=d.width-90, and y should match
                            if (Math.abs(rectX - (d.width - 90)) < 1 && Math.abs(rectY - yPos) < 1) {
                                breakerGroup = group;
                            }
                        }
                    });
                    
                    if (breakerGroup && breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".breaker-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", isClosed ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".breaker-toggle-slider");
                        if (toggleSlider.node()) {
                            const toggleColor = breakerOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#ff4444";
                            const toggleStroke = breakerOn ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#fff700")) : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".breaker-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(breakerOn ? "ON" : "OFF")
                                .attr("fill", breakerOn ? "#fff" : "#888");
                        }
                    }
                }
            }
        }
        
        function renderWires() {
            const wireGroups = wiresGroup.selectAll(".wire-group")
                .data(connections, d => d.id);
            
            wireGroups.exit().remove();
            
            const newWireGroups = wireGroups.enter()
                .append("g")
                .attr("class", "wire-group");
            
            // Create wire path
            newWireGroups.append("path")
                .attr("class", d => `wire ${d.polarity}`)
                .style("stroke", d => getWireStyle(d).color) // Set initial color from getWireStyle
                .on("click", (event, d) => {
                    event.stopPropagation();
                    selectConnection(d);
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    deleteConnection(d.id);
                    closeInspector();
                });
            
            const mergedGroups = wireGroups.merge(newWireGroups);
            
            // Update wire path
            mergedGroups.select(".wire")
                .attr("d", d => generateWirePath(d))
                .classed("selected", d => selectedConnection && selectedConnection.id === d.id)
                // Stroke width is now handled below with the filter attribute
                .style("stroke", d => {
                    if (!liveViewActive) {
                        // In build mode, use getWireStyle which handles load voltage colors
                        return getWireStyle(d).color;
                    }
                    
                    const powerFlow = liveViewPowerFlow[d.id];
                    
                    // Handle parallel connections (blue) - Delta Pro to double voltage hub
                    if (d.polarity === 'parallel') {
                        if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                            return '#00a8e8';
                        }
                        return '#00a8e8'; // Blue even when not live
                    }
                    
                    // Handle AC power connections
                    if (d.polarity === 'ac' || d.polarity === 'load') {
                        // Determine voltage from power flow or from load/outlet/breaker specs
                        let voltage = 120;
                        if (powerFlow && powerFlow.voltage) {
                            voltage = powerFlow.voltage;
                        } else {
                            // Check load item voltage
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                            if (loadItem && loadItem.specs?.voltage) {
                                voltage = loadItem.specs.voltage;
                            } else {
                                // Check outlet voltage
                                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                                if (outletItem && outletItem.specs?.voltage) {
                                    voltage = outletItem.specs.voltage;
                                } else {
                                    // For AC connections, check breaker panel circuit handle voltage
                                    const breakerItem = sourceItem?.type === 'breakerpanel' ? sourceItem : (targetItem?.type === 'breakerpanel' ? targetItem : null);
                                    if (breakerItem) {
                                        // Find the circuit handle
                                        const sourceHandle = sourceItem?.handles ? Object.values(sourceItem.handles).find(h => h.id === d.sourceHandleId) : null;
                                        const targetHandle = targetItem?.handles ? Object.values(targetItem.handles).find(h => h.id === d.targetHandleId) : null;
                                        const circuitHandle = sourceHandle || targetHandle;
                                        if (circuitHandle && circuitHandle.voltage) {
                                            voltage = circuitHandle.voltage;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Always use correct color based on voltage (red for 240V, yellow for 120V)
                        // Whether live or not, the color should match the voltage
                        return voltage === 240 ? '#cc0000' : '#ffd700';
                    }
                    
                    // DC power - keep existing behavior
                    if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                        return getWireStyle(d).color;
                    }
                    return getWireStyle(d).color;
                })
                .attr("filter", d => {
                    if (!liveViewActive) return null;
                    const powerFlow = liveViewPowerFlow[d.id];
                    
                    // Only apply glow filter when circuit is actually live
                    if (!powerFlow || (!powerFlow.isLive && powerFlow.watts === 0)) {
                        return null; // No glow when not live
                    }
                    
                    // Apply glow filter based on connection type
                    if (d.polarity === 'parallel') {
                        // Parallel connections glow only when live
                        if (powerFlow.isLive || powerFlow.watts > 0) {
                            return "url(#blue-glow)";
                        }
                        return null;
                    } else if (d.polarity === 'ac' || d.polarity === 'load') {
                        // Determine voltage
                        let voltage = 120;
                        if (powerFlow && powerFlow.voltage) {
                            voltage = powerFlow.voltage;
                        } else if (d.polarity === 'load') {
                            // For load connections, check the load item voltage
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                            if (loadItem && loadItem.specs?.voltage) {
                                voltage = loadItem.specs.voltage;
                            } else {
                                // Check outlet voltage
                                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                                if (outletItem && outletItem.specs?.voltage) {
                                    voltage = outletItem.specs.voltage;
                                }
                            }
                        }
                        
                        // Apply glow only when live
                        if (powerFlow.isLive || powerFlow.watts > 0) {
                            return voltage === 240 ? "url(#red-glow)" : "url(#yellow-glow)";
                        }
                    }
                    return null;
                })
                .attr("stroke-width", d => {
                    if (!liveViewActive) return 3;
                    const powerFlow = liveViewPowerFlow[d.id];
                    // Make live AC wires thicker for better visibility
                    if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                        if (d.polarity === 'parallel' || d.polarity === 'ac' || d.polarity === 'load') {
                            return 5; // Thicker for live AC wires
                        }
                    }
                    return 3;
                })
                .attr("opacity", d => {
                    // Always full opacity - no dimming in live mode
                    // Wires without glow will look like build mode
                    return 1;
                });
        }
        
        // Get wire style based on polarity
        function getWireStyle(conn) {
            const polarity = conn.polarity || 'mixed';
            
            // Check if this is an AC appliance connection (load)
            if (polarity === 'load') {
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                
                // Determine voltage from load first, then outlet
                let voltage = null;
                if (loadItem && loadItem.specs?.voltage) {
                    voltage = loadItem.specs.voltage;
                } else if (outletItem && outletItem.specs?.voltage) {
                    voltage = outletItem.specs.voltage;
                }
                
                if (voltage) {
                    // Color based on voltage
                    if (voltage === 120) {
                        return {
                            color: '#ffd700'  // Yellow for 120V appliance cords
                        };
                    } else if (voltage === 240) {
                        return {
                            color: '#cc0000'  // Darker red for 240V appliance cords
                        };
                    }
                }
            }
            
            const colors = {
                'positive': '#d9534f',      // Red
                'negative': '#333',         // Dark gray/black
                'mixed': '#888',            // Gray
                'ac': '#f0ad4e',           // Orange
                'load': '#222',            // Very dark (fallback)
                'parallel': '#00a8e8',     // Blue
                'smart-battery': '#5cb85c' // Green
            };
            return {
                color: colors[polarity] || colors['mixed']
            };
        }
        
        // Get absolute position of a handle in world coordinates
        function getHandlePosition(item, handle) {
            return {
                x: item.x + handle.x,
                y: item.y + handle.y
            };
        }
        
        // Generate a smooth bezier curve between two handles
        function generateWirePath(conn) {
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            if (!sourceItem || !targetItem) return "";
            
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
            if (!sourceHandle || !targetHandle) return "";
            
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            return generateCurvePath(start.x, start.y, end.x, end.y, sourceHandle.side, targetHandle.side);
        }
        
        // Generate bezier curve path string
        function generateCurvePath(sx, sy, ex, ey, sourceSide, targetSide) {
            sourceSide = sourceSide || 'top';
            targetSide = targetSide || 'top';
            
            // Calculate distance for dynamic curve strength
            const dist = Math.sqrt((ex - sx) ** 2 + (ey - sy) ** 2);
            const curveStrength = Math.min(80, Math.max(30, dist * 0.4));
            
            let sc1x = sx, sc1y = sy, sc2x = ex, sc2y = ey;
            
            // Source control point - extends outward from the handle
            switch (sourceSide) {
                case 'top': sc1y = sy - curveStrength; break;
                case 'bottom': sc1y = sy + curveStrength; break;
                case 'left': sc1x = sx - curveStrength; break;
                case 'right': sc1x = sx + curveStrength; break;
            }
            
            // Target control point - extends outward from the handle
            switch (targetSide) {
                case 'top': sc2y = ey - curveStrength; break;
                case 'bottom': sc2y = ey + curveStrength; break;
                case 'left': sc2x = ex - curveStrength; break;
                case 'right': sc2x = ex + curveStrength; break;
            }
            
            return `M ${sx} ${sy} C ${sc1x} ${sc1y}, ${sc2x} ${sc2y}, ${ex} ${ey}`;
        }
        
        // ============================================
        // DRAG HANDLERS
        // ============================================
        
        
        function dragStarted(event, d) {
            // Check if Shift is held - duplicate the series string
            const shiftKey = event.sourceEvent ? event.sourceEvent.shiftKey : false;
            
            if (shiftKey && (d.type === 'panel' || d.type === 'battery')) {
                // Prevent default drag behavior
                if (event.sourceEvent) event.sourceEvent.stopPropagation();
                duplicateSeriesString(d, event);
                // Don't proceed with normal drag
                d._duplicating = true;
                return;
            }
            
            d._duplicating = false;
            d3.select(this).raise();
            dragOffset.x = event.x - d.x;
            dragOffset.y = event.y - d.y;
        }
        
        function dragged(event, d) {
            if (d._duplicating) return;
            d.x = event.x - dragOffset.x;
            d.y = event.y - dragOffset.y;
            d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
            renderWires();
        }
        
        function dragEnded(event, d) {
            if (d._duplicating && pendingDuplication) {
                const itemType = pendingDuplication.itemType;
                completeDuplication(event.x, event.y);
                // Show simple hint - the full feedback will trigger when circuit is complete
                if (itemType === 'panel') {
                    showHint("ðŸ“‹ String Created!", 
                        `Connect both strings' + terminals to PV+ and - terminals to PV- to complete the parallel circuit.`);
                } else if (itemType === 'battery') {
                    showHint("ðŸ“‹ Battery String Created!", 
                        `Connect both strings' + terminals to BATT+ and - terminals to BATT- to complete the parallel circuit.`);
                }
            }
            d._duplicating = false;
        }
        
        function showParallelStringFeedback() {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) {
                showHint("ðŸ“‹ String Duplicated!", 
                    `Created a parallel string. Connect both strings' + terminals to PV+ and - terminals to PV- for parallel operation.`);
                return;
            }
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            const maxWattsAtBattery = getMaxWattsForController(controller, batterySpecs.voltage || 12);
            
            // Check if current exceeds controller limit
            if (arraySpecs.imp > controller.specs.maxIsc && areHintsEnabled()) {
                // Yellow warning for current clipping
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #f0ad4e;">âš¡ Current Clipping</h3>
                            <p style="margin: 0 0 8px 0;">
                                Your array's maximum current (<strong>${arraySpecs.imp.toFixed(1)}A</strong>) exceeds the controller's input limit (<strong>${controller.specs.maxIsc}A</strong>).
                            </p>
                            <p style="margin: 0; color: #aaa; font-size: 12px;">
                                This won't damage your controller, but it causes "clipping" - reducing the array's maximum output to the controller's limit. You're leaving some power on the table!
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(240, 173, 78, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                            <div style="font-size: 18px; font-weight: bold; color: #f0ad4e;">${arraySpecs.wmp}W</div>
                            <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.imp.toFixed(1)}A Imp</div>
                            <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                                <div style="font-size: 10px; color: #aaa;">CTRL MAX</div>
                                <div style="font-size: 14px; color: #f0ad4e;">${controller.specs.maxIsc}A</div>
                            </div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
            } else if (areHintsEnabled()) {
                // Positive feedback - show how much more they can add
                const remainingCurrent = controller.specs.maxIsc - arraySpecs.imp;
                const potentialExtraWatts = Math.round(remainingCurrent * (arraySpecs.voc / arraySpecs.panelCount || 37.5));
                
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #5cb85c;">ðŸ“‹ Nice, ${arraySpecs.wmp}W!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Parallel string added! Connect both strings' + terminals to PV+ and - terminals to PV-.
                            </p>
                            <p style="margin: 0; color: #aaa; font-size: 12px;">
                                Your controller can handle up to <strong style="color: #5cb85c;">${maxWattsAtBattery}W</strong> at your current battery voltage. 
                                ${arraySpecs.wmp < maxWattsAtBattery ? `You have room for ~${Math.round(maxWattsAtBattery - arraySpecs.wmp)}W more!` : 'You\'re at the limit!'}
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                            <div style="font-size: 18px; font-weight: bold; color: #5cb85c;">${arraySpecs.wmp}W</div>
                            <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.config || '-'}</div>
                            <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                                <div style="font-size: 10px; color: #aaa;">MAX @ ${batterySpecs.voltage || 12}V</div>
                                <div style="font-size: 14px; color: #5cb85c;">${maxWattsAtBattery}W</div>
                            </div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
            }
        }
        
        // Store pending duplication info
        let pendingDuplication = null;
        
        function duplicateSeriesString(startItem, event) {
            // Find all items of the same type in this series string
            const itemType = startItem.type;
            const stringItems = [];
            const visited = new Set();
            
            function traceString(item) {
                if (visited.has(item.id)) return;
                visited.add(item.id);
                stringItems.push(item);
                
                // Check both handles for connected items of the same type
                Object.values(item.handles).forEach(handle => {
                    handle.connectedTo.forEach(conn => {
                        const connectedItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedItem && connectedItem.type === itemType && !visited.has(connectedItem.id)) {
                            traceString(connectedItem);
                        }
                    });
                });
            }
            
            traceString(startItem);
            
            if (stringItems.length === 0) return;
            
            // Sort items by position to maintain order (by X for horizontal strings, then Y)
            stringItems.sort((a, b) => a.x - b.x || a.y - b.y);
            
            // Store for use in drag end
            pendingDuplication = {
                stringItems,
                itemType,
                startX: event.x,
                startY: event.y
            };
        }
        
        function completeDuplication(endX, endY) {
            if (!pendingDuplication) return;
            
            const { stringItems, itemType, startX, startY } = pendingDuplication;
            pendingDuplication = null;
            
            // Calculate string bounds
            const minX = Math.min(...stringItems.map(p => p.x));
            const maxX = Math.max(...stringItems.map(p => p.x + p.width));
            const minY = Math.min(...stringItems.map(p => p.y));
            const maxY = Math.max(...stringItems.map(p => p.y + p.height));
            const stringWidth = maxX - minX;
            const stringHeight = maxY - minY;
            
            // Determine offset based on drag direction
            const dragDeltaX = endX - startX;
            const dragDeltaY = endY - startY;
            
            let offsetX, offsetY;
            
            // If dragged more horizontally, place to the side
            if (Math.abs(dragDeltaX) > Math.abs(dragDeltaY)) {
                offsetX = dragDeltaX > 0 ? stringWidth + 30 : -(stringWidth + 30);
                offsetY = 0;
            } else {
                // If dragged more vertically, place above or below
                offsetX = 0;
                offsetY = dragDeltaY > 0 ? stringHeight + 30 : -(stringHeight + 30);
            }
            
            // Create new items
            const newItems = [];
            const itemIdMap = new Map();
            
            stringItems.forEach(oldItem => {
                let newItem;
                if (itemType === 'panel') {
                    newItem = createPanel(
                        oldItem.x + offsetX,
                        oldItem.y + offsetY,
                        oldItem.specs
                    );
                } else if (itemType === 'battery') {
                    newItem = createBattery(
                        oldItem.x + offsetX,
                        oldItem.y + offsetY,
                        oldItem.specs
                    );
                }
                if (newItem) {
                    newItems.push(newItem);
                    itemIdMap.set(oldItem.id, newItem);
                    allItems.push(newItem);
                }
            });
            
            // Recreate connections between new items (series connections)
            const createdConnections = new Set();
            
            stringItems.forEach(oldItem => {
                Object.values(oldItem.handles).forEach(handle => {
                    handle.connectedTo.forEach(conn => {
                        const connectedOldItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedOldItem && connectedOldItem.type === itemType && itemIdMap.has(connectedOldItem.id)) {
                            const newSourceItem = itemIdMap.get(oldItem.id);
                            const newTargetItem = itemIdMap.get(connectedOldItem.id);
                            
                            // Create a unique key for this connection pair
                            const connKey = [newSourceItem.id, newTargetItem.id].sort().join('-');
                            if (createdConnections.has(connKey)) return;
                            createdConnections.add(connKey);
                            
                            // Find matching handles by polarity
                            const sourceHandle = Object.values(newSourceItem.handles).find(h => h.polarity === handle.polarity);
                            const connectedOldHandle = Object.values(connectedOldItem.handles).find(h => h.id === conn.handleId);
                            const targetHandle = Object.values(newTargetItem.handles).find(h => h.polarity === connectedOldHandle.polarity);
                            
                            if (sourceHandle && targetHandle) {
                                createConnection(newSourceItem, sourceHandle, newTargetItem, targetHandle);
                            }
                        }
                    });
                });
            });
            
            render();
        }
        
        function handleDragStart(event, item, handle) {
            event.sourceEvent.stopPropagation();
            
            // Store reference to the CURRENT item from allItems (not a stale copy)
            const currentItem = allItems.find(i => i.id === item.id);
            const currentHandle = currentItem ? Object.values(currentItem.handles).find(h => h.id === handle.id) : handle;
            
            draggingHandle = { 
                itemId: item.id,  // Store ID instead of object reference
                handleId: handle.id,
                item: currentItem || item,
                handle: currentHandle || handle
            };
            
            const pos = getHandlePosition(draggingHandle.item, draggingHandle.handle);
            
            tempWire = tempGroup.append("path")
                .attr("class", "wire temp")
                .attr("d", `M ${pos.x} ${pos.y} L ${pos.x} ${pos.y}`);
        }
        
        function handleDragMove(event) {
            if (!draggingHandle || !tempWire) return;
            
            // Get fresh reference to item (in case it moved)
            const item = allItems.find(i => i.id === draggingHandle.itemId) || draggingHandle.item;
            const handle = Object.values(item.handles).find(h => h.id === draggingHandle.handleId) || draggingHandle.handle;
            
            const [mouseX, mouseY] = d3.pointer(event, zoomGroup.node());
            const start = getHandlePosition(item, handle);
            
            // Determine target side based on mouse position relative to start
            let targetSide = 'top';
            if (mouseY > start.y + 20) targetSide = 'top';      // Mouse is below, so target handle is on top
            else if (mouseY < start.y - 20) targetSide = 'bottom'; // Mouse is above, so target handle is on bottom
            else if (mouseX > start.x) targetSide = 'left';
            else targetSide = 'right';
            
            const path = generateCurvePath(start.x, start.y, mouseX, mouseY, handle.side, targetSide);
            tempWire.attr("d", path);
        }
        
        function handleDragEnd(event) {
            if (tempWire) tempWire.remove();
            tempWire = null;
            
            if (!draggingHandle) return;
            
            const [x, y] = d3.pointer(event, zoomGroup.node());
            
            // Get fresh reference to source item
            const sourceItem = allItems.find(i => i.id === draggingHandle.itemId) || draggingHandle.item;
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === draggingHandle.handleId) || draggingHandle.handle;
            
            // Find target handle - closest one within range
            let targetItem = null;
            let targetHandle = null;
            let closestDist = HANDLE_RADIUS * 3;
            
            for (const item of allItems) {
                if (item.id === sourceItem.id) continue;
                
                for (const handle of Object.values(item.handles)) {
                    const pos = getHandlePosition(item, handle);
                    const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                    
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetItem = item;
                        targetHandle = handle;
                    }
                }
            }
            
            if (targetHandle) {
                createConnection(sourceItem, sourceHandle, targetItem, targetHandle);
            } else {
                // No target found - create a new component if dragging from appropriate handle
                
                // Smart battery port drag - create new smart battery expansion
                if (sourceHandle.polarity === 'smart-battery') {
                    // Check if we're dragging from a controller's smart battery port
                    if (sourceItem.type === 'controller' && sourceItem.specs.smartBatteryKWh) {
                        const newX = x - SMART_BATTERY_WIDTH / 2;
                        const newY = y - SMART_BATTERY_HEIGHT / 2;
                        const newSmartBattery = createSmartBattery(newX, newY, sourceItem.specs.smartBatteryKWh, sourceItem.id);
                        
                        allItems.push(newSmartBattery);
                        
                        // Connect to the port closer to the controller (smartPort2 is on the left)
                        createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort2);
                        
                        if (areHintsEnabled()) {
                            showHint("ðŸ”‹ Smart Battery Connected!", 
                                `Added ${sourceItem.specs.smartBatteryKWh} kWh expansion battery. Total capacity: ${(sourceItem.specs.internalBatteryKWh + sourceItem.specs.smartBatteryKWh).toFixed(1)} kWh`);
                        }
                    } else if (sourceItem.type === 'smartbattery') {
                        // Dragging from a smart battery - create another if port is free
                        const newX = x - SMART_BATTERY_WIDTH / 2;
                        const newY = y - SMART_BATTERY_HEIGHT / 2;
                        const newSmartBattery = createSmartBattery(newX, newY, sourceItem.specs.kWh, sourceItem.parentControllerId);
                        
                        allItems.push(newSmartBattery);
                        
                        // Connect smart port 1 (right) to new smart port 2 (left)
                        if (sourceHandle.id.includes('-smart-1')) {
                            createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort2);
                        } else {
                            createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort1);
                        }
                    }
                }
                // Panel or battery drag - create series component
                else if (sourceItem.type === 'panel' || sourceItem.type === 'battery') {
                    let newItem;
                    
                    if (sourceItem.type === 'panel') {
                        const newX = x - PANEL_WIDTH / 2;
                        const newY = y - PANEL_HEIGHT / 2;
                        newItem = createPanel(newX, newY, sourceItem.specs);
                    } else if (sourceItem.type === 'battery') {
                        // Keep same Y as source battery for horizontal alignment
                        const newX = x - BATTERY_WIDTH / 2;
                        const newY = sourceItem.y;
                        newItem = createBattery(newX, newY, sourceItem.specs);
                    }
                    
                    if (newItem) {
                        allItems.push(newItem);
                        
                        // Connect in series: positive -> negative, negative -> positive
                        const isPositive = sourceHandle.polarity === 'positive' || sourceHandle.polarity === 'pv-positive';
                        const newHandle = isPositive ? newItem.handles.negative : newItem.handles.positive;
                        
                        createConnection(sourceItem, sourceHandle, newItem, newHandle);
                        
                        if (sourceItem.type === 'panel') {
                            showSeriesPanelHint();
                        } else if (sourceItem.type === 'battery') {
                            showSeriesBatteryHint();
                        }
                    }
                }
                // AC output drag - create circuit (breaker + outlet)
                else if (sourceHandle.polarity === 'ac' && sourceHandle.id.includes('-ac-out')) {
                    createACCircuit(sourceItem, sourceHandle, x, y);
                }
                // Panel/Spiderbox circuit output drag - create outlet directly
                else if (sourceHandle.polarity === 'ac' && (sourceItem.type === 'breakerpanel' || sourceItem.type === 'spiderbox')) {
                    createOutletFromCircuit(sourceItem, sourceHandle, x, y);
                }
                // Outlet output drag - create another outlet (daisy chain)
                else if (sourceHandle.polarity === 'ac' && sourceItem.type === 'acoutlet' && sourceHandle.id.includes('-out')) {
                    createOutletFromCircuit(sourceItem, sourceHandle, x, y);
                }
                // Outlet load port drag - create appliance/load
                else if (sourceHandle.polarity === 'load' && sourceItem.type === 'acoutlet') {
                    createLoadFromOutlet(sourceItem, sourceHandle, x, y);
                }
            }
            
            draggingHandle = null;
        }
        
        // Create load/appliance from outlet load port
        function createLoadFromOutlet(sourceItem, sourceHandle, x, y) {
            const voltage = sourceHandle.voltage || sourceItem.specs.voltage || 120;
            
            // Find a default preset matching the voltage
            const defaultPreset = APPLIANCE_PRESETS.find(p => p.voltage === voltage) || APPLIANCE_PRESETS[0];
            const preset = { ...defaultPreset, voltage: voltage };
            
            // Create load at drag position
            const load = createACLoad(x - AC_LOAD_WIDTH / 2, y - AC_LOAD_HEIGHT / 2, preset);
            allItems.push(load);
            
            // Connect outlet load port to load cord
            createConnection(sourceItem, sourceHandle, load, load.handles.cord);
            
            if (areHintsEnabled()) {
                showHint("ðŸ”Œ Appliance Connected!", 
                    `Added ${voltage}V load. Select it to change the appliance type and wattage.`);
            }
        }
        
        // Create outlet from panel/spiderbox circuit output or daisy-chain from another outlet
        function createOutletFromCircuit(sourceItem, sourceHandle, x, y) {
            // Get voltage from the source handle
            const voltage = sourceHandle.voltage || 120;
            
            // Create outlet at drag position
            const outlet = createACOutlet(x - AC_OUTLET_WIDTH / 2, y - AC_OUTLET_HEIGHT / 2, voltage);
            allItems.push(outlet);
            
            // Connect source to outlet input
            createConnection(sourceItem, sourceHandle, outlet, outlet.handles.input);
            
            if (areHintsEnabled()) {
                const isDaisyChain = sourceItem.type === 'acoutlet';
                showHint(isDaisyChain ? "ðŸ”Œ Outlet Daisy-Chained!" : "ðŸ”Œ Outlet Connected!", 
                    `Added ${voltage}V outlet. Drag from its right port to add more outlets in series.`);
            }
        }
        
        // Create AC circuit from AC output drag
        function createACCircuit(sourceItem, sourceHandle, x, y) {
            // Determine voltage and wattage from source
            let voltage = 120;
            let maxWatts = 1800;
            
            if (sourceItem.type === 'controller') {
                maxWatts = sourceItem.specs.maxACOutputW || 1800;
            } else if (sourceItem.type === 'doublevoltagehub') {
                voltage = 240; // Hub outputs 240V
                maxWatts = sourceItem.specs.maxOutputW || 7200;
            }
            
            // Auto-size breaker
            const breakerSpecs = getAutoSizedACBreaker(maxWatts, voltage);
            
            // Create breaker at drag position
            const breaker = createACBreaker(x, y, breakerSpecs);
            allItems.push(breaker);
            
            // Create outlet to the right of breaker
            const outlet = createACOutlet(x + AC_BREAKER_WIDTH + 60, y + (AC_BREAKER_HEIGHT - AC_OUTLET_HEIGHT) / 2, voltage);
            allItems.push(outlet);
            
            // Connect source to breaker input
            createConnection(sourceItem, sourceHandle, breaker, breaker.handles.lineIn);
            
            // Connect breaker output to outlet
            createConnection(breaker, breaker.handles.loadOut, outlet, outlet.handles.input);
            
            if (areHintsEnabled()) {
                showHint("âš¡ AC Circuit Created!", 
                    `Added ${breakerSpecs.rating}A breaker and ${voltage}V outlet. Max load: ${breakerSpecs.maxWatts}W`);
            }
        }
        
        // ============================================
        // CONNECTION MANAGEMENT
        // ============================================
        
        function createConnection(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if connection already exists
            const exists = connections.some(c => 
                (c.sourceHandleId === sourceHandle.id && c.targetHandleId === targetHandle.id) ||
                (c.sourceHandleId === targetHandle.id && c.targetHandleId === sourceHandle.id)
            );
            if (exists) return;
            
            // Determine wire polarity - normalize pv-positive/pv-negative to positive/negative
            const normalizePolarity = (p) => {
                if (p === 'pv-positive') return 'positive';
                if (p === 'pv-negative') return 'negative';
                return p;
            };
            
            const srcPol = normalizePolarity(sourceHandle.polarity);
            const tgtPol = normalizePolarity(targetHandle.polarity);
            
            let polarity = 'mixed';
            if (srcPol === tgtPol) {
                polarity = srcPol; // Use normalized polarity for wire color
            }
            // Parallel connections (hub to Delta Pro)
            if (sourceHandle.polarity === 'parallel' && targetHandle.polarity === 'parallel') {
                polarity = 'parallel';
            }
            // Load connections (outlet to appliance - black cord)
            if (sourceHandle.polarity === 'load' || targetHandle.polarity === 'load') {
                polarity = 'load';
            }
            
            // Create connection object first (temporarily for calculations)
            const tempConn = {
                id: `conn-${++connectionIdCounter}`,
                sourceItemId: sourceItem.id,
                sourceHandleId: sourceHandle.id,
                targetItemId: targetItem.id,
                targetHandleId: targetHandle.id,
                polarity
            };
            
            // Calculate initial wire properties
            const initialCurrent = calculateWireCurrent(tempConn);
            const wireSpec = getWireGaugeForAmps(initialCurrent);
            const estimatedLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
            const costPerFoot = WIRE_COST_PER_FOOT[wireSpec.gauge] || WIRE_COST_PER_FOOT['10'];
            const totalWireCost = estimatedLength * costPerFoot;
            
            // Add wire properties to connection
            const conn = {
                ...tempConn,
                // Wire properties
                wireGauge: wireSpec.gauge,
                wireAmps: initialCurrent,
                estimatedLength: estimatedLength,
                costPerFoot: costPerFoot,
                totalWireCost: totalWireCost
            };
            
            connections.push(conn);
            sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
            targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
            
            // If in live view mode, recalculate power flow to update wire glow immediately
            if (liveViewActive && LiveView.state.active) {
                LiveView.PowerFlow.calculate();
            }
            
            render();
            checkTutorialProgress();
            validateSystem();
        }
        
        function deleteItem(itemId) {
            const item = allItems.find(i => i.id === itemId);
            if (!item) return;
            
            // Delete all connections involving this item
            const connToDelete = connections.filter(c => c.sourceItemId === itemId || c.targetItemId === itemId);
            connToDelete.forEach(c => deleteConnection(c.id));
            
            // Remove the item
            allItems = allItems.filter(i => i.id !== itemId);
            
            if (selectedItem && selectedItem.id === itemId) {
                selectedItem = null;
                closeInspector();
            }
            
            render();
            validateSystem();
        }
        
        function deleteConnection(connId) {
            const conn = connections.find(c => c.id === connId);
            if (!conn) return;
            
            // Remove from handles
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            
            if (sourceItem) {
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle) {
                    sourceHandle.connectedTo = sourceHandle.connectedTo.filter(c => c.connectionId !== connId);
                }
            }
            
            if (targetItem) {
                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                if (targetHandle) {
                    targetHandle.connectedTo = targetHandle.connectedTo.filter(c => c.connectionId !== connId);
                }
            }
            
            connections = connections.filter(c => c.id !== connId);
            selectedConnection = null;
            
            // If in live view mode, update power flow and turn off disconnected loads
            if (LiveView.state.active) {
                // Clear power flow for deleted connection
                if (LiveView.state.powerFlow[connId]) {
                    delete LiveView.state.powerFlow[connId];
                }
                
                // Recalculate power flow immediately
                LiveView.PowerFlow.calculate();
                
                // Turn off any loads that are now disconnected from their circuits
                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                    if (LiveView.state.loadStates[loadId]) {
                        const load = allItems.find(i => i.id === loadId);
                        if (load && load.type === 'acload') {
                            const circuitStatus = checkLoadCircuitStatus(load);
                            if (!circuitStatus.isLive) {
                                LiveView.state.loadStates[loadId] = false;
                            }
                        }
                    }
                });
            }
            
            render();
            validateSystem();
        }
        
        // ============================================
        // SELECTION
        // ============================================
        
        function selectItem(item) {
            selectedItem = item;
            selectedConnection = null;
            openInspector(item);
            render();
        }
        
        function selectConnection(conn) {
            selectedConnection = conn;
            selectedItem = null;
            openWireInspector(conn);
            render();
        }
        
        function deselectAll() {
            selectedItem = null;
            selectedConnection = null;
            closeInspector();
            render();
        }
        
        // ============================================
        // INSPECTOR
        // ============================================
        
        function openInspector(item) {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.add('open');
            
            // Hide all inspectors first
            document.getElementById('inspectorEmpty').classList.add('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
            
            if (item.type === 'panel') {
                document.getElementById('panelInspector').classList.remove('hidden');
                document.getElementById('panelName').value = item.specs.name || '';
                document.getElementById('panelWmp').value = item.specs.wmp;
                document.getElementById('panelVmp').value = item.specs.vmp;
                document.getElementById('panelVoc').value = item.specs.voc;
                document.getElementById('panelIsc').value = item.specs.isc;
                document.getElementById('panelCost').value = item.specs.cost;
            } else if (item.type === 'battery') {
                document.getElementById('batteryInspector').classList.remove('hidden');
                document.getElementById('batteryName').value = item.specs.name || '';
                document.getElementById('batteryVoltage').value = item.specs.voltage;
                document.getElementById('batteryAh').value = item.specs.ah;
                document.getElementById('batteryMaxDischarge').value = item.specs.maxDischarge;
                document.getElementById('batteryCost').value = item.specs.cost;
            } else if (item.type === 'controller') {
                document.getElementById('controllerInspector').classList.remove('hidden');
                document.getElementById('controllerName').value = item.specs.name || '';
                document.getElementById('controllerType').value = item.specs.type || 'charge_controller';
                document.getElementById('controllerMaxVoc').value = item.specs.maxVoc;
                document.getElementById('controllerMinVmp').value = item.specs.minVmp || 0;
                document.getElementById('controllerMppMin').value = item.specs.mppVoltageMin || 0;
                document.getElementById('controllerMppMax').value = item.specs.mppVoltageMax || item.specs.maxVoc;
                document.getElementById('controllerMaxIsc').value = item.specs.maxIsc;
                document.getElementById('controllerMaxWmp').value = item.specs.maxWmp;
                document.getElementById('controllerChargeCurrent').value = item.specs.ratedChargeCurrent;
                document.getElementById('controllerCost').value = item.specs.cost;
                
                // Show/hide AC output field based on type
                const isHybrid = item.specs.type === 'hybrid_inverter' || item.specs.type === 'all_in_one';
                document.getElementById('controllerACOutput').classList.toggle('hidden', !isHybrid);
                document.getElementById('controllerACOutputW').value = item.specs.maxACOutputW || 0;
                
                // Set voltage checkboxes
                const supportedVoltages = item.specs.supportedVoltages || [12, 24, 48];
                document.getElementById('controllerV12').checked = supportedVoltages.includes(12);
                document.getElementById('controllerV24').checked = supportedVoltages.includes(24);
                document.getElementById('controllerV36').checked = supportedVoltages.includes(36);
                document.getElementById('controllerV48').checked = supportedVoltages.includes(48);
            } else if (item.type === 'breaker') {
                document.getElementById('breakerInspector').classList.remove('hidden');
                document.getElementById('breakerRating').value = item.specs.rating;
                document.getElementById('breakerMaxVoltage').value = item.specs.maxVoltage;
                document.getElementById('breakerCost').value = item.specs.cost;
                document.getElementById('breakerStatus').textContent = item.isClosed ? 'âœ“ CLOSED (Conducting)' : 'âœ— OPEN (Tripped)';
                document.getElementById('breakerStatus').style.color = item.isClosed ? '#5cb85c' : '#d9534f';
            } else if (item.type === 'combiner') {
                document.getElementById('combinerInspector').classList.remove('hidden');
                document.getElementById('combinerInputCount').textContent = item.specs.inputs;
                document.getElementById('combinerMaxAmps').value = item.specs.maxAmpsPerInput;
                document.getElementById('combinerCost').value = item.specs.cost;
            } else if (item.type === 'solarcombiner') {
                document.getElementById('solarCombinerInspector').classList.remove('hidden');
                document.getElementById('solarCombinerInputCount').textContent = item.specs.inputs;
                document.getElementById('solarCombinerBreakerRating').value = item.specs.breakerRating;
                document.getElementById('solarCombinerMaxVoltage').value = item.specs.maxVoltage;
                document.getElementById('solarCombinerCost').value = item.specs.cost;
                
                // Populate individual breaker toggles
                const breakersDiv = document.getElementById('solarCombinerBreakers');
                breakersDiv.innerHTML = '';
                for (let i = 0; i < item.specs.inputs; i++) {
                    const isClosed = item.breakerStates[i];
                    const btn = document.createElement('button');
                    btn.textContent = `Input ${i + 1}: ${isClosed ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 5px;
                        background: ${isClosed ? '#5cb85c' : '#d9534f'}; color: white;
                        border: none; border-radius: 4px; cursor: pointer; font-size: 11px;
                    `;
                    btn.onclick = () => {
                        item.breakerStates[i] = !item.breakerStates[i];
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${item.id}-circuit-${i + 1}`;
                            // Always create/update to ensure wasTripped is cleared when manually toggling
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: item.breakerStates[i],
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                        }
                        openInspector(item); // Refresh
                        render();
                        
                        // Refresh inspector if a load is currently selected (to update circuit status)
                        if (selectedItem && selectedItem.type === 'acload') {
                            openInspector(selectedItem);
                        }
                    };
                    breakersDiv.appendChild(btn);
                }
            } else if (item.type === 'spiderbox') {
                document.getElementById('spiderboxInspector').classList.remove('hidden');
                document.getElementById('spiderboxMaxPower').textContent = item.specs.maxInputWatts.toLocaleString() + 'W';
                document.getElementById('spiderboxCost').value = item.specs.cost;
                
                // Populate circuit breaker toggles
                const breakersDiv = document.getElementById('spiderboxBreakers');
                breakersDiv.innerHTML = '';
                item.specs.circuits.forEach((circuit, i) => {
                    const handle = item.handles[`circuit${i + 1}`];
                    const isClosed = handle.isClosed !== false;
                    const btn = document.createElement('button');
                    btn.textContent = `${circuit.name} (${circuit.amps}A): ${isClosed ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 6px;
                        background: ${isClosed ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444'}; 
                        color: ${isClosed ? '#000' : '#888'};
                        border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;
                    `;
                    btn.onclick = () => {
                        handle.isClosed = !handle.isClosed;
                        openInspector(item);
                        render();
                    };
                    breakersDiv.appendChild(btn);
                });
            } else if (item.type === 'breakerpanel') {
                document.getElementById('breakerpanelInspector').classList.remove('hidden');
                document.getElementById('panelMaxPower').textContent = item.specs.maxInputWatts.toLocaleString() + 'W';
                const costInput = document.getElementById('breakerpanelCost');
                costInput.value = item.specs.cost;
                // Apply cost changes immediately
                costInput.oninput = () => {
                    item.specs.cost = parseFloat(costInput.value) || 0;
                };
                
                // Main breaker toggle
                const mainOn = item.mainBreakerOn !== false;
                const breakersDiv = document.getElementById('breakerpanelBreakers');
                breakersDiv.innerHTML = '';
                
                // Add main breaker first
                const mainBtn = document.createElement('button');
                mainBtn.textContent = `âš¡ MAIN BREAKER (100A): ${mainOn ? 'ON' : 'OFF'}`;
                mainBtn.style.cssText = `
                    display: block; width: 100%; margin: 3px 0; padding: 8px;
                    background: ${mainOn ? '#8b0000' : '#333'}; 
                    color: ${mainOn ? '#fff' : '#888'};
                    border: 2px solid ${mainOn ? '#d9534f' : '#555'}; border-radius: 4px; 
                    cursor: pointer; font-size: 12px; font-weight: bold;
                `;
                mainBtn.onclick = () => {
                    const wasOn = item.mainBreakerOn !== false;
                    item.mainBreakerOn = !item.mainBreakerOn;
                    const isNowOn = item.mainBreakerOn !== false;
                    
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (wasOn && !isNowOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    
                    if (LiveView.state.active) {
                        LiveView.PowerFlow.calculate();
                    }
                    
                    openInspector(item);
                    render();
                    
                    // Refresh inspector if a load is currently selected (to update circuit status)
                    if (selectedItem && selectedItem.type === 'acload') {
                        openInspector(selectedItem);
                    }
                };
                breakersDiv.appendChild(mainBtn);
                
                // Divider
                const divider = document.createElement('div');
                divider.style.cssText = 'height: 1px; background: #555; margin: 8px 0;';
                breakersDiv.appendChild(divider);
                
                // Populate circuit breaker toggles
                item.specs.circuits.forEach((circuit, i) => {
                    const isClosed = item.breakerStates[i] && mainOn;
                    const breakerOn = item.breakerStates[i];
                    const btn = document.createElement('button');
                    btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${breakerOn ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 6px;
                        background: ${isClosed ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444'}; 
                        color: ${isClosed ? '#000' : '#888'};
                        border: none; border-radius: 4px; cursor: ${mainOn ? 'pointer' : 'not-allowed'}; 
                        font-size: 11px; font-weight: bold;
                        opacity: ${mainOn ? 1 : 0.5};
                    `;
                    btn.onclick = () => {
                        if (mainOn) {
                            const wasOn = item.breakerStates[i] !== false;
                            item.breakerStates[i] = !item.breakerStates[i];
                            const isNowOn = item.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${item.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: item.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                                
                                // Immediately recalculate power flow and re-render
                                LiveView.PowerFlow.calculate();
                            }
                            
                            openInspector(item); // Refresh to show updated state
                            render();
                            
                            // Refresh inspector if a load is currently selected (to update circuit status)
                            if (selectedItem && selectedItem.type === 'acload') {
                                openInspector(selectedItem);
                            }
                        }
                    };
                    breakersDiv.appendChild(btn);
                });
            } else if (item.type === 'acload') {
                document.getElementById('acloadInspector').classList.remove('hidden');
                
                // Show/hide live view toggle section
                const toggleSection = document.getElementById('loadToggleSection');
                if (liveViewActive) {
                    toggleSection.classList.remove('hidden');
                    const isOn = LiveView.state.loadStates[item.id] === true;
                    const toggleBtn = document.getElementById('loadToggleBtn');
                    const statusText = document.getElementById('loadStatusText');
                    
                    toggleBtn.textContent = isOn ? 'ON' : 'OFF';
                    toggleBtn.style.background = isOn ? '#5cb85c' : '#d9534f';
                    toggleBtn.style.color = '#fff';
                    
                    // Check circuit status
                    const circuitStatus = checkLoadCircuitStatus(item);
                    if (!circuitStatus.isLive && isOn) {
                        // Load is on but circuit is dead
                        statusText.textContent = circuitStatus.message;
                        statusText.style.color = '#d9534f';
                    } else if (isOn) {
                        const loadWatts = getLoadWatts(item);
                        statusText.textContent = `Drawing ${loadWatts}W`;
                        statusText.style.color = '#5cb85c';
                    } else {
                        if (!circuitStatus.isLive) {
                            statusText.textContent = circuitStatus.message;
                            statusText.style.color = '#d9534f';
                        } else {
                            statusText.textContent = 'Load is off';
                            statusText.style.color = '#888';
                        }
                    }
                    
                    // Update toggle button handler
                    toggleBtn.onclick = () => {
                        toggleLoad(item);
                        openInspector(item); // Refresh inspector
                    };
                } else {
                    toggleSection.classList.add('hidden');
                }
                
                // Populate preset dropdown
                const presetSelect = document.getElementById('loadPreset');
                presetSelect.innerHTML = APPLIANCE_PRESETS.map((p, i) => 
                    `<option value="${i}" ${p.name === item.specs.name ? 'selected' : ''}>${p.icon} ${p.name} (${p.voltage}V, ${p.avgWatts || 0}W)</option>`
                ).join('');
                
                document.getElementById('loadName').value = item.specs.name;
                document.getElementById('loadVoltage').value = item.specs.voltage;
                document.getElementById('loadMaxWatts').value = item.specs.maxWatts;
                document.getElementById('loadIcon').value = item.specs.icon || 'âš¡';
                
                // Behavior section
                const behavior = item.specs.behavior || { type: 'constant' };
                document.getElementById('loadBehaviorType').value = behavior.type;
                
                // Hide all behavior sections, show the active one
                document.querySelectorAll('.behavior-section').forEach(el => el.classList.add('hidden'));
                
                if (behavior.type === 'constant') {
                    document.getElementById('behaviorConstant').classList.remove('hidden');
                    document.getElementById('loadAvgWatts').value = item.specs.avgWatts || 0;
                } else if (behavior.type === 'scheduled') {
                    document.getElementById('behaviorScheduled').classList.remove('hidden');
                    document.getElementById('scheduleOn').value = behavior.schedule?.onTrigger || 'sunset';
                    document.getElementById('scheduleOff').value = behavior.schedule?.offTrigger || 'sunrise';
                } else if (behavior.type === 'batch') {
                    document.getElementById('behaviorBatch').classList.remove('hidden');
                    populateRecipeList(item);
                } else if (behavior.type === 'thermostat') {
                    document.getElementById('behaviorThermostat').classList.remove('hidden');
                    document.getElementById('thermostatSetpoint').value = behavior.setpoint || 72;
                    document.getElementById('thermostatDeadband').value = behavior.deadband || 2;
                    document.getElementById('thermostatDuty').value = behavior.dutyPercent || 50;
                } else if (behavior.type === 'charging') {
                    document.getElementById('behaviorCharging').classList.remove('hidden');
                    document.getElementById('chargingBatteryKwh').value = behavior.batteryKwh || 0;
                    document.getElementById('chargingRateKw').value = behavior.chargeRateKw || 0;
                    document.getElementById('chargingDailyUse').value = behavior.dailyDepletionKwh || 0;
                }
            }
        }
        
        // Helper function to populate recipe list in inspector
        function populateRecipeList(item) {
            const recipeList = document.getElementById('recipeList');
            const recipes = item.specs.behavior?.recipes || [];
            
            let html = '';
            let totalDailyWh = 0;
            
            recipes.forEach((recipe, i) => {
                const dailyWh = recipe.energyWh * recipe.batchesPerDay;
                totalDailyWh += dailyWh;
                html += `
                    <div class="recipe-item" style="padding: 6px; margin-bottom: 4px; background: #252525; border-radius: 3px; font-size: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: #f0ad4e;">${recipe.name}</strong>
                            <button class="remove-recipe-btn" data-index="${i}" style="background: #d9534f; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">Ã—</button>
                        </div>
                        <div style="color: #888; margin-top: 3px;">${recipe.inputs} â†’ ${recipe.outputs}</div>
                        <div style="display: flex; gap: 8px; margin-top: 3px; color: #aaa;">
                            <span>${recipe.energyWh}Wh</span>
                            <span>${recipe.durationMin}min</span>
                            <span>${recipe.batchesPerDay}/day</span>
                        </div>
                        <div style="color: #5cb85c; margin-top: 2px;">${dailyWh.toFixed(0)}Wh/day</div>
                    </div>
                `;
            });
            
            if (recipes.length === 0) {
                html = '<p style="color: #666; font-size: 10px; text-align: center; padding: 10px;">No recipes defined</p>';
            }
            
            recipeList.innerHTML = html;
            document.getElementById('dailyEnergyTotal').textContent = `Total: ${totalDailyWh.toFixed(0)} Wh/day (${(totalDailyWh/1000).toFixed(2)} kWh/day)`;
            
            // Attach remove handlers
            recipeList.querySelectorAll('.remove-recipe-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    item.specs.behavior.recipes.splice(idx, 1);
                    populateRecipeList(item);
                    render();
                };
            });
        }
        
        function openWireInspector(conn) {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.add('open');
            
            // Hide all inspectors
            document.getElementById('inspectorEmpty').classList.add('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.remove('hidden');
            
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            
            document.getElementById('wireInfo').textContent = 
                `${sourceItem?.type || 'Unknown'} â†’ ${targetItem?.type || 'Unknown'} (${conn.polarity})`;
            
            // Calculate expected current for this wire
            const expectedCurrent = calculateWireCurrent(conn);
            const recommendedBreaker = autosizeBreaker(expectedCurrent);
            document.getElementById('wireCurrentInfo').textContent = 
                expectedCurrent > 0 ? `Expected current: ~${expectedCurrent.toFixed(1)}A | Recommended breaker: ${recommendedBreaker}A` : '';
            
            // Initialize wire properties if they don't exist (for old connections)
            if (!conn.wireGauge) {
                updateWireGaugeForConnection(conn);
            }
            
            // Update wire gauge display
            const wireSpec = WIRE_GAUGE_SPECS[conn.wireGauge] || WIRE_GAUGE_SPECS['10'];
            document.getElementById('wireGaugeDisplay').value = wireSpec.name;
            document.getElementById('wireAmpsDisplay').value = `${conn.wireAmps?.toFixed(1) || '0.0'} A`;
            
            // Set length input
            const lengthInput = document.getElementById('wireLengthInput');
            lengthInput.value = conn.estimatedLength || 10;
            
            // Set cost per foot input
            const costPerFootInput = document.getElementById('wireCostPerFootInput');
            costPerFootInput.value = conn.costPerFoot || WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
            
            // Calculate and display total cost
            updateWireCostDisplay(conn);
            
            // Store current connection for event handlers
            if (!window.currentWireInspectorConn) {
                window.currentWireInspectorConn = null;
            }
            window.currentWireInspectorConn = conn;
            
            // Remove existing event listeners (if any) and add new ones
            const lengthInputNew = document.getElementById('wireLengthInput');
            const costPerFootInputNew = document.getElementById('wireCostPerFootInput');
            const recalcBtn = document.getElementById('recalculateWireLength');
            
            // Clone and replace to remove old listeners
            const newLengthInput = lengthInputNew.cloneNode(true);
            const newCostInput = costPerFootInputNew.cloneNode(true);
            const newRecalcBtn = recalcBtn.cloneNode(true);
            
            lengthInputNew.parentNode.replaceChild(newLengthInput, lengthInputNew);
            costPerFootInputNew.parentNode.replaceChild(newCostInput, costPerFootInputNew);
            recalcBtn.parentNode.replaceChild(newRecalcBtn, recalcBtn);
            
            // Set values again
            newLengthInput.value = conn.estimatedLength || 10;
            newCostInput.value = conn.costPerFoot || WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
            
            // Add event listeners
            newLengthInput.addEventListener('change', function() {
                const length = parseFloat(this.value) || 0;
                conn.estimatedLength = Math.max(0, length);
                updateWireCostDisplay(conn);
                render();
            });
            
            newCostInput.addEventListener('change', function() {
                const cost = parseFloat(this.value) || 0;
                conn.costPerFoot = Math.max(0, cost);
                updateWireCostDisplay(conn);
                render();
            });
            
            newRecalcBtn.addEventListener('click', function() {
                if (sourceItem && targetItem) {
                    const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                    const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                    if (sourceHandle && targetHandle) {
                        const newLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
                        conn.estimatedLength = newLength;
                        newLengthInput.value = newLength;
                        updateWireCostDisplay(conn);
                        render();
                    }
                }
            });
        }
        
        // Update wire cost display in inspector
        function updateWireCostDisplay(conn) {
            if (!conn) return;
            const totalCost = (conn.estimatedLength || 0) * (conn.costPerFoot || 0);
            conn.totalWireCost = totalCost;
            document.getElementById('wireTotalCostDisplay').value = `$${totalCost.toFixed(2)}`;
        }
        
        function calculateWireCurrent(conn, visited = new Set()) {
            // Prevent infinite recursion
            const connKey = `${conn.sourceItemId}-${conn.sourceHandleId}`;
            if (visited.has(connKey)) return 0;
            visited.add(connKey);
            
            // Trace back to find the source panel(s) and calculate expected current
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            if (!sourceItem) return 0;
            
            // Handle panel connections
            if (sourceItem.type === 'panel') {
                // Single panel - return its Imp
                return sourceItem.specs.imp || sourceItem.specs.isc * 0.9;
            }
            
            // Handle controller connections
            if (sourceItem.type === 'controller') {
                // For PV connections, calculate array current
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && (sourceHandle.polarity === 'pv-positive' || sourceHandle.polarity === 'pv-negative')) {
                    const arraySpecs = calculateConnectedArraySpecs(sourceItem);
                    return arraySpecs.imp || 0;
                }
                // For battery connections, use controller charge current
                if (sourceHandle && (sourceHandle.polarity === 'battery-positive' || sourceHandle.polarity === 'battery-negative')) {
                    return sourceItem.specs.ratedChargeCurrent || 0;
                }
                // For AC output
                if (sourceHandle && sourceHandle.polarity === 'ac') {
                    const maxACWatts = sourceItem.specs.maxACOutputW || 0;
                    const acVoltage = 120; // Default, could be determined from connection
                    return maxACWatts / acVoltage;
                }
            }
            
            // Handle battery connections
            if (sourceItem.type === 'battery') {
                // Battery discharge current - estimate based on max discharge
                const maxDischarge = sourceItem.specs.maxDischarge || sourceItem.specs.ah || 0;
                return maxDischarge; // Amps
            }
            
            // Handle combiner connections
            if (sourceItem.type === 'combiner' || sourceItem.type === 'solarcombiner') {
                // Sum currents from all connected inputs
                let totalCurrent = 0;
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && sourceHandle.id.includes('-out-')) {
                    // Output handle - sum all input currents
                    Object.values(sourceItem.handles).forEach(handle => {
                        if (handle.inputIndex !== undefined) {
                            handle.connectedTo.forEach(inputConn => {
                                const inputItem = allItems.find(i => i.id === inputConn.itemId);
                                if (inputItem) {
                                    // Recursively calculate current from input
                                    const tempConn = {
                                        sourceItemId: inputItem.id,
                                        sourceHandleId: inputConn.handleId
                                    };
                                    totalCurrent += calculateWireCurrent(tempConn, visited);
                                }
                            });
                        }
                    });
                }
                return totalCurrent;
            }
            
            // Handle breaker connections (if closed)
            if (sourceItem.type === 'breaker' && sourceItem.isClosed) {
                // Trace through breaker to source
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && sourceHandle.id.includes('-load-')) {
                    // Load side - trace to line side
                    const lineHandle = sourceHandle.polarity === 'positive' ? 
                        sourceItem.handles.linePositive : sourceItem.handles.lineNegative;
                    if (lineHandle && lineHandle.connectedTo.length > 0) {
                        const lineConn = lineHandle.connectedTo[0];
                        const lineItem = allItems.find(i => i.id === lineConn.itemId);
                        if (lineItem) {
                            const tempConn = {
                                sourceItemId: lineItem.id,
                                sourceHandleId: lineConn.handleId
                            };
                            return calculateWireCurrent(tempConn, visited);
                        }
                    }
                }
            }
            
            // Handle outlet connections - don't trace through outlets to prevent loops
            if (sourceItem.type === 'acoutlet') {
                return 0; // Outlets don't generate current, they pass it through
            }
            
            // Default: try to trace through connection
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            if (sourceHandle && sourceHandle.connectedTo.length > 0) {
                // Try to get current from connected source
                const connectedItem = allItems.find(i => i.id === sourceHandle.connectedTo[0].itemId);
                if (connectedItem && connectedItem.type !== 'acoutlet') { // Skip outlets to prevent loops
                    const tempConn = {
                        sourceItemId: connectedItem.id,
                        sourceHandleId: sourceHandle.connectedTo[0].handleId
                    };
                    return calculateWireCurrent(tempConn, visited);
                }
            }
            
            return 0;
        }
        
        // Estimate wire length in feet based on component positions
        function estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle) {
            if (!sourceItem || !targetItem || !sourceHandle || !targetHandle) {
                return 10; // Default fallback
            }
            
            // Get handle positions
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            // Calculate Euclidean distance
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const straightDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Convert pixels to feet (assuming 1 pixel â‰ˆ 0.1 feet, adjust as needed)
            // This is a rough estimate - actual scaling may vary
            const pixelsPerFoot = 10; // Adjust this based on your canvas scale
            const straightFeet = straightDistance / pixelsPerFoot;
            
            // Add routing overhead (25% for wire routing, bends, etc.)
            const routingOverhead = 1.25;
            const estimatedFeet = straightFeet * routingOverhead;
            
            // Round to 1 decimal place, minimum 1 foot
            return Math.max(1, Math.round(estimatedFeet * 10) / 10);
        }
        
        // Update wire gauge for a connection based on current system specs
        function updateWireGaugeForConnection(conn) {
            if (!conn) return;
            
            // Calculate current operating amperage
            const currentAmps = calculateWireCurrent(conn);
            
            // Get appropriate wire gauge
            const wireSpec = getWireGaugeForAmps(currentAmps);
            
            // Update connection properties
            conn.wireAmps = currentAmps;
            conn.wireGauge = wireSpec.gauge;
            
            // Update cost if costPerFoot exists, otherwise use default
            if (!conn.costPerFoot) {
                conn.costPerFoot = WIRE_COST_PER_FOOT[wireSpec.gauge] || WIRE_COST_PER_FOOT['10'];
            }
            
            // Recalculate total wire cost
            if (conn.estimatedLength) {
                conn.totalWireCost = conn.estimatedLength * conn.costPerFoot;
            }
        }
        
        // Update all wire gauges when system specs change
        function updateAllWireGauges() {
            connections.forEach(conn => {
                updateWireGaugeForConnection(conn);
            });
        }
        
        function closeInspector() {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.remove('open');
            
            document.getElementById('inspectorEmpty').classList.remove('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
        }
        
        // ============================================
        // VALIDATION & SCORING
        // ============================================
        
        let systemValidated = false;
        
        function validateSystem() {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Calculate array specs using connection tracing
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            
            // Update wire gauges based on current system specs
            updateAllWireGauges();
            
            // Check if system is operational
            const pvConnected = controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                               controller.handles?.pvNegative?.connectedTo?.length > 0;
            const battConnected = controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                                 controller.handles?.batteryNegative?.connectedTo?.length > 0;
            
            // Update controller visual state
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            if (pvConnected && battConnected && arraySpecs.wmp > 0 && batterySpecs.kWh > 0) {
                const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
                const maxSupportedVoltage = Math.max(...supportedVoltages);
                const nominalBatteryVoltage = Math.round(batterySpecs.voltage / 12) * 12;
                
                // Check for battery overvoltage (60V+)
                if (batterySpecs.voltage > maxSupportedVoltage + 10) {
                    controllerGroup.classed('operational', false).classed('error', true);
                    
                    if (!controller.batteryOvervoltage) {
                        controller.batteryOvervoltage = true;
                        triggerBatteryOvervoltageEffect(controller, batterySpecs.voltage, maxSupportedVoltage);
                    }
                }
                // Check for incompatible battery voltage (e.g., 36V on 12/24/48V controller)
                else if (!supportedVoltages.includes(nominalBatteryVoltage) && batterySpecs.voltage > 12) {
                    controller.batteryOvervoltage = false;
                    controllerGroup.classed('operational', false).classed('error', false);
                    
                    if (!controller.incompatibleVoltageShown) {
                        controller.incompatibleVoltageShown = true;
                        showHint("âš ï¸ Incompatible Battery Voltage", 
                            `This controller isn't compatible with ${nominalBatteryVoltage}V battery configurations. ` +
                            `Supported voltages: ${supportedVoltages.join('V, ')}V. Try adding or removing batteries to reach a compatible voltage.`);
                    }
                }
                // Check for solar voltage overload
                else if (arraySpecs.voc > controller.specs.maxVoc) {
                    controller.batteryOvervoltage = false;
                    controller.incompatibleVoltageShown = false;
                    controllerGroup.classed('operational', false).classed('error', true);
                    
                    // DESTRUCTION EFFECT - only trigger once
                    if (!controller.destroyed) {
                        controller.destroyed = true;
                        triggerOverloadEffect(controller, arraySpecs.voc, controller.specs.maxVoc);
                    }
                } else if (arraySpecs.imp > controller.specs.maxIsc) {
                    // Check for current overload (use Imp for actual operating current)
                    controller.destroyed = false;
                    controllerGroup.classed('operational', true).classed('error', false);
                    
                    if (!controller.currentClippingShown) {
                        controller.currentClippingShown = true;
                        
                        // Calculate clipped output: Array Vmp Ã— Controller max Isc
                        const clippedOutputW = Math.round(arraySpecs.vmp * controller.specs.maxIsc);
                        const lostPowerW = arraySpecs.wmp - clippedOutputW;
                        const lostPercent = ((lostPowerW / arraySpecs.wmp) * 100).toFixed(0);
                        const controllerMaxW = controller.specs.maxWmp || (controller.specs.maxIsc * controller.specs.maxVoc);
                        
                        // Calculate how many more panels in series would help
                        const currentVmp = arraySpecs.vmp;
                        const targetVmp = (arraySpecs.wmp / controller.specs.maxIsc); // Vmp needed to get full power at max current
                        const panelVmp = arraySpecs.panelCount > 0 ? currentVmp / arraySpecs.seriesCount : 30;
                        const additionalPanelsNeeded = Math.ceil((targetVmp - currentVmp) / panelVmp);
                        
                        showCurrentClippingHint(arraySpecs, controller, clippedOutputW, lostPowerW, lostPercent, additionalPanelsNeeded);
                    }
                    systemValidated = true;
                } else {
                    // System is operational and within limits
                    controller.destroyed = false;
                    controller.batteryOvervoltage = false;
                    controller.incompatibleVoltageShown = false;
                    controller.currentClippingShown = false; // Reset clipping flag when current is within limits
                    controllerGroup.classed('operational', true).classed('error', false);
                    
                    // Calculate max watts based on battery voltage
                    const maxWattsAtBatteryVoltage = getMaxWattsForController(controller, batterySpecs.voltage);
                    const maxWattsAt48V = getMaxWattsForController(controller, 48);
                    const maxWattsAt24V = getMaxWattsForController(controller, 24);
                    
                    // Check for battery voltage upgrade (24V or 48V)
                    const lastBatteryVoltage = controller.lastBatteryVoltage || 12;
                    if (nominalBatteryVoltage > lastBatteryVoltage && nominalBatteryVoltage >= 24) {
                        controller.lastBatteryVoltage = nominalBatteryVoltage;
                        showSuccessAnimation();
                        showBatteryUpgradeHint(nominalBatteryVoltage, maxWattsAtBatteryVoltage);
                    } else {
                        controller.lastBatteryVoltage = nominalBatteryVoltage;
                    }
                    
                    // Check if array is near controller's voltage limit (optimal for current battery)
                    // Only show this hint when circuit is fully connected (both PV+ and PV- connected)
                    const voltageUtilization = arraySpecs.voc / controller.specs.maxVoc;
                    const isNearVoltageLimit = voltageUtilization > 0.85 && voltageUtilization <= 1.0;
                    const canBenefitFromHigherVoltage = batterySpecs.voltage < 48 && 
                        controller.specs.supportedVoltages && 
                        controller.specs.supportedVoltages.includes(48);
                    const circuitComplete = pvConnected && battConnected;
                    
                    // Check if a new parallel string was just connected (significant wattage increase)
                    const wattageIncrease = arraySpecs.wmp - lastConnectedArrayWmp;
                    const newStringConnected = circuitComplete && wattageIncrease >= 200 && lastConnectedArrayWmp > 0;
                    
                    if (newStringConnected) {
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showSuccessAnimation();
                        showParallelStringFeedback();
                    } else if (isNearVoltageLimit && canBenefitFromHigherVoltage && !optimalArrayHintShown && arraySpecs.panelCount >= 4 && circuitComplete) {
                        optimalArrayHintShown = true;
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showSuccessAnimation();
                        showOptimalArrayHint(arraySpecs, batterySpecs, maxWattsAtBatteryVoltage, maxWattsAt48V);
                    } else if (!systemValidated && circuitComplete) {
                        systemValidated = true;
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showAchievement("ðŸŽ‰ System Operational!", {
                            arrayWmp: arraySpecs.wmp,
                            arrayVoc: arraySpecs.voc,
                            arrayIsc: arraySpecs.isc,
                            batteryKwh: batterySpecs.kWh,
                            batteryVoltage: batterySpecs.voltage,
                            maxWattsAtVoltage: maxWattsAtBatteryVoltage,
                            cost: calculateTotalCost(),
                            optimization: calculateOptimizationScore(controller, arraySpecs)
                        });
                    } else if (circuitComplete) {
                        // Update last wattage even if no hint shown
                        lastConnectedArrayWmp = arraySpecs.wmp;
                    }
                }
            } else {
                controllerGroup.classed('operational', false).classed('error', false);
            }
        }
        
        function triggerOverloadEffect(controller, actualVoltage, maxVoltage) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            // Create explosion particles
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Add spark particles
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 30 + Math.random() * 50;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 4)
                    .attr("fill", Math.random() > 0.5 ? "#ff6600" : "#ffff00")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash the screen red
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff0000")
                .style("opacity", 0.5)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake the controller
            controllerGroup
                .transition().duration(50).attr("transform", `translate(${controller.x - 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            // Show dramatic warning with helpful tips
            setTimeout(() => {
                if (!areHintsEnabled()) return;
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #d9534f;">ðŸ’¥ CONTROLLER DESTROYED!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Array voltage (${actualVoltage.toFixed(1)}V) exceeded the controller's max (${maxVoltage}V) by ${((actualVoltage/maxVoltage - 1) * 100).toFixed(0)}%!
                            </p>
                            <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                                <strong>Solutions:</strong> Remove some panels, or wire panels in parallel strings instead of one long series string.
                            </p>
                            <p style="margin: 0; color: #888; font-size: 11px;">
                                <strong>Tips:</strong> Double-click wires to delete them. Select nodes and press Delete to remove.
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(217, 83, 79, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                            <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #d9534f;">${actualVoltage.toFixed(1)}V</div>
                            <div style="font-size: 10px; color: #d9534f; margin-top: 2px;">MAX: ${maxVoltage}V</div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
                
                // Start live voltage updates
                if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
            }, 400);
        }
        
        function triggerBatteryOvervoltageEffect(controller, actualVoltage, maxVoltage) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            // Create explosion particles
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Add spark particles (blue/white for battery)
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 30 + Math.random() * 50;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 4)
                    .attr("fill", Math.random() > 0.5 ? "#00aaff" : "#ffffff")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash the screen blue
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#0066ff")
                .style("opacity", 0.5)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake the controller
            controllerGroup
                .transition().duration(50).attr("transform", `translate(${controller.x - 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            // Show warning
            setTimeout(() => {
                if (!areHintsEnabled()) return;
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #0088ff;">âš¡ BATTERY OVERVOLTAGE!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Whoa, too many volts! Your battery bank is at <strong style="color: #d9534f;">${actualVoltage.toFixed(1)}V</strong>.
                            </p>
                            <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                                <strong>${maxVoltage}V</strong> is the limit for this controller, and most common solar controllers don't work with battery voltages above 48V.
                            </p>
                            <p style="margin: 0; color: #888; font-size: 11px;">
                                Take it down a notch! Remove some batteries from the series string.
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(0, 136, 255, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BANK VOLTAGE</div>
                            <div id="liveBatteryVoltage" style="font-size: 22px; font-weight: bold; color: #d9534f;">${actualVoltage.toFixed(1)}V</div>
                            <div style="font-size: 10px; color: #0088ff; margin-top: 2px;">MAX: ${maxVoltage}V</div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
                
                // Start live battery voltage updates
                if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = setInterval(updateSeriesBatteryReadout, 200);
            }, 400);
        }
        
        function showBatteryUpgradeHint(voltage, maxWatts) {
            showSuccessAnimation();
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">ðŸ”‹ Upgraded to ${voltage}V!</h3>
                        <p style="margin: 0 0 8px 0;">
                            Nice! You've upgraded to a <strong style="color: #28a745;">${voltage}V battery bank</strong>!
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            Now you can connect up to <strong style="color: #ffdd57;">${maxWatts}W</strong> of solar panels.
                        </p>
                        <p style="margin: 0; color: #888; font-size: 11px;">
                            ${voltage < 48 ? 'Try adding more panels in series-parallel strings, or upgrade to 48V for even more capacity!' : 'This is the maximum voltage for most controllers. Now maximize your solar array!'}
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(40, 167, 69, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BATTERY</div>
                        <div style="font-size: 22px; font-weight: bold; color: #28a745;">${voltage}V</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">MAX SOLAR</div>
                            <div style="font-size: 14px; color: #ffdd57;">${maxWatts}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        function calculateConnectedArraySpecs(controller) {
            // Find all COMPLETE circuits connected to the controller
            // A complete circuit requires BOTH positive AND negative paths from panel to controller
            
            const completeStrings = [];
            
            // Helper: normalize polarity for comparison
            const normalizePolarity = (p) => {
                if (p === 'pv-positive') return 'positive';
                if (p === 'pv-negative') return 'negative';
                return p;
            };
            
            // Trace from controller to find all reachable panels, tracking the polarity path
            // targetPolarity: 'positive' or 'negative' - what panel terminal we're looking for at the END of a string
            function traceToPanels(startItem, startHandle, targetPolarity, visited = new Set(), depth = 0) {
                if (depth > 50) return [];
                const key = startItem.id + '-' + startHandle.id;
                if (visited.has(key)) return [];
                visited.add(key);
                
                const panels = [];
                
                if (startItem.type === 'panel') {
                    // We found a panel - add it
                    panels.push(startItem);
                    
                    // Also trace through series connections to find more panels
                    // If we entered via positive, check negative for series connection (and vice versa)
                    const entryPolarity = normalizePolarity(startHandle.polarity);
                    const otherHandle = entryPolarity === 'positive' ? 
                        startItem.handles.negative : startItem.handles.positive;
                    
                    // Trace through the other terminal to find series-connected panels
                    otherHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel') {
                            const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                            if (handle) {
                                // Series connection: opposite polarities connect
                                panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                            }
                        }
                    });
                    
                    return panels;
                }
                
                // For combiners, we enter via output and need to trace back through matching polarity inputs
                if (startItem.type === 'combiner' || startItem.type === 'solarcombiner') {
                    const isOutputHandle = startHandle.id.includes('-out-');
                    
                    if (isOutputHandle) {
                        // Determine which input polarity to follow based on output polarity
                        const outputPolarity = normalizePolarity(startHandle.polarity);
                        
                        Object.entries(startItem.handles).forEach(([name, h]) => {
                            if (h.inputIndex !== undefined) {
                                // Only follow inputs matching the polarity we're tracing
                                const inputPolarity = normalizePolarity(h.polarity);
                                if (inputPolarity !== outputPolarity) return;
                                
                                // For solar combiner, check breaker state
                                if (startItem.type === 'solarcombiner' && !startItem.breakerStates[h.inputIndex]) {
                                    return;
                                }
                                h.connectedTo.forEach(conn => {
                                    const item = allItems.find(i => i.id === conn.itemId);
                                    if (item) {
                                        const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                                        if (handle) {
                                            panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                                        }
                                    }
                                });
                            }
                        });
                    }
                    return panels;
                }
                
                // For breakers, trace through if closed
                if (startItem.type === 'breaker') {
                    if (!startItem.isClosed) return [];
                    
                    // Determine which side we entered from and trace to the other side
                    const handlePolarity = normalizePolarity(startHandle.polarity);
                    const isLoadSide = startHandle.id.includes('-load-');
                    const isLineSide = startHandle.id.includes('-line-');
                    
                    let targetHandle;
                    if (isLoadSide) {
                        // Entered via load, trace to line
                        targetHandle = handlePolarity === 'positive' ? 
                            startItem.handles.linePositive : startItem.handles.lineNegative;
                    } else if (isLineSide) {
                        // Entered via line, trace to load
                        targetHandle = handlePolarity === 'positive' ? 
                            startItem.handles.loadPositive : startItem.handles.loadNegative;
                    }
                    
                    if (targetHandle) {
                        targetHandle.connectedTo.forEach(conn => {
                            const item = allItems.find(i => i.id === conn.itemId);
                            if (item) {
                                const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                                if (handle) {
                                    panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                                }
                            }
                        });
                    }
                    return panels;
                }
                
                // For direct connections
                startHandle.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                        if (handle) {
                            panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                        }
                    }
                });
                
                return panels;
            }
            
            // Find panels reachable from PV+ (looking for panel positive terminals)
            const panelsFromPositive = new Set();
            if (controller.handles.pvPositive && controller.handles.pvPositive.connectedTo) {
                controller.handles.pvPositive.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const handle = Object.values(item.handles).find(h => h.id === conn.handleId);
                        if (handle) {
                            // Use a fresh visited set for each parallel connection
                            traceToPanels(item, handle, 'positive', new Set()).forEach(p => {
                                panelsFromPositive.add(p.id);
                            });
                        }
                    }
                });
            }
            
            // Find panels reachable from PV- (looking for panel negative terminals)
            const panelsFromNegative = new Set();
            if (controller.handles.pvNegative && controller.handles.pvNegative.connectedTo) {
                controller.handles.pvNegative.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const handle = Object.values(item.handles).find(h => h.id === conn.handleId);
                        if (handle) {
                            // Use a fresh visited set for each parallel connection
                            traceToPanels(item, handle, 'negative', new Set()).forEach(p => {
                                panelsFromNegative.add(p.id);
                            });
                        }
                    }
                });
            }
            
            // A panel is in a complete circuit only if reachable from BOTH positive AND negative paths
            const completePanelIds = new Set([...panelsFromPositive].filter(id => panelsFromNegative.has(id)));
            
            if (completePanelIds.size === 0) {
                return { wmp: 0, voc: 0, vmp: 0, isc: 0, imp: 0, panelCount: 0, seriesCount: 0, parallelCount: 0 };
            }
            
            // Now trace series strings, but only include panels that are in complete circuits
            const visitedPanels = new Set();
            
            function traceSeriesString(startPanel, startHandle) {
                const string = [];
                let currentPanel = startPanel;
                let currentHandle = startHandle;
                
                while (currentPanel && !visitedPanels.has(currentPanel.id)) {
                    // Only include panels that are in complete circuits
                    if (!completePanelIds.has(currentPanel.id)) break;
                    
                    visitedPanels.add(currentPanel.id);
                    string.push(currentPanel);
                    
                    const otherHandle = currentHandle.polarity === 'positive' 
                        ? currentPanel.handles.negative 
                        : currentPanel.handles.positive;
                    
                    let nextPanel = null;
                    let nextHandle = null;
                    
                    for (const conn of otherHandle.connectedTo) {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel' && !visitedPanels.has(item.id) && completePanelIds.has(item.id)) {
                            const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (connectedHandle && connectedHandle.polarity !== otherHandle.polarity) {
                                nextPanel = item;
                                nextHandle = connectedHandle;
                                break;
                            }
                        }
                    }
                    
                    currentPanel = nextPanel;
                    currentHandle = nextHandle;
                }
                
                return string;
            }
            
            // Build strings from complete panels
            // First, find "string start" panels - panels whose positive terminal is NOT connected to another panel's negative
            // These are the first panels in each series string
            const stringStartPanels = [];
            for (const panelId of completePanelIds) {
                const panel = allItems.find(i => i.id === panelId);
                if (!panel) continue;
                
                // Check if positive terminal is connected to another panel's negative terminal
                const posConnections = panel.handles.positive.connectedTo;
                const isConnectedToPanelNegative = posConnections.some(conn => {
                    const connItem = allItems.find(i => i.id === conn.itemId);
                    if (connItem && connItem.type === 'panel') {
                        const connHandle = Object.values(connItem.handles).find(h => h.id === conn.handleId);
                        return connHandle && connHandle.polarity === 'negative';
                    }
                    return false;
                });
                
                // If positive is NOT connected to another panel's negative, this is a string start
                if (!isConnectedToPanelNegative) {
                    stringStartPanels.push(panel);
                }
            }
            
            // Now trace strings starting from the identified start panels
            for (const panel of stringStartPanels) {
                if (visitedPanels.has(panel.id)) continue;
                const string = traceSeriesString(panel, panel.handles.positive);
                if (string.length > 0) {
                    completeStrings.push(string);
                }
            }
            
            if (completeStrings.length === 0) {
                return { wmp: 0, voc: 0, vmp: 0, isc: 0, imp: 0, panelCount: 0, seriesCount: 0, parallelCount: 0 };
            }
            
            const parallelCount = completeStrings.length;
            const seriesCount = Math.max(...completeStrings.map(s => s.length));
            const totalPanels = completeStrings.reduce((sum, s) => sum + s.length, 0);
            
            // For each string, calculate its voltage (sum of panel voltages in series)
            const stringVocs = completeStrings.map(s => s.reduce((sum, p) => sum + p.specs.voc, 0));
            const stringVmps = completeStrings.map(s => s.reduce((sum, p) => sum + p.specs.vmp, 0));
            
            // Array Voc is the max string Voc (parallel strings don't add voltage)
            const voc = Math.max(...stringVocs);
            const vmp = Math.max(...stringVmps);
            
            // Array current is sum of string currents (parallel strings add current)
            // Each string's current is limited by the lowest panel current in that string
            const stringIscs = completeStrings.map(s => Math.min(...s.map(p => p.specs.isc)));
            const stringImps = completeStrings.map(s => Math.min(...s.map(p => p.specs.imp || p.specs.isc * 0.9)));
            
            const isc = stringIscs.reduce((sum, i) => sum + i, 0);
            const imp = stringImps.reduce((sum, i) => sum + i, 0);
            
            // Total wattage is sum of all panel wattages
            const wmp = completeStrings.reduce((sum, s) => sum + s.reduce((sum2, p) => sum2 + p.specs.wmp, 0), 0);
            
            return { 
                wmp, voc, vmp, isc, imp, 
                panelCount: totalPanels, 
                seriesCount, 
                parallelCount,
                config: `${parallelCount}P${seriesCount}S`
            };
        }
        
        function calculateConnectedBatterySpecs(controller) {
            // For all-in-one controllers, return the internal battery specs plus any connected smart batteries
            if (controller.specs.type === 'all_in_one' && controller.specs.internalBatteryKWh) {
                const internalVoltage = controller.specs.supportedVoltages?.[0] || 48;
                let totalKwh = controller.specs.internalBatteryKWh;
                let smartBatteryCount = 0;
                
                // Count connected smart batteries
                const visitedSmartBatteries = new Set();
                function traceSmartBatteries(item) {
                    Object.values(item.handles).forEach(handle => {
                        if (handle.polarity === 'smart-battery') {
                            handle.connectedTo.forEach(conn => {
                                const connectedItem = allItems.find(i => i.id === conn.itemId);
                                if (connectedItem && connectedItem.type === 'smartbattery' && !visitedSmartBatteries.has(connectedItem.id)) {
                                    visitedSmartBatteries.add(connectedItem.id);
                                    totalKwh += connectedItem.specs.kWh;
                                    smartBatteryCount++;
                                    // Recursively trace from this smart battery
                                    traceSmartBatteries(connectedItem);
                                }
                            });
                        }
                    });
                }
                traceSmartBatteries(controller);
                
                const totalAh = (totalKwh * 1000) / internalVoltage;
                const configText = smartBatteryCount > 0 
                    ? `Internal + ${smartBatteryCount} ext`
                    : 'Internal';
                return {
                    voltage: internalVoltage,
                    ah: totalAh,
                    kWh: totalKwh,
                    maxDischarge: totalAh * 0.9, // Assume 90% usable
                    batteryCount: 1 + smartBatteryCount,
                    seriesCount: 1,
                    parallelCount: 1 + smartBatteryCount,
                    config: configText,
                    isInternal: true
                };
            }
            
            // Trace batteries connected to controller's battery handles
            // Now traces through breakers and combiners
            const connectedBatteries = new Set();
            const visitedNodes = new Set();
            
            function traceTowardsBatteries(item, handle, depth = 0) {
                if (depth > 20) return; // Prevent infinite loops
                const nodeKey = item.id + '-' + handle.id;
                if (visitedNodes.has(nodeKey)) return;
                visitedNodes.add(nodeKey);
                
                if (item.type === 'battery') {
                    connectedBatteries.add(item.id);
                    // Trace through this battery's other handle for series connections
                    Object.values(item.handles).forEach(h => {
                        if (h.id !== handle.id) {
                            h.connectedTo.forEach(conn => {
                                const nextItem = allItems.find(i => i.id === conn.itemId);
                                if (nextItem) {
                                    const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                    if (nextHandle) {
                                        traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                    }
                                }
                            });
                        }
                    });
                    return;
                }
                
                // If it's a breaker, trace through if closed
                if (item.type === 'breaker') {
                    if (!item.isClosed) return; // Breaker is open
                    
                    // Determine which side we came from and trace the other side
                    const isLineSide = handle.id.includes('-line-');
                    const otherHandles = isLineSide 
                        ? [item.handles.loadPositive, item.handles.loadNegative]
                        : [item.handles.linePositive, item.handles.lineNegative];
                    
                    otherHandles.forEach(h => {
                        h.connectedTo.forEach(conn => {
                            const nextItem = allItems.find(i => i.id === conn.itemId);
                            if (nextItem) {
                                const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                if (nextHandle) {
                                    traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                }
                            }
                        });
                    });
                    return;
                }
                
                // If it's a combiner, trace all connected handles
                if (item.type === 'combiner') {
                    Object.values(item.handles).forEach(h => {
                        h.connectedTo.forEach(conn => {
                            const nextItem = allItems.find(i => i.id === conn.itemId);
                            if (nextItem) {
                                const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                if (nextHandle) {
                                    traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                }
                            }
                        });
                    });
                    return;
                }
            }
            
            // Start tracing from controller's battery handles (if they exist)
            const battHandles = [controller.handles.batteryPositive, controller.handles.batteryNegative].filter(h => h);
            battHandles.forEach(battHandle => {
                battHandle.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle) {
                            traceTowardsBatteries(item, connectedHandle);
                        }
                    }
                });
            });
            
            const batteries = Array.from(connectedBatteries).map(id => allItems.find(i => i.id === id));
            
            if (batteries.length === 0) {
                return { voltage: 0, ah: 0, kWh: 0, maxDischarge: 0, batteryCount: 0 };
            }
            
            // Find series strings by tracing battery-to-battery connections
            const visitedBatteries = new Set();
            const strings = [];
            
            function traceSeriesString(startBattery) {
                const string = [];
                const toVisit = [startBattery];
                
                while (toVisit.length > 0) {
                    const battery = toVisit.pop();
                    if (visitedBatteries.has(battery.id)) continue;
                    visitedBatteries.add(battery.id);
                    string.push(battery);
                    
                    // Check both handles for connections to other batteries
                    Object.values(battery.handles).forEach(handle => {
                        handle.connectedTo.forEach(conn => {
                            const connectedItem = allItems.find(i => i.id === conn.itemId);
                            if (connectedItem && connectedItem.type === 'battery' && !visitedBatteries.has(connectedItem.id)) {
                                toVisit.push(connectedItem);
                            }
                        });
                    });
                }
                
                return string;
            }
            
            // Build all series strings
            batteries.forEach(battery => {
                if (!visitedBatteries.has(battery.id)) {
                    const string = traceSeriesString(battery);
                    if (string.length > 0) {
                        strings.push(string);
                    }
                }
            });
            
            if (strings.length === 0) {
                return { voltage: 0, ah: 0, kWh: 0, maxDischarge: 0, batteryCount: 0 };
            }
            
            // Calculate specs for series-parallel configuration
            // Each string: voltages add (series), capacity is min Ah in string
            // Parallel strings: voltage stays same (should be equal), Ah adds up
            
            const stringVoltages = strings.map(s => s.reduce((sum, b) => sum + b.specs.voltage, 0));
            const stringAhs = strings.map(s => Math.min(...s.map(b => b.specs.ah)));
            const stringMaxDischarges = strings.map(s => Math.min(...s.map(b => b.specs.maxDischarge)));
            
            // For parallel strings, voltage should be the same (use max to catch mismatches)
            const voltage = Math.max(...stringVoltages);
            // Ah adds up in parallel
            const ah = stringAhs.reduce((sum, a) => sum + a, 0);
            const kWh = (voltage * ah) / 1000;
            const maxDischarge = stringMaxDischarges.reduce((sum, d) => sum + d, 0);
            
            return { 
                voltage, 
                ah, 
                kWh, 
                maxDischarge, 
                batteryCount: batteries.length,
                seriesCount: Math.max(...strings.map(s => s.length)),
                parallelCount: strings.length,
                config: `${strings.length}P${Math.max(...strings.map(s => s.length))}S`
            };
        }
        
        function calculateOptimizationScore(controller, arraySpecs) {
            if (!controller || arraySpecs.wmp === 0) return 0;
            return Math.min(100, (arraySpecs.wmp / controller.specs.maxWmp) * 100);
        }
        
        function calculateTotalCost() {
            // Sum component costs
            let componentCost = allItems.reduce((sum, item) => sum + (item.specs.cost || 0), 0);
            
            // Sum wire costs from all connections
            let wireCost = connections.reduce((sum, conn) => sum + (conn.totalWireCost || 0), 0);
            
            return componentCost + wireCost;
        }
        
        // Generate Amazon search link for a component
        function generateAmazonLink(component) {
            if (!component || !component.specs) return null;
            
            const name = component.specs.name || '';
            const type = component.type || '';
            let searchTerms = name;
            
            // Add key specs to search terms based on component type
            if (type === 'panel') {
                const wmp = component.specs.wmp || '';
                const vmp = component.specs.vmp || '';
                searchTerms = `${name} ${wmp}W ${vmp}V solar panel`.trim();
            } else if (type === 'battery') {
                const voltage = component.specs.voltage || '';
                const ah = component.specs.ah || '';
                searchTerms = `${name} ${voltage}V ${ah}Ah LiFePO4 battery`.trim();
            } else if (type === 'controller') {
                const maxVoc = component.specs.maxVoc || '';
                const maxWmp = component.specs.maxWmp || '';
                searchTerms = `${name} ${maxVoc}V ${maxWmp}W MPPT charge controller`.trim();
            } else if (type === 'breaker' || type === 'acbreaker') {
                const rating = component.specs.rating || '';
                const voltage = component.specs.voltage || component.specs.maxVoltage || '';
                searchTerms = `${name} ${rating}A ${voltage}V DC breaker`.trim();
            } else {
                searchTerms = name;
            }
            
            // Encode search terms for URL
            const encodedTerms = encodeURIComponent(searchTerms);
            return `https://www.amazon.com/s?k=${encodedTerms}`;
        }
        
        // Generate bill of materials
        function generateBillOfMaterials() {
            const bom = {
                categories: {
                    panels: [],
                    batteries: [],
                    controllers: [],
                    breakers: [],
                    combiners: [],
                    wires: [],
                    other: []
                },
                totalCost: 0
            };
            
            // Helper to create item key for grouping
            function getItemKey(item) {
                if (item.type === 'panel') {
                    return `panel-${item.specs.wmp}-${item.specs.vmp}-${item.specs.cost}`;
                } else if (item.type === 'battery') {
                    return `battery-${item.specs.voltage}-${item.specs.ah}-${item.specs.cost}`;
                } else if (item.type === 'controller') {
                    return `controller-${item.specs.name}-${item.specs.cost}`;
                } else if (item.type === 'breaker') {
                    return `breaker-${item.specs.rating}-${item.specs.maxVoltage}-${item.specs.cost}`;
                } else if (item.type === 'acbreaker') {
                    return `acbreaker-${item.specs.rating}-${item.specs.voltage}-${item.specs.cost}`;
                } else if (item.type === 'combiner' || item.type === 'solarcombiner') {
                    return `${item.type}-${item.specs.inputs || item.specs.breakerRating}-${item.specs.cost}`;
                }
                return `${item.type}-${item.specs.name || 'unknown'}-${item.specs.cost}`;
            }
            
            // Group components by type and specs
            const componentGroups = {};
            
            allItems.forEach(item => {
                if (!item.specs || item.specs.cost === undefined) return;
                
                const key = getItemKey(item);
                if (!componentGroups[key]) {
                    componentGroups[key] = {
                        name: item.specs.name || `${item.type} ${item.id}`,
                        type: item.type,
                        specs: { ...item.specs },
                        quantity: 0,
                        unitCost: item.specs.cost || 0,
                        totalCost: 0,
                        referenceLink: item.specs.referenceLink || null
                    };
                }
                componentGroups[key].quantity++;
                componentGroups[key].totalCost += item.specs.cost || 0;
            });
            
            // Categorize components and generate links
            Object.values(componentGroups).forEach(group => {
                // Get reference link: use preset link, or generate Amazon link, or null
                let referenceLink = group.referenceLink;
                if (!referenceLink) {
                    // Find a sample item of this type to generate link
                    const sampleItem = allItems.find(item => {
                        const key = getItemKey(item);
                        return key === Object.keys(componentGroups).find(k => componentGroups[k] === group);
                    });
                    if (sampleItem) {
                        referenceLink = generateAmazonLink(sampleItem);
                    }
                }
                
                const item = {
                    name: group.name,
                    quantity: group.quantity,
                    unitCost: group.unitCost,
                    totalCost: group.totalCost,
                    referenceLink: referenceLink,
                    specs: group.specs
                };
                
                if (group.type === 'panel') {
                    bom.categories.panels.push(item);
                } else if (group.type === 'battery' || group.type === 'smartbattery') {
                    bom.categories.batteries.push(item);
                } else if (group.type === 'controller') {
                    bom.categories.controllers.push(item);
                } else if (group.type === 'breaker' || group.type === 'acbreaker') {
                    bom.categories.breakers.push(item);
                } else if (group.type === 'combiner' || group.type === 'solarcombiner') {
                    bom.categories.combiners.push(item);
                } else {
                    bom.categories.other.push(item);
                }
                
                bom.totalCost += group.totalCost;
            });
            
            // Group wires by AWG size
            const wireGroups = {};
            connections.forEach(conn => {
                if (!conn.wireGauge || !conn.totalWireCost) return;
                
                const gauge = conn.wireGauge;
                if (!wireGroups[gauge]) {
                    wireGroups[gauge] = {
                        gauge: gauge,
                        name: WIRE_GAUGE_SPECS[gauge]?.name || `${gauge} AWG`,
                        totalLength: 0,
                        costPerFoot: conn.costPerFoot || WIRE_COST_PER_FOOT[gauge] || 0,
                        totalCost: 0,
                        quantity: 0 // Count of wire runs
                    };
                }
                wireGroups[gauge].totalLength += conn.estimatedLength || 0;
                wireGroups[gauge].totalCost += conn.totalWireCost || 0;
                wireGroups[gauge].quantity++;
            });
            
            // Add wire groups to BOM
            Object.values(wireGroups).forEach(wireGroup => {
                bom.categories.wires.push({
                    name: `${wireGroup.name} Wire`,
                    quantity: wireGroup.quantity,
                    unitCost: wireGroup.costPerFoot,
                    totalLength: wireGroup.totalLength.toFixed(1),
                    totalCost: wireGroup.totalCost,
                    referenceLink: null,
                    specs: {
                        gauge: wireGroup.gauge,
                        length: wireGroup.totalLength
                    }
                });
                bom.totalCost += wireGroup.totalCost;
            });
            
            return bom;
        }
        
        // Display bill of materials
        function showBillOfMaterials() {
            const bom = generateBillOfMaterials();
            const bomContent = document.getElementById('bomContent');
            
            let html = '<div style="margin-bottom: 20px;">';
            
            // Helper to render a category
            function renderCategory(categoryName, items, displayName) {
                if (items.length === 0) return '';
                
                let categoryHtml = `
                    <h3 style="color: #5bc0de; margin-top: 20px; margin-bottom: 10px; border-bottom: 2px solid #5bc0de; padding-bottom: 5px;">${displayName}</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">
                        <thead>
                            <tr style="background: #2a2a2a;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #444;">Item</th>
                                <th style="padding: 8px; text-align: center; border: 1px solid #444;">Qty</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #444;">Unit Cost</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #444;">Total Cost</th>
                                <th style="padding: 8px; text-align: center; border: 1px solid #444;">Link</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                let categoryTotal = 0;
                items.forEach((item, index) => {
                    categoryTotal += item.totalCost;
                    const rowColor = index % 2 === 0 ? '#1a1a1a' : '#252525';
                    const linkDisplay = item.referenceLink ? 
                        `<a href="${item.referenceLink}" target="_blank" style="color: #5bc0de; text-decoration: none;">ðŸ”— View</a>` : 
                        '<span style="color: #888;">â€”</span>';
                    
                    // For wires, show length instead of quantity
                    const qtyDisplay = item.totalLength ? `${item.quantity} runs (${item.totalLength} ft)` : item.quantity;
                    
                    categoryHtml += `
                        <tr style="background: ${rowColor};">
                            <td style="padding: 8px; border: 1px solid #444;">${item.name}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #444;">${qtyDisplay}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #444;">$${item.unitCost.toFixed(2)}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #444; font-weight: bold;">$${item.totalCost.toFixed(2)}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #444;">${linkDisplay}</td>
                        </tr>
                    `;
                });
                
                categoryHtml += `
                        </tbody>
                        <tfoot>
                            <tr style="background: #2a2a2a; font-weight: bold;">
                                <td colspan="3" style="padding: 8px; text-align: right; border: 1px solid #444;">${displayName} Subtotal:</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #444; color: #f0ad4e;">$${categoryTotal.toFixed(2)}</td>
                                <td style="padding: 8px; border: 1px solid #444;"></td>
                            </tr>
                        </tfoot>
                    </table>
                `;
                
                return categoryHtml;
            }
            
            // Render each category
            html += renderCategory('panels', bom.categories.panels, 'Solar Panels');
            html += renderCategory('batteries', bom.categories.batteries, 'Batteries');
            html += renderCategory('controllers', bom.categories.controllers, 'Controllers/Inverters');
            html += renderCategory('breakers', bom.categories.breakers, 'Breakers');
            html += renderCategory('combiners', bom.categories.combiners, 'Combiners');
            html += renderCategory('wires', bom.categories.wires, 'Wires');
            html += renderCategory('other', bom.categories.other, 'Other Components');
            
            // Grand total
            html += `
                <div style="margin-top: 30px; padding: 15px; background: #2a2a2a; border: 2px solid #5bc0de; border-radius: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 18px; font-weight: bold;">Grand Total:</span>
                        <span style="font-size: 24px; font-weight: bold; color: #5cb85c;">$${bom.totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                    </div>
                </div>
            `;
            
            html += '</div>';
            bomContent.innerHTML = html;
            
            // Show overlay
            document.getElementById('bomOverlay').style.display = 'flex';
        }
        
        function hideBillOfMaterials() {
            document.getElementById('bomOverlay').style.display = 'none';
        }
        
        // Export bill of materials
        function exportBillOfMaterials() {
            const bom = generateBillOfMaterials();
            const format = 'csv'; // Could be made selectable
            
            let content = '';
            let filename = '';
            
            if (format === 'csv') {
                // CSV format
                content = 'Category,Item,Quantity,Unit Cost,Total Cost,Link\n';
                
                function addCategory(categoryName, items) {
                    items.forEach(item => {
                        const qty = item.totalLength ? `${item.quantity} (${item.totalLength}ft)` : item.quantity;
                        const link = item.referenceLink || '';
                        content += `${categoryName},"${item.name}",${qty},$${item.unitCost.toFixed(2)},$${item.totalCost.toFixed(2)},"${link}"\n`;
                    });
                }
                
                addCategory('Solar Panels', bom.categories.panels);
                addCategory('Batteries', bom.categories.batteries);
                addCategory('Controllers', bom.categories.controllers);
                addCategory('Breakers', bom.categories.breakers);
                addCategory('Combiners', bom.categories.combiners);
                addCategory('Wires', bom.categories.wires);
                addCategory('Other', bom.categories.other);
                
                content += `\nGrand Total,,,,"$${bom.totalCost.toFixed(2)}",\n`;
                
                filename = `solar_system_bom_${new Date().toISOString().slice(0,10)}.csv`;
            } else if (format === 'json') {
                // JSON format
                content = JSON.stringify(bom, null, 2);
                filename = `solar_system_bom_${new Date().toISOString().slice(0,10)}.json`;
            }
            
            // Create download
            const blob = new Blob([content], { type: format === 'csv' ? 'text/csv' : 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Calculate combined AC output from hubs (Delta Pro parallel system)
        function calculateHubCombinedOutput() {
            const hubs = allItems.filter(i => i.type === 'doublevoltagehub');
            let totalHubOutput = 0;
            
            hubs.forEach(hub => {
                let connectedUnits = 0;
                let unitOutputSum = 0;
                
                // Check input1
                if (hub.handles.input1.connectedTo.length > 0) {
                    const connectedItem = allItems.find(i => i.id === hub.handles.input1.connectedTo[0].itemId);
                    if (connectedItem && connectedItem.type === 'controller' && connectedItem.specs.parallelCapable) {
                        connectedUnits++;
                        unitOutputSum += connectedItem.specs.maxACOutputW || 0;
                    }
                }
                
                // Check input2
                if (hub.handles.input2.connectedTo.length > 0) {
                    const connectedItem = allItems.find(i => i.id === hub.handles.input2.connectedTo[0].itemId);
                    if (connectedItem && connectedItem.type === 'controller' && connectedItem.specs.parallelCapable) {
                        connectedUnits++;
                        unitOutputSum += connectedItem.specs.maxACOutputW || 0;
                    }
                }
                
                // Hub output is sum of connected units (up to hub max)
                if (connectedUnits > 0) {
                    totalHubOutput += Math.min(unitOutputSum, hub.specs.maxOutputW);
                }
            });
            
            return totalHubOutput;
        }
        
        function updateScores() {
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            const controllers = allItems.filter(i => i.type === 'controller');
            const controller = controllers[0]; // Primary controller for validation display
            
            // Use connection-aware calculations if controller exists
            let arrayWmp, arrayVoc, arrayImp, arrayConfig, batteryKwh, batteryVoltage, batteryConfig, nominalBatteryVoltage;
            
            if (controllers.length > 0) {
                // Aggregate solar from ALL controllers (for hub-connected systems)
                let totalWmp = 0;
                let maxVoc = 0;
                let totalImp = 0;
                let totalBatteryKwh = 0;
                let configs = [];
                
                controllers.forEach(ctrl => {
                    const arraySpecs = calculateConnectedArraySpecs(ctrl);
                    const batterySpecs = calculateConnectedBatterySpecs(ctrl);
                    totalWmp += arraySpecs.wmp;
                    maxVoc = Math.max(maxVoc, arraySpecs.voc); // Use max Voc for safety checks
                    totalImp += arraySpecs.imp || 0;
                    totalBatteryKwh += batterySpecs.kWh;
                    if (arraySpecs.config && arraySpecs.config !== '-') {
                        configs.push(arraySpecs.config);
                    }
                });
                
                arrayWmp = totalWmp;
                arrayVoc = maxVoc;
                arrayImp = totalImp;
                arrayConfig = configs.length > 0 ? configs.join(' + ') : '-';
                batteryKwh = totalBatteryKwh;
                
                // For battery voltage, use first controller's connected battery
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                batteryVoltage = batterySpecs.voltage;
                batteryConfig = batterySpecs.config || '-';
                // Calculate nominal voltage (round to nearest 12V increment)
                nominalBatteryVoltage = batteryVoltage > 0 ? Math.round(batteryVoltage / 12) * 12 : 0;
            } else {
                arrayWmp = panels.reduce((sum, p) => sum + p.specs.wmp, 0);
                arrayVoc = panels.reduce((sum, p) => sum + p.specs.voc, 0);
                arrayImp = panels.length > 0 ? panels[0].specs.imp || 0 : 0;
                arrayConfig = panels.length > 0 ? `1P${panels.length}S` : '-';
                batteryKwh = batteries.reduce((sum, b) => sum + b.specs.kWh, 0);
                batteryVoltage = batteries.reduce((sum, b) => sum + b.specs.voltage, 0);
                batteryConfig = batteries.length > 0 ? `1P${batteries.length}S` : '-';
                nominalBatteryVoltage = batteryVoltage > 0 ? Math.round(batteryVoltage / 12) * 12 : 0;
            }
            
            const totalCost = calculateTotalCost();
            
            // Update score displays
            document.getElementById('scoreArrayWmp').textContent = arrayWmp + ' W';
            
            const vocEl = document.getElementById('scoreArrayVoc');
            vocEl.textContent = arrayVoc.toFixed(1) + ' V';
            vocEl.classList.remove('good', 'warning', 'error');
            if (controller) {
                if (arrayVoc > controller.specs.maxVoc) {
                    vocEl.classList.add('error');
                } else if (arrayVoc > controller.specs.maxVoc * 0.9) {
                    vocEl.classList.add('warning');
                } else {
                    vocEl.classList.add('good');
                }
            }
            
            // Array Imp
            const impEl = document.getElementById('scoreArrayImp');
            impEl.textContent = arrayImp.toFixed(1) + ' A';
            impEl.classList.remove('good', 'warning', 'error');
            if (controller) {
                if (arrayImp > controller.specs.maxIsc) {
                    impEl.classList.add('error');
                } else if (arrayImp > controller.specs.maxIsc * 0.9) {
                    impEl.classList.add('warning');
                } else {
                    impEl.classList.add('good');
                }
            }
            
            // Array Config (e.g., 2P4S)
            document.getElementById('scoreArrayConfig').textContent = arrayConfig;
            
            document.getElementById('scoreBatteryKwh').textContent = batteryKwh.toFixed(2) + ' kWh';
            document.getElementById('scoreBatteryConfig').textContent = batteryConfig;
            document.getElementById('scoreBatteryVoltage').textContent = nominalBatteryVoltage > 0 ? nominalBatteryVoltage + 'V' : '-';
            document.getElementById('scoreTotalCost').textContent = '$' + totalCost.toLocaleString();
            
            // Optimization score
            if (controller) {
                const optScore = calculateOptimizationScore(controller, { wmp: arrayWmp });
                document.getElementById('scoreOptimization').textContent = optScore.toFixed(0) + '%';
                
                const optEl = document.getElementById('scoreOptimization');
                optEl.classList.remove('good', 'warning', 'error');
                if (optScore >= 80) optEl.classList.add('good');
                else if (optScore >= 50) optEl.classList.add('warning');
                else optEl.classList.add('error');
            } else {
                document.getElementById('scoreOptimization').textContent = '-';
            }
            
            // K_micro estimate (based on typical panel efficiency ~18%)
            const panelEfficiency = 0.18;
            const kMicro = 0.1 * panelEfficiency;
            document.getElementById('scoreKMicro').textContent = kMicro.toFixed(4);
        }
        
        // ============================================
        // HINTS & ACHIEVEMENTS
        // ============================================
        
        function areHintsEnabled() {
            return document.getElementById('showHintsToggle')?.checked !== false;
        }
        
        function showHint(title, text) {
            // Check if hints are enabled
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            // Restore standard hint structure if it was replaced
            hintPopup.innerHTML = `
                <h3 id="hintTitle"></h3>
                <p id="hintText"></p>
                <button id="hintDismiss">Got it!</button>
            `;
            document.getElementById('hintTitle').textContent = title;
            document.getElementById('hintText').textContent = text;
            hintPopup.classList.remove('hidden');
            // Ensure it's visible and interactive
            hintPopup.style.display = 'block';
            hintPopup.style.visibility = 'visible';
            hintPopup.style.pointerEvents = 'auto';
            hintPopup.style.opacity = '1';
            // Event listener is handled via event delegation on the hintPopup container
        }
        
        function hideHint() {
            const hintPopup = document.getElementById('hintPopup');
            if (hintPopup) {
                hintPopup.classList.add('hidden');
                // Force remove from interaction flow
                hintPopup.style.display = 'none';
                hintPopup.style.visibility = 'hidden';
                hintPopup.style.pointerEvents = 'none';
                hintPopup.style.opacity = '0';
            }
            if (seriesVoltageInterval) {
                clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = null;
            }
        }
        
        function showCurrentClippingHint(arraySpecs, controller, clippedOutputW, lostPowerW, lostPercent, additionalPanelsNeeded) {
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #f0ad4e;">âš¡ Current Clipping Active</h3>
                        <p style="margin: 0 0 8px 0;">
                            Your array current (<strong>${arraySpecs.imp.toFixed(1)}A</strong>) exceeds the controller's max input (<strong>${controller.specs.maxIsc}A</strong>).
                        </p>
                        <p style="margin: 0 0 8px 0; color: #f0ad4e;">
                            <strong>Clipped output: ${clippedOutputW}W</strong> (losing ${lostPowerW}W / ${lostPercent}%)
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            <strong>How clipping works:</strong> Array Vmp (${arraySpecs.vmp.toFixed(1)}V) Ã— Controller max Isc (${controller.specs.maxIsc}A) = ${clippedOutputW}W max
                        </p>
                        <p style="margin: 0; color: #5cb85c; font-size: 12px;">
                            <strong>Solution:</strong> Add more panels in series to increase voltage and decrease current. 
                            ${additionalPanelsNeeded > 0 ? `Adding ~${additionalPanelsNeeded} more panel${additionalPanelsNeeded > 1 ? 's' : ''} per string would help utilize more of your array's potential.` : ''}
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(240, 173, 78, 0.2); border-radius: 8px; text-align: center; min-width: 120px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY RATED</div>
                        <div style="font-size: 16px; font-weight: bold; color: #888; text-decoration: line-through;">${arraySpecs.wmp}W</div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 8px;">WITH CLIPPING</div>
                        <div style="font-size: 20px; font-weight: bold; color: #f0ad4e;">${clippedOutputW}W</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">CTRL MAX</div>
                            <div style="font-size: 14px; color: #5cb85c;">${controller.specs.maxWmp || 'N/A'}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // ============================================
        // TUTORIAL SYSTEM
        // ============================================
        
        function checkTutorialProgress() {
            // Skip tutorial progress tracking if hints are disabled
            if (!areHintsEnabled()) return;
            if (tutorialCompleted) return;
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const batteryConnected = controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                                    controller.handles?.batteryNegative?.connectedTo?.length > 0;
            const solarConnected = controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                                  controller.handles?.pvNegative?.connectedTo?.length > 0;
            
            // Check if user connected solar first (out of order)
            if (tutorialStep === 0 && solarConnected && !batteryConnected && !connectedSolarFirst) {
                connectedSolarFirst = true;
                hideHint();
                showSuccessAnimation();
                setTimeout(() => {
                    showHint("â˜€ï¸ Nice! You've got solar power!", 
                        "But your controller isn't connected to a battery yet. This usually works, but it's best to connect the battery first so the power has somewhere to go. Connect the battery now!");
                }, 300);
                return;
            }
            
            const currentStepData = TUTORIAL_STEPS[tutorialStep];
            if (!currentStepData) {
                tutorialCompleted = true;
                return;
            }
            
            // Check if current step is complete
            if (currentStepData.check(controller)) {
                // Auto-dismiss current hint
                hideHint();
                
                // Show success animation
                showSuccessAnimation();
                
                tutorialStep++;
                
                // Show success message, then next hint
                if (tutorialStep < TUTORIAL_STEPS.length) {
                    setTimeout(() => {
                        showHint(currentStepData.successTitle, currentStepData.successText);
                    }, 300);
                }
                
                // Check if tutorial is complete - show series hint
                if (tutorialStep >= TUTORIAL_STEPS.length) {
                    tutorialCompleted = true;
                    // Show series hint after a delay
                    setTimeout(() => {
                        if (!seriesHintShown) {
                            showSeriesHint();
                        }
                    }, 2000);
                }
            }
        }
        
        function showSeriesHint() {
            seriesHintShown = true;
            if (!areHintsEnabled()) return;
            
            // Disconnect the negative PV wire so user can drag to create series panels
            // Only do this if hints are enabled (already checked above)
            const controller = allItems.find(i => i.type === 'controller');
            if (controller) {
                const negConn = connections.find(c => 
                    c.targetHandleId === controller.handles.pvNegative.id || 
                    c.sourceHandleId === controller.handles.pvNegative.id
                );
                if (negConn) {
                    deleteConnection(negConn.id);
                }
            }
            
            const arraySpecs = controller ? calculateConnectedArraySpecs(controller) : { voc: 0, panelCount: 0 };
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #ffdd57;">âš¡ Expand Your Array</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the panel's - terminal to empty space to add more panels in series.</p>
                        <p style="margin: 0; color: #aaa; font-size: 12px;">
                            Series connection: <strong style="color: #ffdd57;">voltage adds up</strong>, current stays the same.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                        <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #5cb85c;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div id="livePanelCount" style="font-size: 10px; color: #888; margin-top: 2px;">${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
        }
        
        function showSeriesPanelHint() {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const arraySpecs = controller ? calculateConnectedArraySpecs(controller) : { voc: 0, panelCount: 0 };
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">âœ¨ Panel Added!</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the new panel's - terminal to add more in series, or connect it back to the controller's PV- to complete the circuit.</p>
                        <p style="margin: 0; color: #aaa; font-size: 11px;">
                            <strong>Tips:</strong> Double-click wires to delete. Select nodes and press Delete to remove.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                        <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #5cb85c;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div id="livePanelCount" style="font-size: 10px; color: #888; margin-top: 2px;">${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
        }
        
        function updateSeriesVoltageReadout() {
            const readout = document.getElementById('liveVoltageReadout');
            if (!readout) {
                if (seriesVoltageInterval) {
                    clearInterval(seriesVoltageInterval);
                    seriesVoltageInterval = null;
                }
                return;
            }
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            readout.textContent = arraySpecs.voc.toFixed(1) + 'V';
            
            // Update panel count too
            const countEl = document.getElementById('livePanelCount');
            if (countEl) {
                countEl.textContent = `${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}`;
            }
            
            // Change color based on controller limit
            if (arraySpecs.voc > controller.specs.maxVoc) {
                readout.style.color = '#d9534f';
            } else if (arraySpecs.voc > controller.specs.maxVoc * 0.8) {
                readout.style.color = '#f0ad4e';
            } else {
                readout.style.color = '#5cb85c';
            }
        }
        
        function showOptimalArrayHint(arraySpecs, batterySpecs, maxWattsAtBattery, maxWattsAt48V) {
            if (!areHintsEnabled()) return;
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">ðŸŽ‰ Excellent Array Configuration!</h3>
                        <p style="margin: 0 0 8px 0;">
                            You've connected <strong style="color: #ffdd57;">${arraySpecs.wmp}W</strong> of solar panels without exceeding your controller's voltage limit!
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            But your <strong style="color: #f0ad4e;">${batterySpecs.voltage}V battery</strong> is limiting your controller's solar input to <strong>${maxWattsAtBattery}W</strong>.
                        </p>
                        <p style="margin: 0 0 8px 0; color: #5bc0de; font-size: 12px;">
                            With a <strong>48V battery</strong>, you could connect up to <strong>${maxWattsAt48V}W</strong> of solar panels!
                        </p>
                        <p style="margin: 0; color: #888; font-size: 11px;">
                            Try building a higher voltage battery pack by connecting batteries in series!
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 110px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                        <div style="font-size: 18px; font-weight: bold; color: #5cb85c;">${arraySpecs.wmp}W</div>
                        <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">MAX @ ${batterySpecs.voltage}V</div>
                            <div style="font-size: 14px; color: #f0ad4e;">${maxWattsAtBattery}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        function showSeriesBatteryHint() {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const batterySpecs = controller ? calculateConnectedBatterySpecs(controller) : { voltage: 0, kWh: 0 };
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">ðŸ”‹ Battery Added!</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the new battery's terminal to add more in series, or connect it back to the controller's BATT terminals.</p>
                        <p style="margin: 0; color: #aaa; font-size: 11px;">
                            Series connection: <strong style="color: #ffdd57;">voltage adds up</strong>. Build 24V or 48V packs for more solar capacity!
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(40, 167, 69, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BANK VOLTAGE</div>
                        <div id="liveBatteryVoltage" style="font-size: 22px; font-weight: bold; color: #28a745;">${batterySpecs.voltage.toFixed(1)}V</div>
                        <div id="liveBatteryCount" style="font-size: 10px; color: #888; margin-top: 2px;">${batterySpecs.kWh.toFixed(2)} kWh</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live battery voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesBatteryReadout, 200);
        }
        
        function updateSeriesBatteryReadout() {
            const readout = document.getElementById('liveBatteryVoltage');
            if (!readout) {
                if (seriesVoltageInterval) {
                    clearInterval(seriesVoltageInterval);
                    seriesVoltageInterval = null;
                }
                return;
            }
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            readout.textContent = batterySpecs.voltage.toFixed(1) + 'V';
            
            // Update kWh too
            const kwhEl = document.getElementById('liveBatteryCount');
            if (kwhEl) {
                kwhEl.textContent = `${batterySpecs.kWh.toFixed(2)} kWh`;
            }
            
            // Change color based on voltage compatibility
            const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
            const maxSupported = Math.max(...supportedVoltages);
            
            if (batterySpecs.voltage > maxSupported) {
                readout.style.color = '#d9534f';
            } else if (!supportedVoltages.includes(Math.round(batterySpecs.voltage / 12) * 12)) {
                readout.style.color = '#f0ad4e';
            } else {
                readout.style.color = '#28a745';
            }
        }
        
        function showSuccessAnimation() {
            if (!areHintsEnabled()) return;
            
            // Create smooth green glow overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(92, 184, 92, 0.3) 0%, rgba(92, 184, 92, 0) 70%);
                pointer-events: none;
                z-index: 10001;
                opacity: 0;
                transition: opacity 0.4s ease-in-out;
            `;
            document.body.appendChild(overlay);
            
            // Fade in
            setTimeout(() => overlay.style.opacity = '1', 10);
            
            // Fade out and remove
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 400);
            }, 600);
            
            // Add a subtle green pulse to the canvas border
            const canvas = document.getElementById('canvas');
            canvas.style.boxShadow = '0 0 30px rgba(92, 184, 92, 0.6)';
            setTimeout(() => {
                canvas.style.transition = 'box-shadow 0.5s ease-out';
                canvas.style.boxShadow = 'none';
            }, 100);
            setTimeout(() => {
                canvas.style.transition = '';
            }, 600);
        }
        
        function startTutorial() {
            tutorialStep = 0;
            tutorialCompleted = false;
            
            const firstStep = TUTORIAL_STEPS[0];
            showHint(firstStep.title, firstStep.text);
        }
        
        // Calculate system statistics for review/display
        function calculateSystemStats() {
            const controllers = allItems.filter(i => i.type === 'controller');
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Initialize default stats
            let stats = {
                arrayWmp: 0,
                arrayVoc: 0,
                arrayVmp: 0,
                arrayIsc: 0,
                arrayImp: 0,
                panelCount: 0,
                seriesCount: 0,
                parallelCount: 0,
                batteryKwh: 0,
                batteryVoltage: 0,
                batteryAh: 0,
                batteryCount: 0,
                controllerName: 'None',
                controllerCount: 0,
                controllerMaxWmp: 0,
                controllerMaxVoc: 0,
                controllerRatedChargeCurrent: 0,
                cost: 0,
                optimization: 0,
                isOperational: false
            };
            
            // Calculate combined specs from ALL controllers (for hub-connected systems)
            if (controllers.length > 0) {
                let totalWmp = 0;
                let maxVoc = 0;
                let maxVmp = 0;
                let totalIsc = 0;
                let totalImp = 0;
                let totalPanelCount = 0;
                let maxSeriesCount = 0;
                let totalParallelCount = 0;
                let totalBatteryKwh = 0;
                let totalBatteryAh = 0;
                let totalBatteryCount = 0;
                let totalMaxWmp = 0;
                let maxMaxVoc = 0;
                let totalRatedChargeCurrent = 0;
                let controllerNames = [];
                let allOperational = true;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    
                    // Aggregate array specs
                    totalWmp += arraySpecs.wmp;
                    maxVoc = Math.max(maxVoc, arraySpecs.voc);
                    maxVmp = Math.max(maxVmp, arraySpecs.vmp);
                    totalIsc += arraySpecs.isc;
                    totalImp += arraySpecs.imp;
                    totalPanelCount += arraySpecs.panelCount;
                    maxSeriesCount = Math.max(maxSeriesCount, arraySpecs.seriesCount);
                    totalParallelCount += arraySpecs.parallelCount;
                    
                    // Aggregate battery specs
                    totalBatteryKwh += batterySpecs.kWh;
                    totalBatteryAh += batterySpecs.ah;
                    totalBatteryCount += batterySpecs.batteryCount;
                    
                    // Aggregate controller specs
                    totalMaxWmp += controller.specs.maxWmp || 0;
                    maxMaxVoc = Math.max(maxMaxVoc, controller.specs.maxVoc || 0);
                    totalRatedChargeCurrent += controller.specs.ratedChargeCurrent || 0;
                    
                    const controllerName = controller.specs.name || 'Unknown';
                    if (!controllerNames.includes(controllerName)) {
                        controllerNames.push(controllerName);
                    }
                    
                    // Check if this controller is operational
                    const pvPositive = controller.handles?.pvPositive;
                    const pvNegative = controller.handles?.pvNegative;
                    const batteryPositive = controller.handles?.batteryPositive;
                    const batteryNegative = controller.handles?.batteryNegative;
                    
                    const pvConnected = pvPositive && pvNegative && 
                                       pvPositive.connectedTo && pvNegative.connectedTo &&
                                       pvPositive.connectedTo.length > 0 && pvNegative.connectedTo.length > 0;
                    const battConnected = batteryPositive && batteryNegative &&
                                         batteryPositive.connectedTo && batteryNegative.connectedTo &&
                                         batteryPositive.connectedTo.length > 0 && batteryNegative.connectedTo.length > 0;
                    
                    // For all-in-one controllers, check if they have internal battery
                    const isAllInOne = controller.specs?.type === 'all_in_one' || controller.subtype === 'all_in_one';
                    const hasInternalBattery = isAllInOne && controller.specs?.internalBatteryKWh > 0;
                    
                    const controllerOperational = (pvConnected && (battConnected || hasInternalBattery)) && 
                                                  arraySpecs.wmp > 0 && batterySpecs.kWh > 0;
                    
                    if (!controllerOperational) {
                        allOperational = false;
                    }
                });
                
                // Set aggregated stats
                stats.arrayWmp = totalWmp;
                stats.arrayVoc = maxVoc;
                stats.arrayVmp = maxVmp;
                stats.arrayIsc = totalIsc;
                stats.arrayImp = totalImp;
                stats.panelCount = totalPanelCount;
                stats.seriesCount = maxSeriesCount;
                stats.parallelCount = totalParallelCount;
                
                stats.batteryKwh = totalBatteryKwh;
                stats.batteryAh = totalBatteryAh;
                stats.batteryCount = totalBatteryCount;
                
                // Use first controller's battery voltage (they should all be the same in parallel)
                if (controllers.length > 0) {
                    const firstBatterySpecs = calculateConnectedBatterySpecs(controllers[0]);
                    stats.batteryVoltage = firstBatterySpecs.voltage;
                }
                
                // Controller info
                stats.controllerCount = controllers.length;
                stats.controllerName = controllerNames.length === 1 ? controllerNames[0] : 
                                      controllerNames.length > 1 ? `${controllerNames[0]} (${controllers.length}x)` :
                                      'Unknown';
                stats.controllerMaxWmp = totalMaxWmp;
                stats.controllerMaxVoc = maxMaxVoc;
                stats.controllerRatedChargeCurrent = totalRatedChargeCurrent;
                
                // System is operational if all controllers are operational
                stats.isOperational = allOperational && totalWmp > 0 && totalBatteryKwh > 0;
                
                // Calculate optimization score (based on total array vs total controller capacity)
                if (totalWmp > 0 && totalMaxWmp > 0) {
                    stats.optimization = Math.min(100, (totalWmp / totalMaxWmp) * 100);
                }
            }
            
            // Calculate total cost (including wires)
            stats.cost = calculateTotalCost();
            
            return stats;
        }
        
        function showAchievement(title, stats) {
            if (!areHintsEnabled()) return;
            
            document.getElementById('achievementTitle').textContent = title;
            
            // Calculate daily energy estimate (assuming 4.5 peak sun hours)
            const peakSunHours = 4.5;
            const dailyKwh = (stats.arrayWmp * peakSunHours) / 1000;
            
            // Calculate cost metrics
            const costPerWatt = stats.arrayWmp > 0 ? (stats.cost / stats.arrayWmp).toFixed(2) : 0;
            const costPerKwh = stats.batteryKwh > 0 ? (stats.cost / stats.batteryKwh).toFixed(0) : 0;
            
            // Calculate payback (assuming $0.12/kWh grid cost)
            const gridCostPerKwh = 0.12;
            const annualSavings = dailyKwh * 365 * gridCostPerKwh;
            const paybackYears = annualSavings > 0 ? (stats.cost / annualSavings).toFixed(1) : 'âˆž';
            
            const statsContainer = document.getElementById('achievementStats');
            statsContainer.innerHTML = `
                <div class="achievement-stat">
                    <div class="label">Array Power</div>
                    <div class="value">${stats.arrayWmp} W</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Array Voltage</div>
                    <div class="value">${stats.arrayVoc.toFixed(1)} V</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Battery Storage</div>
                    <div class="value">${stats.batteryKwh.toFixed(2)} kWh</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Battery Voltage</div>
                    <div class="value">${stats.batteryVoltage.toFixed(1)} V</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Optimization</div>
                    <div class="value">${stats.optimization.toFixed(0)}%</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Est. Daily Output</div>
                    <div class="value">${dailyKwh.toFixed(1)} kWh</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Total Cost</div>
                    <div class="value">$${stats.cost.toLocaleString()}</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Est. Payback</div>
                    <div class="value">${paybackYears} years</div>
                </div>
            `;
            
            document.getElementById('achievementOverlay').classList.add('visible');
        }
        
        // ============================================
        // SYSTEM REVIEW MODULE
        // ============================================
        const SystemReview = {
            // Configuration constants
            config: {
                peakSunHours: 4.5,
                gridCostPerKwh: 0.12
            },
            
            // Calculate system statistics with derived values
            calculateStats: function() {
                const stats = calculateSystemStats();
                const dailyKwh = (stats.arrayWmp * this.config.peakSunHours) / 1000;
                const annualSavings = dailyKwh * 365 * this.config.gridCostPerKwh;
                const paybackYears = annualSavings > 0 && stats.cost > 0 
                    ? (stats.cost / annualSavings).toFixed(1) 
                    : 'âˆž';
                
                return {
                    ...stats,
                    dailyKwh,
                    annualSavings,
                    paybackYears
                };
            },
            
            // Format a single stat item
            formatStatItem: function(label, value, options = {}) {
                const valueClass = options.disabled ? 'system-review-stat-disabled' : '';
                return `
                    <div class="achievement-stat">
                        <div class="label">${label}</div>
                        <div class="value ${valueClass}">${value}</div>
                    </div>
                `;
            },
            
            // Render all stats HTML
            render: function(stats) {
                let statsHTML = '';
                
                // Panel stats
                if (stats.panelCount > 0) {
                    statsHTML += this.formatStatItem('Array Power', `${stats.arrayWmp} W`);
                    statsHTML += this.formatStatItem('Array Voltage', `${stats.arrayVoc.toFixed(1)} V`);
                    statsHTML += this.formatStatItem('Array Current', `${stats.arrayImp.toFixed(1)} A`);
                    statsHTML += this.formatStatItem('Panel Count', `${stats.panelCount} (${stats.parallelCount}P${stats.seriesCount}S)`);
                } else {
                    statsHTML += this.formatStatItem('Solar Panels', 'Not Connected', { disabled: true });
                }
                
                // Battery stats
                if (stats.batteryCount > 0) {
                    statsHTML += this.formatStatItem('Battery Storage', `${stats.batteryKwh.toFixed(2)} kWh`);
                    statsHTML += this.formatStatItem('Battery Voltage', `${stats.batteryVoltage.toFixed(1)} V`);
                    statsHTML += this.formatStatItem('Battery Count', `${stats.batteryCount}`);
                } else {
                    statsHTML += this.formatStatItem('Batteries', 'Not Connected', { disabled: true });
                }
                
                // Controller stats
                if (stats.controllerName !== 'None') {
                    statsHTML += this.formatStatItem(
                        `Controller${stats.controllerCount > 1 ? 's' : ''}`,
                        `${stats.controllerName}${stats.controllerCount > 1 ? ` (${stats.controllerCount}x)` : ''}`
                    );
                    statsHTML += this.formatStatItem(
                        `Max PV Input${stats.controllerCount > 1 ? ' (Combined)' : ''}`,
                        `${stats.controllerMaxWmp} W`
                    );
                    statsHTML += this.formatStatItem('Max Voc', `${stats.controllerMaxVoc} V`);
                    
                    if (stats.optimization > 0) {
                        statsHTML += this.formatStatItem('Optimization', `${stats.optimization.toFixed(0)}%`);
                    }
                }
                
                // Daily output
                if (stats.arrayWmp > 0) {
                    statsHTML += this.formatStatItem('Est. Daily Output', `${stats.dailyKwh.toFixed(1)} kWh`);
                }
                
                // Cost
                statsHTML += this.formatStatItem('Total Cost', `$${stats.cost.toLocaleString()}`);
                
                // Payback
                if (stats.isOperational && stats.cost > 0) {
                    statsHTML += this.formatStatItem('Est. Payback', `${stats.paybackYears} years`);
                }
                
                return statsHTML;
            },
            
            // Main entry point - show system review
            show: function() {
                const stats = this.calculateStats();
                
                // Set title based on system status
                const title = stats.isOperational ? 'ðŸ“Š System Review' : 'ðŸ“Š System Overview';
                document.getElementById('achievementTitle').textContent = title;
                
                // Build and display stats
                const statsContainer = document.getElementById('achievementStats');
                statsContainer.innerHTML = this.render(stats);
                
                // Update button visibility
                const startSimBtn = document.getElementById('startSimulation');
                const continueBtn = document.getElementById('achievementClose');
                
                // Add BOM button if it doesn't exist
                let bomBtn = document.getElementById('viewBomBtn');
                if (!bomBtn) {
                    const buttonContainer = document.querySelector('#achievementOverlay .achievement-content > div:last-child');
                    if (buttonContainer) {
                        bomBtn = document.createElement('button');
                        bomBtn.id = 'viewBomBtn';
                        bomBtn.textContent = 'ðŸ“‹ View Bill of Materials';
                        bomBtn.style.background = '#5bc0de';
                        bomBtn.style.marginRight = '10px';
                        buttonContainer.insertBefore(bomBtn, startSimBtn);
                        bomBtn.addEventListener('click', () => {
                            hideAchievement();
                            showBillOfMaterials();
                        });
                    }
                }
                bomBtn.style.display = 'inline-block';
                
                if (stats.isOperational) {
                    startSimBtn.style.display = 'inline-block';
                    continueBtn.textContent = 'Continue Building';
                } else {
                    startSimBtn.style.display = 'none';
                    continueBtn.textContent = 'Close';
                }
                
                document.getElementById('achievementOverlay').classList.add('visible');
            }
        };
        
        // Legacy function for backward compatibility
        function showSystemReview() {
            SystemReview.show();
        }
        
        function hideAchievement() {
            document.getElementById('achievementOverlay').classList.remove('visible');
        }
        
        // ============================================
        // COMPONENT LIBRARY
        // ============================================
        
        function populateLibraries() {
            // Panels
            const panelLibrary = document.getElementById('panelLibrary');
            panelLibrary.innerHTML = PANEL_PRESETS.map((p, i) => `
                <div class="component-item" data-preset-type="panel" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${p.name}</div>
                        <div class="component-specs">${p.wmp}W | ${p.vmp}V | $${p.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Batteries
            const batteryLibrary = document.getElementById('batteryLibrary');
            batteryLibrary.innerHTML = BATTERY_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="battery" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.voltage}V | ${b.ah}Ah | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Controllers
            const controllerLibrary = document.getElementById('controllerLibrary');
            controllerLibrary.innerHTML = CONTROLLER_PRESETS.map((c, i) => `
                <div class="component-item" data-preset-type="controller" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${c.name}</div>
                        <div class="component-specs">${c.maxVoc}V / ${c.ratedChargeCurrent}A | ${c.supportedVoltages.join('/')}V | $${c.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Breakers
            const breakerLibrary = document.getElementById('breakerLibrary');
            breakerLibrary.innerHTML = BREAKER_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="breaker" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.maxVoltage}V DC | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Combiners
            const combinerLibrary = document.getElementById('combinerLibrary');
            combinerLibrary.innerHTML = COMBINER_PRESETS.map((c, i) => `
                <div class="component-item" data-preset-type="combiner" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${c.name}</div>
                        <div class="component-specs">${c.inputs} inputs | ${c.maxAmpsPerInput}A/input | $${c.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Solar Combiner Boxes
            const solarCombinerLibrary = document.getElementById('solarCombinerLibrary');
            solarCombinerLibrary.innerHTML = SOLAR_COMBINER_PRESETS.map((s, i) => `
                <div class="component-item" data-preset-type="solarcombiner" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${s.name}</div>
                        <div class="component-specs">${s.inputs}x ${s.breakerRating}A breakers | $${s.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // EcoFlow Ecosystem
            const ecoflowLibrary = document.getElementById('ecoflowLibrary');
            ecoflowLibrary.innerHTML = `
                <div class="component-item" data-preset-type="doublevoltagehub" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">Double Voltage Hub</div>
                        <div class="component-specs">120V/240V â€¢ 7200W | $400</div>
                    </div>
                </div>
            `;
            
            // AC Breakers
            const acBreakerLibrary = document.getElementById('acBreakerLibrary');
            acBreakerLibrary.innerHTML = AC_BREAKER_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="acbreaker" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.maxWatts}W max | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // AC Outlets
            const acOutletLibrary = document.getElementById('acOutletLibrary');
            acOutletLibrary.innerHTML = `
                <div class="component-item" data-preset-type="acoutlet" data-preset-index="120">
                    <div class="component-info">
                        <div class="component-name">120V Outlet</div>
                        <div class="component-specs">15A NEMA 5-15 | $5</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="acoutlet" data-preset-index="240">
                    <div class="component-info">
                        <div class="component-name">240V Outlet</div>
                        <div class="component-specs">30A NEMA 14-30 | $25</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="spiderbox" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">CEP Spider Box</div>
                        <div class="component-specs">240V 50A In â€¢ 6 circuits | $450</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="breakerpanel" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">100A Breaker Panel</div>
                        <div class="component-specs">240V 100A â€¢ 8 circuits | $250</div>
                    </div>
                </div>
            `;
            
            // Add click handlers
            document.querySelectorAll('.component-item').forEach(el => {
                el.addEventListener('click', () => {
                    const type = el.dataset.presetType;
                    const index = parseInt(el.dataset.presetIndex);
                    addComponentFromPreset(type, index);
                });
            });
        }
        
        function addComponentFromPreset(type, index) {
            const x = svgWidth / 2 - 50 + Math.random() * 100;
            const y = svgHeight / 2 - 50 + Math.random() * 100;
            
            let item;
            if (type === 'panel') {
                item = createPanel(x, y, PANEL_PRESETS[index]);
            } else if (type === 'battery') {
                item = createBattery(x, y, BATTERY_PRESETS[index]);
            } else if (type === 'controller') {
                item = createController(x, y, CONTROLLER_PRESETS[index]);
            } else if (type === 'breaker') {
                item = createBreaker(x, y, BREAKER_PRESETS[index]);
            } else if (type === 'combiner') {
                item = createCombiner(x, y, COMBINER_PRESETS[index]);
            } else if (type === 'solarcombiner') {
                item = createSolarCombinerBox(x, y, SOLAR_COMBINER_PRESETS[index]);
            } else if (type === 'doublevoltagehub') {
                item = createDoubleVoltageHub(x, y);
            } else if (type === 'acbreaker') {
                item = createACBreaker(x, y, AC_BREAKER_PRESETS[index]);
            } else if (type === 'acoutlet') {
                // index is voltage (120 or 240)
                item = createACOutlet(x, y, index);
            } else if (type === 'spiderbox') {
                item = createSpiderBox(x, y);
            } else if (type === 'breakerpanel') {
                item = createBreakerPanel(x, y);
            }
            
            if (item) {
                allItems.push(item);
                render();
            }
        }
        
        // ============================================
        // MODE SWITCHING
        // ============================================
        
        function setMode(mode) {
            currentMode = mode;
            
            document.getElementById('buildModeBtn').classList.toggle('active', mode === 'build');
            document.getElementById('liveViewModeBtn').classList.toggle('active', mode === 'live');
            document.getElementById('simulateModeBtn').classList.toggle('active', mode === 'simulate');
            
            document.getElementById('buildControls').classList.toggle('hidden', mode !== 'build');
            document.getElementById('liveViewControls').classList.toggle('hidden', mode !== 'live');
            document.getElementById('simulateControls').classList.toggle('hidden', mode !== 'simulate');
            
            // Show/hide simulation stats section
            document.getElementById('simStatsSection').style.display = mode === 'simulate' ? 'block' : 'none';
            
            if (mode === 'live') {
                // Initialize live view mode
                LiveView.initialize();
            } else if (mode === 'simulate') {
                // Check if system is valid for simulation
                const controller = allItems.find(i => i.type === 'controller');
                if (controller) {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    
                    if (arraySpecs.wmp === 0 || batterySpecs.kWh === 0) {
                        showHint("âš ï¸ Incomplete System", 
                            "Your system needs connected solar panels and batteries to simulate. " +
                            "Go back to Build mode and complete the connections.");
                        return;
                    }
                    
                    // Store specs in localStorage for the simulator to read
                    const systemSpecs = {
                        arrayWmp: arraySpecs.wmp,
                        arrayVoc: arraySpecs.voc,
                        arrayImp: arraySpecs.imp,
                        arrayConfig: arraySpecs.config,
                        batteryKwh: batterySpecs.kWh,
                        batteryVoltage: batterySpecs.voltage,
                        controllerMaxWatts: getMaxWattsForController(controller, batterySpecs.voltage),
                        controllerMaxIsc: controller.specs.maxIsc,
                        // Convert Wmp to kW for the simulator's ratedOutput
                        solarRatedKw: arraySpecs.wmp / 1000
                    };
                    localStorage.setItem('solarBuilderSpecs', JSON.stringify(systemSpecs));
                    
                    // Navigate to the simulator in the same window
                    window.location.href = 'simulator.html?fromBuilder=true';
                    
                    // Reset mode back to build
                    setMode('build');
                    return;
                }
            } else {
                // Stop simulation when switching to build mode
                if (isPlaying) {
                    playPause();
                }
                // Stop live view animation when switching away
                LiveView.stop();
            }
        }
        
        
        function initializeSimulationFromBuild() {
            resetSimulation();
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            
            // Store the built system specs for simulation
            simStats.systemSpecs = {
                arrayWmp: arraySpecs.wmp,
                arrayVoc: arraySpecs.voc,
                arrayImp: arraySpecs.imp,
                arrayConfig: arraySpecs.config,
                batteryKwh: batterySpecs.kWh,
                batteryVoltage: batterySpecs.voltage,
                controllerMaxWatts: getMaxWattsForController(controller, batterySpecs.voltage),
                controllerMaxIsc: controller.specs.maxIsc
            };
            
            // Initialize battery charge to 20% (morning scenario)
            simStats.maxBatteryCapacity = batterySpecs.kWh;
            simStats.batteryCharge = batterySpecs.kWh * 0.2;
            
            updateSimulationDisplay();
        }
        
        function showSimulationStartHint(arraySpecs, batterySpecs) {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const maxWatts = controller ? getMaxWattsForController(controller, batterySpecs.voltage) : 0;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5bc0de;">â–¶ Simulation Started!</h3>
                        <p style="margin: 0 0 8px 0;">
                            Your <strong>${arraySpecs.wmp}W</strong> solar array and <strong>${batterySpecs.kWh.toFixed(2)} kWh</strong> battery are now simulating.
                        </p>
                        <p style="margin: 0; color: #aaa; font-size: 12px;">
                            Press <strong>Play</strong> to start time progression. Watch your battery charge during the day and discharge at night.
                            Use the speed slider to fast-forward through days.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(91, 192, 222, 0.2); border-radius: 8px; text-align: center; min-width: 110px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">SYSTEM</div>
                        <div style="font-size: 16px; font-weight: bold; color: #5bc0de;">${arraySpecs.config || '1P1S'}</div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">${arraySpecs.wmp}W / ${batterySpecs.kWh.toFixed(1)}kWh</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">BATTERY</div>
                            <div style="font-size: 14px; color: #5cb85c;">20%</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // ============================================
        // SIMULATION
        // ============================================
        
        // Simulation stats
        let simStats = {
            totalSolarGenerated: 0,
            totalEnergyUsed: 0,
            batteryCharge: 0,
            maxBatteryCapacity: 0,
            peakPower: 0
        };
        
        function getSolarIrradiance(hourOfDay) {
            // Simplified solar curve: peaks at noon (hour 12)
            // Returns 0-1 multiplier for solar output
            if (hourOfDay < 6 || hourOfDay > 18) return 0;
            
            // Sinusoidal curve from 6am to 6pm
            const dayProgress = (hourOfDay - 6) / 12; // 0 to 1 over daylight hours
            return Math.sin(dayProgress * Math.PI);
        }
        
        function updateTimeDisplay() {
            const totalHours = Math.floor(elapsedHours);
            const day = Math.floor(totalHours / 24) + 1;
            const hour = totalHours % 24;
            document.getElementById('timeDisplay').textContent = 
                `${totalHours} hours (Day ${day}, ${String(hour).padStart(2, '0')}:00)`;
        }
        
        function playPause() {
            isPlaying = !isPlaying;
            document.getElementById('playPauseButton').textContent = isPlaying ? 'â¸' : 'â–¶';
            
            if (isPlaying) {
                lastTimestamp = performance.now();
                animationFrameId = requestAnimationFrame(simulationLoop);
            } else if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }
        
        function simulationLoop(timestamp) {
            if (!isPlaying) return;
            
            const delta = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            
            // Advance simulation (1 real second = simulationSpeed hours)
            const hoursToAdvance = delta * simulationSpeed;
            elapsedHours += hoursToAdvance;
            
            // Update simulation state
            simulateStep(hoursToAdvance);
            
            updateTimeDisplay();
            updateSimulationDisplay();
            animationFrameId = requestAnimationFrame(simulationLoop);
        }
        
        function simulateStep(hours) {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            // Use stored specs if available, otherwise calculate
            const specs = simStats.systemSpecs || {};
            const arrayWmp = specs.arrayWmp || calculateConnectedArraySpecs(controller).wmp;
            const batteryKwh = specs.batteryKwh || calculateConnectedBatterySpecs(controller).kWh;
            const controllerMaxWatts = specs.controllerMaxWatts || 9999;
            
            if (arrayWmp === 0 || batteryKwh === 0) return;
            
            // Get current hour of day
            const hourOfDay = Math.floor(elapsedHours) % 24;
            const irradiance = getSolarIrradiance(hourOfDay);
            
            // Calculate solar generation this step (kWh)
            // Apply controller clipping if array exceeds controller max watts
            const rawSolarPowerKw = (arrayWmp / 1000) * irradiance;
            const maxControllerPowerKw = controllerMaxWatts / 1000;
            const effectiveSolarPowerKw = Math.min(rawSolarPowerKw, maxControllerPowerKw);
            const solarGeneratedKwh = effectiveSolarPowerKw * hours;
            
            // Track clipping
            if (rawSolarPowerKw > maxControllerPowerKw && irradiance > 0.5) {
                simStats.clippedEnergy = (simStats.clippedEnergy || 0) + (rawSolarPowerKw - effectiveSolarPowerKw) * hours;
            }
            
            // Update battery
            simStats.maxBatteryCapacity = batteryKwh;
            const previousCharge = simStats.batteryCharge;
            
            // Add solar to battery (capped at capacity)
            simStats.batteryCharge = Math.min(
                simStats.maxBatteryCapacity,
                simStats.batteryCharge + solarGeneratedKwh
            );
            
            // Track actual captured energy (what went into battery)
            const actualCaptured = simStats.batteryCharge - previousCharge;
            simStats.totalSolarGenerated += actualCaptured;
            
            // Track peak power (effective, after clipping)
            if (effectiveSolarPowerKw > simStats.peakPower) {
                simStats.peakPower = effectiveSolarPowerKw;
            }
            
            // Simulate base load (0.5 kW average consumption)
            const baseLoadKwh = 0.5 * hours;
            simStats.batteryCharge = Math.max(0, simStats.batteryCharge - baseLoadKwh);
            simStats.totalEnergyUsed += baseLoadKwh;
        }
        
        function updateSimulationDisplay() {
            // Update K_micro in real-time
            // K_micro = 0.1 * (energy_used / energy_incident)
            // For simulation, we track captured vs possible
            const totalIncident = simStats.totalSolarGenerated + simStats.totalEnergyUsed; // Simplified
            const kMicro = totalIncident > 0 ? 0.1 * (simStats.totalSolarGenerated / Math.max(1, totalIncident * 2)) : 0;
            document.getElementById('scoreKMicro').textContent = kMicro.toFixed(4);
            
            // Update simulation stats display
            document.getElementById('simSolarGenerated').textContent = simStats.totalSolarGenerated.toFixed(2) + ' kWh';
            document.getElementById('simEnergyUsed').textContent = simStats.totalEnergyUsed.toFixed(2) + ' kWh';
            
            const chargePercent = simStats.maxBatteryCapacity > 0 
                ? (simStats.batteryCharge / simStats.maxBatteryCapacity) * 100 
                : 0;
            const chargeEl = document.getElementById('simBatteryCharge');
            chargeEl.textContent = chargePercent.toFixed(0) + '%';
            chargeEl.classList.remove('good', 'warning', 'error');
            if (chargePercent >= 50) chargeEl.classList.add('good');
            else if (chargePercent >= 20) chargeEl.classList.add('warning');
            else chargeEl.classList.add('error');
            
            document.getElementById('simPeakPower').textContent = simStats.peakPower.toFixed(2) + ' kW';
        }
        
        function resetSimulation() {
            elapsedHours = 0;
            simStats = {
                totalSolarGenerated: 0,
                totalEnergyUsed: 0,
                batteryCharge: 0,
                maxBatteryCapacity: 0,
                peakPower: 0
            };
            
            // Initialize battery charge to 50%
            const controller = allItems.find(i => i.type === 'controller');
            if (controller) {
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                simStats.maxBatteryCapacity = batterySpecs.kWh;
                simStats.batteryCharge = batterySpecs.kWh * 0.5;
            }
            
            updateTimeDisplay();
        }
        
        // ============================================
        // LAUNCH SIMULATOR
        // ============================================
        
        function launchSimulator() {
            const controllers = allItems.filter(i => i.type === 'controller');
            if (controllers.length === 0) {
                showHint("âš ï¸ No Controller", "Add a charge controller to your system before simulating.");
                return;
            }
            
            // Aggregate specs from ALL controllers (for hub-connected systems)
            let totalWmp = 0;
            let maxVoc = 0;
            let totalImp = 0;
            let totalBatteryKwh = 0;
            let totalMaxWatts = 0;
            let totalMaxIsc = 0;
            let configs = [];
            let batteryVoltage = 0;
            
            controllers.forEach(ctrl => {
                const arraySpecs = calculateConnectedArraySpecs(ctrl);
                const batterySpecs = calculateConnectedBatterySpecs(ctrl);
                totalWmp += arraySpecs.wmp;
                maxVoc = Math.max(maxVoc, arraySpecs.voc);
                totalImp += arraySpecs.imp || 0;
                totalBatteryKwh += batterySpecs.kWh;
                totalMaxWatts += getMaxWattsForController(ctrl, batterySpecs.voltage);
                totalMaxIsc += ctrl.specs.maxIsc;
                if (arraySpecs.config && arraySpecs.config !== '-') {
                    configs.push(arraySpecs.config);
                }
                if (batterySpecs.voltage > 0) {
                    batteryVoltage = batterySpecs.voltage;
                }
            });
            
            if (totalWmp === 0 || totalBatteryKwh === 0) {
                showHint("âš ï¸ Incomplete System", 
                    "Your system needs connected solar panels and batteries to simulate. Complete the connections first.");
                return;
            }
            
            // Store specs in localStorage for the simulator to read
            const systemSpecs = {
                arrayWmp: totalWmp,
                arrayVoc: maxVoc,
                arrayImp: totalImp,
                arrayConfig: configs.length > 0 ? configs.join(' + ') : '-',
                batteryKwh: totalBatteryKwh,
                batteryVoltage: batteryVoltage,
                controllerMaxWatts: totalMaxWatts,
                controllerMaxIsc: totalMaxIsc,
                solarRatedKw: totalWmp / 1000,
                // Export AC loads with their behavior data
                loads: allItems.filter(i => i.type === 'acload').map(load => ({
                    name: load.specs.name,
                    icon: load.specs.icon,
                    voltage: load.specs.voltage,
                    maxWatts: load.specs.maxWatts,
                    avgWatts: load.specs.avgWatts,
                    behavior: load.specs.behavior
                }))
            };
            localStorage.setItem('solarBuilderSpecs', JSON.stringify(systemSpecs));
            
            // Save the current builder state for returning later
            const builderState = {
                items: allItems,
                connections: connections,
                itemIdCounter: itemIdCounter,
                connectionIdCounter: connectionIdCounter
            };
            localStorage.setItem('solarBuilderState', JSON.stringify(builderState));
            
            // Navigate to the simulator in the same window
            window.location.href = 'simulator.html?fromBuilder=true';
        }
        
        // ============================================
        // SAVE/LOAD
        // ============================================
        
        function saveSystem() {
            const data = {
                items: allItems,
                connections: connections,
                version: 1
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-system-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadSystem() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        allItems = data.items || [];
                        connections = data.connections || [];
                        
                        // Initialize wire properties for old connections that don't have them
                        connections.forEach(conn => {
                            if (!conn.wireGauge) {
                                updateWireGaugeForConnection(conn);
                                // If still no length, estimate it
                                if (!conn.estimatedLength) {
                                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                                    if (sourceItem && targetItem) {
                                        const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                                        const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                                        if (sourceHandle && targetHandle) {
                                            conn.estimatedLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
                                            conn.costPerFoot = WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
                                            conn.totalWireCost = conn.estimatedLength * conn.costPerFoot;
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Update ID counters
                        itemIdCounter = Math.max(0, ...allItems.map(i => parseInt(i.id.split('-')[1]) || 0));
                        connectionIdCounter = Math.max(0, ...connections.map(c => parseInt(c.id.split('-')[1]) || 0));
                        
                        render();
                    } catch (err) {
                        alert('Error loading file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // ============================================
        // DEFAULT LAYOUT
        // ============================================
        
        function setupDefaultLayout() {
            // Reset tutorial state
            tutorialStep = 0;
            tutorialCompleted = false;
            connectedSolarFirst = false;
            seriesHintShown = false;
            optimalArrayHintShown = false;
            lastConnectedArrayWmp = 0;
            systemValidated = false;
            
            // Calculate center position based on actual canvas dimensions
            const centerX = svgWidth / 2;
            const startY = svgHeight / 2 - 150;
            
            // Create components in a vertical column: panel on top, controller middle, battery bottom
            const panel = createPanel(centerX - PANEL_WIDTH / 2, startY, PANEL_PRESETS[0]);
            const controller = createController(centerX - CONTROLLER_WIDTH / 2, startY + 120, CONTROLLER_PRESETS[0]);
            const battery = createBattery(centerX - BATTERY_WIDTH / 2, startY + 260, BATTERY_PRESETS[0]);
            
            allItems.push(panel, controller, battery);
            
            render();
            
            // Start tutorial after a short delay
            setTimeout(() => {
                startTutorial();
            }, 800);
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            updateSvgDimensions();
            populateLibraries();
            
            // Check if returning from simulator with saved state
            const savedState = localStorage.getItem('solarBuilderState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    allItems = state.items || [];
                    connections = state.connections || [];
                    itemIdCounter = state.itemIdCounter || 0;
                    connectionIdCounter = state.connectionIdCounter || 0;
                    
                    // Rebuild handle.connectedTo arrays from connections
                    // (these don't serialize properly with circular refs)
                    allItems.forEach(item => {
                        Object.values(item.handles).forEach(h => h.connectedTo = []);
                    });
                    connections.forEach(conn => {
                        const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                        const targetItem = allItems.find(i => i.id === conn.targetItemId);
                        if (sourceItem && targetItem) {
                            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                            const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                            if (sourceHandle && targetHandle) {
                                sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
                                targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
                            }
                        }
                    });
                    
                    // Skip tutorial if returning with existing design
                    tutorialCompleted = true;
                    systemValidated = true;
                    
                    render();
                    // Don't remove state - keep it for future returns
                } catch (e) {
                    console.error('Failed to restore builder state:', e);
                    setupDefaultLayout();
                }
            } else {
                setupDefaultLayout();
            }
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    // Don't delete if user is typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (selectedItem) {
                        deleteItem(selectedItem.id);
                        e.preventDefault();
                    } else if (selectedConnection) {
                        deleteConnection(selectedConnection.id);
                        closeInspector();
                        e.preventDefault();
                    }
                }
            });
            
            // Mode toggle
            document.getElementById('buildModeBtn').addEventListener('click', () => setMode('build'));
            document.getElementById('liveViewModeBtn').addEventListener('click', () => setMode('live'));
            document.getElementById('simulateModeBtn').addEventListener('click', () => setMode('simulate'));
            
            // Live view controls
            document.getElementById('resetAllLoadsBtn').addEventListener('click', () => {
                Object.keys(liveViewLoadStates).forEach(loadId => {
                    LiveView.state.loadStates[loadId] = false;
                });
                render();
            });
            
            document.getElementById('resetAllBreakersBtn').addEventListener('click', () => {
                // Reset regular AC breakers
                allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker').forEach(breaker => {
                    breaker.isClosed = true;
                    LiveView.state.breakerStates[breaker.id] = { isClosed: true, wasTripped: false };
                });
                
                // Reset breaker panel circuits
                allItems.filter(i => i.type === 'breakerpanel').forEach(panel => {
                    // Reset main breaker
                    panel.mainBreakerOn = true;
                    
                    // Reset all circuit breakers
                    if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                    for (let i = 0; i < 8; i++) {
                        panel.breakerStates[i] = true;
                        const breakerId = `${panel.id}-circuit-${i + 1}`;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                });
                
                // Reset spiderbox (CEP box) circuit breakers
                allItems.filter(i => i.type === 'spiderbox').forEach(spiderbox => {
                    if (spiderbox.handles) {
                        Object.keys(spiderbox.handles).forEach(handleKey => {
                            const handle = spiderbox.handles[handleKey];
                            if (handle && handleKey.startsWith('circuit')) {
                                handle.isClosed = true;
                                // Sync with LiveView state
                                const circuitIndex = parseInt(handleKey.match(/circuit(\d+)/)?.[1]) - 1;
                                if (circuitIndex >= 0) {
                                    const breakerId = `${spiderbox.id}-circuit-${circuitIndex + 1}`;
                                    LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                                }
                            }
                        });
                    }
                });
                
                // Recalculate power flow after resetting all breakers
                if (LiveView.state.active) {
                    LiveView.PowerFlow.calculate();
                }
                
                render();
                
                // Refresh inspector if a load, breaker panel, or spiderbox is currently selected
                if (selectedItem) {
                    if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel' || selectedItem.type === 'spiderbox') {
                        openInspector(selectedItem);
                    }
                }
            });
            
            // Function to reset a specific tripped breaker (called from hint button)
            window.resetTrippedBreaker = function(breakerId, breakerType, panelId = null, circuitIndex = null) {
                if (breakerType === 'acbreaker') {
                    // Reset regular AC breaker
                    const breaker = allItems.find(i => i.id === breakerId && (i.type === 'acbreaker' || i.type === 'breaker'));
                    if (breaker) {
                        breaker.isClosed = true;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                } else if (breakerType === 'breakerpanel' && panelId && circuitIndex !== null) {
                    // Reset breaker panel circuit
                    const panel = allItems.find(i => i.id === panelId && i.type === 'breakerpanel');
                    if (panel) {
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        panel.breakerStates[circuitIndex] = true;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                }
                
                // Hide hint and re-render
                hideHint();
                render();
                
                // Refresh inspector if a load is currently selected (to update circuit status)
                if (selectedItem && selectedItem.type === 'acload') {
                    openInspector(selectedItem);
                }
            };
            
            // System Review button
            document.getElementById('systemReviewBtn').addEventListener('click', () => {
                showSystemReview();
            });
            
            // BOM buttons
            document.getElementById('bomCloseBtn').addEventListener('click', hideBillOfMaterials);
            document.getElementById('bomExportBtn').addEventListener('click', exportBillOfMaterials);
            
            // Build controls
            document.getElementById('addPanelBtn').addEventListener('click', () => addComponentFromPreset('panel', 0));
            document.getElementById('addBatteryBtn').addEventListener('click', () => addComponentFromPreset('battery', 0));
            document.getElementById('resetBtn').addEventListener('click', () => {
                allItems = [];
                connections = [];
                selectedItem = null;
                selectedConnection = null;
                itemIdCounter = 0;
                connectionIdCounter = 0;
                closeInspector();
                localStorage.removeItem('solarBuilderState'); // Clear saved state on reset
                setupDefaultLayout();
            });
            
            // Simulate controls
            document.getElementById('playPauseButton').addEventListener('click', playPause);
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                simulationSpeed = parseInt(e.target.value);
                document.getElementById('speedLabel').textContent = simulationSpeed + 'x';
            });
            
            // Simulate button
            document.getElementById('simulateBtn').addEventListener('click', launchSimulator);
            
            // Show Hints toggle - hide any visible hint when unchecked
            document.getElementById('showHintsToggle').addEventListener('change', (e) => {
                if (!e.target.checked) {
                    hideHint();
                }
            });
            
            // Save/Load
            document.getElementById('saveBtn').addEventListener('click', saveSystem);
            document.getElementById('loadBtn').addEventListener('click', loadSystem);
            
            // Sidebar toggles
            document.getElementById('left-sidebar-toggle').addEventListener('click', () => {
                document.getElementById('left-sidebar').classList.toggle('collapsed');
            });
            
            // Inspector apply buttons
            document.getElementById('applyPanelChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'panel') return;
                
                const newSpecs = {
                    name: document.getElementById('panelName').value,
                    wmp: parseFloat(document.getElementById('panelWmp').value),
                    vmp: parseFloat(document.getElementById('panelVmp').value),
                    voc: parseFloat(document.getElementById('panelVoc').value),
                    isc: parseFloat(document.getElementById('panelIsc').value),
                    cost: parseFloat(document.getElementById('panelCost').value)
                };
                
                // Apply to ALL panels
                allItems.filter(i => i.type === 'panel').forEach(p => {
                    Object.assign(p.specs, newSpecs);
                });
                
                render();
                validateSystem();
            });
            
            document.getElementById('applyBatteryChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'battery') return;
                
                const voltage = parseFloat(document.getElementById('batteryVoltage').value);
                const ah = parseFloat(document.getElementById('batteryAh').value);
                
                const newSpecs = {
                    name: document.getElementById('batteryName').value,
                    voltage,
                    ah,
                    maxDischarge: parseFloat(document.getElementById('batteryMaxDischarge').value),
                    cost: parseFloat(document.getElementById('batteryCost').value),
                    kWh: (voltage * ah) / 1000
                };
                
                // Apply to ALL batteries
                allItems.filter(i => i.type === 'battery').forEach(b => {
                    Object.assign(b.specs, newSpecs);
                });
                
                render();
                validateSystem();
            });
            
            document.getElementById('applyControllerChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'controller') return;
                
                const newType = document.getElementById('controllerType').value;
                const oldType = selectedItem.specs.type;
                
                selectedItem.specs.name = document.getElementById('controllerName').value;
                selectedItem.specs.type = newType;
                selectedItem.subtype = newType;
                selectedItem.specs.maxVoc = parseFloat(document.getElementById('controllerMaxVoc').value);
                selectedItem.specs.minVmp = parseFloat(document.getElementById('controllerMinVmp').value) || 0;
                selectedItem.specs.mppVoltageMin = parseFloat(document.getElementById('controllerMppMin').value) || 0;
                selectedItem.specs.mppVoltageMax = parseFloat(document.getElementById('controllerMppMax').value) || selectedItem.specs.maxVoc;
                selectedItem.specs.maxIsc = parseFloat(document.getElementById('controllerMaxIsc').value);
                selectedItem.specs.maxWmp = parseFloat(document.getElementById('controllerMaxWmp').value);
                selectedItem.specs.ratedChargeCurrent = parseFloat(document.getElementById('controllerChargeCurrent').value);
                selectedItem.specs.cost = parseFloat(document.getElementById('controllerCost').value);
                
                // Get supported voltages from checkboxes
                const supportedVoltages = [];
                if (document.getElementById('controllerV12').checked) supportedVoltages.push(12);
                if (document.getElementById('controllerV24').checked) supportedVoltages.push(24);
                if (document.getElementById('controllerV36').checked) supportedVoltages.push(36);
                if (document.getElementById('controllerV48').checked) supportedVoltages.push(48);
                selectedItem.specs.supportedVoltages = supportedVoltages.length > 0 ? supportedVoltages : [12];
                
                // Handle AC output for hybrid inverters
                const isHybrid = newType === 'hybrid_inverter' || newType === 'all_in_one';
                const wasHybrid = oldType === 'hybrid_inverter' || oldType === 'all_in_one';
                
                if (isHybrid) {
                    selectedItem.specs.maxACOutputW = parseFloat(document.getElementById('controllerACOutputW').value) || 0;
                    // Add AC output handle if it doesn't exist
                    if (!selectedItem.handles.acOutput) {
                        selectedItem.handles.acOutput = { 
                            id: `${selectedItem.id}-ac-out`, 
                            polarity: 'ac', 
                            x: selectedItem.width + 5, 
                            y: selectedItem.height * 0.5, 
                            side: 'right', 
                            connectedTo: [] 
                        };
                    }
                } else {
                    // Remove AC output handle if switching from hybrid to non-hybrid
                    if (wasHybrid && selectedItem.handles.acOutput) {
                        // Delete any connections to this handle
                        const acHandleId = selectedItem.handles.acOutput.id;
                        const connToDelete = connections.filter(c => 
                            c.sourceHandleId === acHandleId || c.targetHandleId === acHandleId
                        );
                        connToDelete.forEach(c => deleteConnection(c.id));
                        delete selectedItem.handles.acOutput;
                        delete selectedItem.specs.maxACOutputW;
                    }
                }
                
                render();
                validateSystem();
            });
            
            // Toggle AC output visibility when controller type changes
            document.getElementById('controllerType').addEventListener('change', (e) => {
                const isHybrid = e.target.value === 'hybrid_inverter' || e.target.value === 'all_in_one';
                document.getElementById('controllerACOutput').classList.toggle('hidden', !isHybrid);
            });
            
            document.getElementById('deleteWire').addEventListener('click', () => {
                if (selectedConnection) {
                    deleteConnection(selectedConnection.id);
                    closeInspector();
                }
            });
            
            // Add breaker to wire
            document.getElementById('addBreakerToWire').addEventListener('click', () => {
                if (!selectedConnection) return;
                
                const conn = selectedConnection;
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                if (!sourceItem || !targetItem) return;
                
                // Calculate expected current and auto-size breaker
                const expectedCurrent = calculateWireCurrent(conn);
                const breakerRating = autosizeBreaker(expectedCurrent > 0 ? expectedCurrent : 10);
                const breakerPreset = BREAKER_PRESETS.find(b => b.rating >= breakerRating) || BREAKER_PRESETS[1];
                
                // Position breaker between source and target
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                const midX = (sourceItem.x + sourceHandle.x + targetItem.x + targetHandle.x) / 2 - BREAKER_WIDTH / 2;
                const midY = (sourceItem.y + sourceHandle.y + targetItem.y + targetHandle.y) / 2 - BREAKER_HEIGHT / 2;
                
                // Create breaker
                const breaker = createBreaker(midX, midY, breakerPreset);
                allItems.push(breaker);
                
                // Delete old connection
                deleteConnection(conn.id);
                
                // Create new connections through breaker
                // Source -> Breaker Line
                const sourceHandleObj = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                const breakerLineHandle = sourceHandleObj.polarity === 'positive' || sourceHandleObj.polarity === 'pv-positive' 
                    ? breaker.handles.linePositive : breaker.handles.lineNegative;
                createConnection(sourceItem, sourceHandleObj, breaker, breakerLineHandle);
                
                // Breaker Load -> Target
                const targetHandleObj = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                const breakerLoadHandle = targetHandleObj.polarity === 'positive' || targetHandleObj.polarity === 'pv-positive'
                    ? breaker.handles.loadPositive : breaker.handles.loadNegative;
                createConnection(breaker, breakerLoadHandle, targetItem, targetHandleObj);
                
                closeInspector();
                render();
                showHint("ðŸ”Œ Breaker Added", `A ${breakerPreset.rating}A breaker has been added to protect this circuit.`);
            });
            
            // Breaker inspector buttons
            document.getElementById('toggleBreaker').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                selectedItem.isClosed = !selectedItem.isClosed;
                openInspector(selectedItem); // Refresh inspector
                render();
            });
            
            document.getElementById('applyBreakerChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                selectedItem.specs.rating = parseInt(document.getElementById('breakerRating').value);
                selectedItem.specs.maxVoltage = parseFloat(document.getElementById('breakerMaxVoltage').value);
                selectedItem.specs.cost = parseFloat(document.getElementById('breakerCost').value);
                render();
            });
            
            document.getElementById('autosizeBreaker').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                
                // Find connections to this breaker and calculate expected current
                const breakerConns = connections.filter(c => 
                    c.sourceItemId === selectedItem.id || c.targetItemId === selectedItem.id
                );
                
                let maxCurrent = 0;
                breakerConns.forEach(conn => {
                    const current = calculateWireCurrent(conn);
                    if (current > maxCurrent) maxCurrent = current;
                });
                
                if (maxCurrent > 0) {
                    const newRating = autosizeBreaker(maxCurrent);
                    selectedItem.specs.rating = newRating;
                    document.getElementById('breakerRating').value = newRating;
                    render();
                    showHint("âš¡ Breaker Auto-Sized", `Breaker sized to ${newRating}A based on expected ${maxCurrent.toFixed(1)}A current.`);
                } else {
                    showHint("âš ï¸ Cannot Auto-Size", "Connect the breaker to a circuit first to auto-size based on expected current.");
                }
            });
            
            // Combiner inspector
            document.getElementById('applyCombinerChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'combiner') return;
                selectedItem.specs.maxAmpsPerInput = parseFloat(document.getElementById('combinerMaxAmps').value);
                selectedItem.specs.cost = parseFloat(document.getElementById('combinerCost').value);
                render();
            });
            
            // Solar Combiner inspector
            document.getElementById('applySolarCombinerChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'solarcombiner') return;
                selectedItem.specs.breakerRating = parseInt(document.getElementById('solarCombinerBreakerRating').value);
                selectedItem.specs.maxVoltage = parseFloat(document.getElementById('solarCombinerMaxVoltage').value);
                selectedItem.specs.cost = parseFloat(document.getElementById('solarCombinerCost').value);
                render();
            });
            
            // Spider Box inspector
            document.getElementById('applySpiderboxChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                selectedItem.specs.cost = parseFloat(document.getElementById('spiderboxCost').value);
                render();
            });
            document.getElementById('spiderboxAllOn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                selectedItem.specs.circuits.forEach((_, i) => {
                    selectedItem.handles[`circuit${i + 1}`].isClosed = true;
                    // Sync with LiveView state
                    const breakerId = `${selectedItem.id}-circuit-${i + 1}`;
                    LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                });
                openInspector(selectedItem);
                render();
            });
            document.getElementById('spiderboxAllOff').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                selectedItem.specs.circuits.forEach((_, i) => {
                    selectedItem.handles[`circuit${i + 1}`].isClosed = false;
                    // Sync with LiveView state
                    const breakerId = `${selectedItem.id}-circuit-${i + 1}`;
                    LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: false };
                });
                openInspector(selectedItem);
                render();
            });
            
            // Breaker Panel inspector
            document.getElementById('applyBreakerpanelChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breakerpanel') return;
                selectedItem.specs.cost = parseFloat(document.getElementById('breakerpanelCost').value);
                render();
            });
            document.getElementById('breakerpanelAllOn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breakerpanel') return;
                selectedItem.breakerStates = selectedItem.breakerStates.map(() => true);
                // Sync with LiveView state if in live view mode
                if (LiveView.state.active) {
                    for (let i = 0; i < 8; i++) {
                        const breakerId = `${selectedItem.id}-circuit-${i + 1}`;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                }
                openInspector(selectedItem);
                render();
            });
            document.getElementById('breakerpanelAllOff').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breakerpanel') return;
                selectedItem.breakerStates = selectedItem.breakerStates.map(() => false);
                // Sync with LiveView state if in live view mode
                if (LiveView.state.active) {
                    for (let i = 0; i < 8; i++) {
                        const breakerId = `${selectedItem.id}-circuit-${i + 1}`;
                        LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: false };
                    }
                }
                openInspector(selectedItem);
                render();
            });
            
            // AC Load inspector
            document.getElementById('loadPreset').addEventListener('change', (e) => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                const preset = APPLIANCE_PRESETS[parseInt(e.target.value)];
                selectedItem.specs.name = preset.name;
                selectedItem.specs.voltage = preset.voltage;
                selectedItem.specs.maxWatts = preset.maxWatts;
                selectedItem.specs.avgWatts = preset.avgWatts;
                selectedItem.specs.icon = preset.icon;
                // Deep copy behavior
                selectedItem.specs.behavior = preset.behavior ? JSON.parse(JSON.stringify(preset.behavior)) : { type: 'constant' };
                openInspector(selectedItem);
                render();
            });
            
            // Behavior type change
            document.getElementById('loadBehaviorType').addEventListener('change', (e) => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                const newType = e.target.value;
                
                // Initialize behavior with defaults for the new type
                if (newType === 'constant') {
                    selectedItem.specs.behavior = { type: 'constant' };
                } else if (newType === 'scheduled') {
                    selectedItem.specs.behavior = { type: 'scheduled', schedule: { onTrigger: 'sunset', offTrigger: 'sunrise' } };
                } else if (newType === 'batch') {
                    selectedItem.specs.behavior = { type: 'batch', recipes: [] };
                } else if (newType === 'thermostat') {
                    selectedItem.specs.behavior = { type: 'thermostat', setpoint: 72, deadband: 2, dutyPercent: 50 };
                } else if (newType === 'charging') {
                    selectedItem.specs.behavior = { type: 'charging', batteryKwh: 1, chargeRateKw: 0.5, dailyDepletionKwh: 0.5 };
                }
                openInspector(selectedItem);
            });
            
            // Add recipe button
            document.getElementById('addRecipeBtn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                if (!selectedItem.specs.behavior) selectedItem.specs.behavior = { type: 'batch', recipes: [] };
                if (!selectedItem.specs.behavior.recipes) selectedItem.specs.behavior.recipes = [];
                
                // Prompt for recipe details (simple approach)
                const name = prompt('Recipe name:', 'New Recipe');
                if (!name) return;
                const inputs = prompt('Inputs (what goes in):', 'raw material');
                const outputs = prompt('Outputs (what comes out):', 'finished product');
                const energyWh = parseFloat(prompt('Energy per batch (Wh):', '100')) || 100;
                const durationMin = parseFloat(prompt('Duration (minutes):', '10')) || 10;
                const batchesPerDay = parseFloat(prompt('Batches per day:', '1')) || 1;
                
                selectedItem.specs.behavior.recipes.push({
                    name, inputs, outputs, energyWh, durationMin, batchesPerDay
                });
                populateRecipeList(selectedItem);
                render();
            });
            
            document.getElementById('applyLoadChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                selectedItem.specs.name = document.getElementById('loadName').value;
                selectedItem.specs.voltage = parseInt(document.getElementById('loadVoltage').value);
                selectedItem.specs.maxWatts = parseFloat(document.getElementById('loadMaxWatts').value) || 0;
                selectedItem.specs.icon = document.getElementById('loadIcon').value || 'âš¡';
                
                // Save behavior-specific fields
                const behaviorType = document.getElementById('loadBehaviorType').value;
                if (behaviorType === 'constant') {
                    selectedItem.specs.avgWatts = parseFloat(document.getElementById('loadAvgWatts').value) || 0;
                    selectedItem.specs.behavior = { type: 'constant' };
                } else if (behaviorType === 'scheduled') {
                    selectedItem.specs.behavior = {
                        type: 'scheduled',
                        schedule: {
                            onTrigger: document.getElementById('scheduleOn').value,
                            offTrigger: document.getElementById('scheduleOff').value
                        }
                    };
                    // Calculate avg watts based on schedule (rough estimate)
                    selectedItem.specs.avgWatts = selectedItem.specs.maxWatts * 0.5; // Assume ~12hr on
                } else if (behaviorType === 'batch') {
                    // Recipes are already saved directly, calculate avgWatts from daily total
                    const recipes = selectedItem.specs.behavior?.recipes || [];
                    const dailyWh = recipes.reduce((sum, r) => sum + (r.energyWh * r.batchesPerDay), 0);
                    selectedItem.specs.avgWatts = dailyWh / 24; // Wh/day / 24h = avg watts
                } else if (behaviorType === 'thermostat') {
                    selectedItem.specs.behavior = {
                        type: 'thermostat',
                        setpoint: parseFloat(document.getElementById('thermostatSetpoint').value) || 72,
                        deadband: parseFloat(document.getElementById('thermostatDeadband').value) || 2,
                        dutyPercent: parseFloat(document.getElementById('thermostatDuty').value) || 50
                    };
                    // Calculate avg watts from duty cycle
                    selectedItem.specs.avgWatts = selectedItem.specs.maxWatts * (selectedItem.specs.behavior.dutyPercent / 100);
                } else if (behaviorType === 'charging') {
                    selectedItem.specs.behavior = {
                        type: 'charging',
                        batteryKwh: parseFloat(document.getElementById('chargingBatteryKwh').value) || 0,
                        chargeRateKw: parseFloat(document.getElementById('chargingRateKw').value) || 0,
                        dailyDepletionKwh: parseFloat(document.getElementById('chargingDailyUse').value) || 0
                    };
                    // Avg watts = daily energy replenishment / 24h
                    selectedItem.specs.avgWatts = (selectedItem.specs.behavior.dailyDepletionKwh * 1000) / 24;
                }
                render();
            });
            
            // Hint dismiss - use event delegation so it works even after innerHTML replacement
            const hintPopup = document.getElementById('hintPopup');
            if (hintPopup) {
                hintPopup.addEventListener('click', (e) => {
                    if (e.target && (e.target.id === 'hintDismiss' || e.target.textContent === 'Got it!' || e.target.textContent === 'Got it')) {
                        hideHint();
                    }
                });
            }
            
            // Achievement close
            document.getElementById('achievementClose').addEventListener('click', hideAchievement);
            document.getElementById('startSimulation').addEventListener('click', () => {
                hideAchievement();
                launchSimulator();
            });
            
            // Canvas click to deselect
            svg.on("click", () => {
                deselectAll();
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                updateSvgDimensions();
            });
        });
    </script>
</body>
</html>

