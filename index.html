<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval'; script-src * 'unsafe-inline' 'unsafe-eval'; connect-src * 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; frame-src *; style-src * 'unsafe-inline';">
    <title>Solar Builder & Simulator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* ============================================
           SOLAR BUILDER & SIMULATOR - UNIFIED STYLES
           CSS Variables & Consolidated Classes
           ============================================ */
        
        :root {
            /* Primary Colors */
            --clr-primary: #ffdd57;
            --clr-primary-light: #ffed87;
            --clr-primary-dark: #e6c547;
            --clr-primary-rgb: 255, 221, 87;
            
            /* Semantic Colors */
            --clr-success: #5cb85c;
            --clr-success-rgb: 92, 184, 92;
            --clr-danger: #d9534f;
            --clr-danger-rgb: 217, 83, 79;
            --clr-warning: #f0ad4e;
            --clr-warning-rgb: 240, 173, 78;
            --clr-info: #5bc0de;
            --clr-info-rgb: 91, 192, 222;
            
            /* Backgrounds */
            --bg-body: #2d2d2d;
            --bg-sidebar: #3a3a3a;
            --bg-input: #4a4a4a;
            --bg-canvas: #1a2b3c;
            --bg-toolbar: linear-gradient(135deg, #1a2b3c 0%, #2a3b4c 100%);
            
            /* Borders */
            --border-light: #555;
            --border-med: #666;
            --border-dark: #777;
            
            /* Text Colors */
            --text-primary: #e8e8e8;
            --text-secondary: #ccc;
            --text-muted: #aaa;
            --text-dim: #888;
            
            /* Spacing */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-med: 0.3s ease;
        }
        
        * { box-sizing: border-box; }
        
        body { 
            font-family: Arial, sans-serif; 
            background-color: var(--bg-body); 
            color: var(--text-primary); 
            margin: 0; padding: 0; 
            overflow: hidden; 
            display: flex; flex-direction: column; 
            height: 100vh;
        }
        
        .hidden { display: none !important; }
        
        /* ============================================
           TOOLBAR
           ============================================ */
        .toolbar { 
            background: var(--bg-toolbar);
            border-bottom: 3px solid var(--clr-primary);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            padding: 12px 20px; 
            display: flex; gap: 15px; 
            align-items: center; justify-content: space-between;
            flex-shrink: 0; z-index: 1001; position: relative;
        }
        
        .toolbar-left, .toolbar-center, .toolbar-right {
            display: flex; align-items: center; flex-wrap: nowrap;
        }
        .toolbar-left { gap: 15px; flex: 0 0 auto; }
        .toolbar-center { gap: 15px; flex: 1 1 auto; justify-content: center; min-width: 0; }
        .toolbar-center .mode-toggle { order: -1; flex-shrink: 0; z-index: 10; }
        .toolbar-right { gap: 10px; flex: 0 0 auto; }
        
        /* Base button styles */
        .toolbar button { 
            padding: 8px 14px; 
            background: rgba(0,0,0,0.3);
            color: #fff; 
            border: 2px solid rgba(var(--clr-primary-rgb), 0.3); 
            border-radius: var(--radius-md); 
            cursor: pointer; 
            font-size: 0.9em; font-weight: 600;
            transition: all var(--transition-med);
            white-space: nowrap;
        }
        .toolbar button:hover { 
            background: rgba(0,0,0,0.5);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--clr-primary-rgb), 0.3);
        }
        .toolbar button.active {
            background: rgba(var(--clr-primary-rgb), 0.3);
            border-color: var(--clr-primary);
        }
        
        /* Mode toggle group */
        .toolbar .mode-toggle {
            display: flex !important; gap: 0;
            border-radius: var(--radius-md); overflow: hidden;
            flex-shrink: 0; visibility: visible !important;
        }
        .toolbar .mode-toggle button {
            border-radius: 0; border-right: none;
            min-width: 100px; padding: 8px 16px;
        }
        .toolbar .mode-toggle button:first-child { border-radius: var(--radius-md) 0 0 var(--radius-md); }
        .toolbar .mode-toggle button:last-child { 
            border-radius: 0 var(--radius-md) var(--radius-md) 0; 
            border-right: 2px solid rgba(var(--clr-primary-rgb), 0.3); 
        }
        .toolbar .mode-toggle button.active {
            background: rgba(var(--clr-primary-rgb), 0.2);
            border-color: rgba(var(--clr-primary-rgb), 0.6);
            color: var(--clr-primary); font-weight: bold;
        }
        .toolbar .mode-toggle button:hover {
            background: rgba(var(--clr-primary-rgb), 0.15);
            color: var(--clr-primary);
        }
        
        /* Mode-specific buttons */
        #liveViewModeBtn { background: rgba(var(--clr-warning-rgb), 0.2); border-color: rgba(var(--clr-warning-rgb), 0.4); }
        #liveViewModeBtn:hover { background: rgba(var(--clr-warning-rgb), 0.3); color: var(--clr-warning); }
        #liveViewModeBtn.active { background: rgba(var(--clr-warning-rgb), 0.3); border-color: rgba(var(--clr-warning-rgb), 0.6); color: var(--clr-warning); font-weight: bold; }
        
        #simulateModeBtn { min-width: 120px; padding: 10px 20px; background: rgba(var(--clr-success-rgb), 0.25); border-color: var(--clr-success); }
        #simulateModeBtn:hover { background: rgba(var(--clr-success-rgb), 0.35); color: #e9ffe9; }
        #simulateModeBtn.active { background: rgba(var(--clr-success-rgb), 0.45); color: #e9ffe9; box-shadow: 0 0 10px rgba(var(--clr-success-rgb), 0.7); }

        .system-review-button {
            background: linear-gradient(135deg, rgba(var(--clr-info-rgb), 0.6), rgba(0, 123, 255, 0.5));
            border: 1px solid var(--clr-info); color: #e3f7ff;
            padding: 6px 14px; border-radius: 999px;
            cursor: pointer; font-size: 12px; font-weight: 600;
            display: inline-flex; align-items: center; gap: 6px;
            box-shadow: 0 0 10px rgba(var(--clr-info-rgb), 0.6);
            text-shadow: 0 0 4px rgba(0,0,0,0.6);
        }
        .system-review-button:hover {
            background: linear-gradient(135deg, rgba(var(--clr-info-rgb), 0.8), rgba(0, 123, 255, 0.7));
            border-color: #7fd8f5; box-shadow: 0 0 14px rgba(var(--clr-info-rgb), 0.9);
        }
        
        .toolbar .time-display { 
            font-size: 1.1em; color: var(--clr-primary); font-weight: 600;
            text-shadow: 0 0 10px rgba(var(--clr-primary-rgb), 0.5);
            white-space: nowrap; display: inline-block; text-align: center;
        }
        .toolbar .weather-controls, .toolbar .zoom-controls { display: flex; align-items: center; flex-shrink: 0; white-space: nowrap; }
        .toolbar .weather-controls { gap: 10px; }
        .toolbar .zoom-controls { gap: 5px; }
        .toolbar .play-controls { display: flex; align-items: center; gap: 12px; }
        .toolbar .play-controls button#playPauseButton { font-size: 1.4em; padding: 8px 16px; min-width: 50px; }
        
        .toolbar input[type="range"] { 
            width: 150px; cursor: pointer; margin: 0;
            height: 6px; background: rgba(0,0,0,0.3);
            border-radius: 3px; outline: none;
        }
        .toolbar input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 18px; height: 18px;
            background: var(--clr-primary); border-radius: 50%;
            cursor: pointer; box-shadow: 0 0 8px rgba(var(--clr-primary-rgb), 0.6);
        }
        .toolbar .speed-label { font-size: 0.95em; color: var(--clr-primary); font-weight: 600; min-width: 45px; }
        
        /* ============================================
           MAIN CONTENT AREA
           ============================================ */
        #main-content { display: flex; flex-grow: 1; overflow: hidden; position: relative; }
        
        #canvas-container { 
            flex-grow: 1; position: relative; overflow: hidden;
            transition: background-color 1s ease-in-out;
            touch-action: none; -webkit-overflow-scrolling: touch;
        }
        
        svg {
            touch-action: none; width: 100%; height: 100%; 
            background-color: var(--bg-canvas); 
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px); 
            background-size: 35px 35px; 
            position: relative; transition: background-color 1s ease-in-out;
        }
        
        /* ============================================
           SIDEBARS (Shared Styles)
           ============================================ */
        #left-sidebar, #right-sidebar {
            background-color: var(--bg-sidebar);
            padding: 15px; padding-bottom: 80px;
            box-sizing: border-box; overflow-y: auto;
            color: var(--text-primary);
            position: fixed; top: 64px; bottom: 0;
            z-index: 1000;
        }
        #left-sidebar { width: 280px; left: 0; border-right: 1px solid var(--border-light); transition: width var(--transition-med), opacity var(--transition-med); }
        #right-sidebar { width: 320px; right: 0; border-left: 1px solid var(--border-light); transition: width var(--transition-med), transform var(--transition-med); transform: translateX(100%); }
        #right-sidebar.open { transform: translateX(0); }
        
        #left-sidebar.collapsed { width: 0 !important; padding: 0 !important; overflow: visible; border-right: none; }
        #left-sidebar.collapsed > *:not(#left-sidebar-toggle) { opacity: 0; pointer-events: none; }
        
        /* Sidebar toggle buttons */
        #left-sidebar-toggle, #right-sidebar-toggle {
            position: fixed !important; top: 50% !important;
            transform: translateY(-50%) !important;
            width: 30px !important; height: 60px !important;
            background-color: var(--bg-sidebar) !important;
            border: 1px solid var(--border-light) !important;
            cursor: pointer; display: flex !important;
            align-items: center; justify-content: center;
            color: #fff; font-size: 18px;
            z-index: 10000 !important;
            transition: background-color var(--transition-fast), left var(--transition-med), right var(--transition-med);
            pointer-events: auto !important;
        }
        #left-sidebar-toggle { left: 0 !important; border-left: none !important; border-radius: 0 var(--radius-sm) var(--radius-sm) 0 !important; box-shadow: 2px 0 8px rgba(0,0,0,0.3); }
        #right-sidebar-toggle { right: 0 !important; border-right: none !important; border-radius: var(--radius-sm) 0 0 var(--radius-sm) !important; box-shadow: -2px 0 8px rgba(0,0,0,0.3); }
        #left-sidebar-toggle:hover, #right-sidebar-toggle:hover { background-color: #4a4a4a; }
        #left-sidebar:not(.collapsed) #left-sidebar-toggle { left: 280px; }
        #right-sidebar.open #right-sidebar-toggle { right: 320px; }
        
        /* Sidebar sections */
        .sidebar-section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-light); }
        .sidebar-section:last-child { border-bottom: none; }
        .system-scores-section { position: sticky; top: 0; background: var(--bg-sidebar); z-index: 10; padding-top: 10px; margin-bottom: 12px; border-bottom: 2px solid var(--border-light); }
        .sidebar-section h3 { margin: 0 0 12px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: var(--clr-primary); }
        .sidebar-section h4 { margin: 0 0 8px 0; font-size: 12px; color: var(--text-muted); }
        .sidebar-section label { display: block; margin-bottom: 8px; font-size: 12px; color: var(--text-secondary); }
        
        /* Form controls */
        .sidebar-section input[type="text"],
        .sidebar-section input[type="number"],
        .sidebar-section select {
            width: 100%; padding: 8px;
            background-color: var(--bg-input); color: #fff;
            border: 1px solid var(--border-med); border-radius: var(--radius-sm);
            margin-top: 4px;
        }
        .sidebar-section input:focus, .sidebar-section select:focus { outline: none; border-color: var(--clr-primary); }
        
        .sidebar-section button {
            padding: 8px 12px; background-color: #555; color: #fff;
            border: 1px solid var(--border-dark); border-radius: var(--radius-sm);
            cursor: pointer; margin-top: 5px; width: 100%;
            transition: background-color var(--transition-fast);
        }
        .sidebar-section button:hover { background-color: #6a6a6a; }
        
        /* ============================================
           SCORE BAR
           ============================================ */
        .score-bar { display: flex; flex-direction: column; gap: 6px; }
        .score-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 10px; background: rgba(0,0,0,0.2);
            border-radius: var(--radius-md); border: 1px solid rgba(var(--clr-primary-rgb), 0.25);
        }
        .score-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px; }
        .score-value {
            font-size: 16px; font-weight: 700; color: var(--clr-primary);
            text-shadow: 0 0 4px rgba(var(--clr-primary-rgb), 0.5), 0 0 8px rgba(var(--clr-primary-rgb), 0.25);
        }
        .score-value.good { color: var(--clr-success); }
        .score-value.warning { color: var(--clr-warning); }
        .score-value.error { color: var(--clr-danger); }
        
        /* ============================================
           COMPONENT LIBRARY
           ============================================ */
        .component-library { display: flex; flex-direction: column; gap: 8px; }
        .component-item {
            display: flex; align-items: center; padding: 10px;
            background: rgba(0,0,0,0.2); border: 1px solid var(--border-light);
            border-radius: var(--radius-md); cursor: pointer;
            transition: all var(--transition-fast);
        }
        .component-item:hover { background: rgba(0,0,0,0.4); border-color: var(--clr-primary); }
        .component-item img { width: 40px; height: 40px; margin-right: 10px; object-fit: contain; border-radius: var(--radius-sm); background: #333; }
        .component-item .component-info { flex: 1; }
        .component-item .component-name { font-size: 12px; font-weight: bold; color: #fff; }
        .component-item .component-specs { font-size: 10px; color: var(--text-muted); margin-top: 2px; }
        
        /* ============================================
           CANVAS ELEMENTS
           ============================================ */
        .item-group { cursor: grab; }
        .item-group:active { cursor: grabbing; }
        .item-group.selected .item-rect { stroke: var(--clr-primary); stroke-width: 3px; }
        
        /* Solar Panel */
        .panel .item-rect { fill: #2a4a6a; stroke: #4a7aaa; stroke-width: 2px; }
        .panel .panel-cells { stroke: #1a3a5a; stroke-width: 1px; }
        .panel .panel-label, .panel .panel-specs { text-anchor: middle; pointer-events: none; }
        .panel .panel-label { fill: #fff; font-size: 14px; font-weight: bold; }
        .panel .panel-specs { fill: var(--text-secondary); font-size: 11px; }
        
        /* Battery */
        .battery .item-rect { fill: #4a5a4a; stroke: #6a8a6a; stroke-width: 2px; }
        .battery .battery-terminal-pos { fill: var(--clr-danger); }
        .battery .battery-terminal-neg { fill: #222; stroke: #111; stroke-width: 1px; }
        .battery .battery-label, .battery .battery-specs { text-anchor: middle; pointer-events: none; }
        .battery .battery-label { fill: #fff; font-size: 12px; font-weight: bold; }
        .battery .battery-specs { fill: var(--text-secondary); font-size: 10px; }
        .battery .capacity-bar-bg { fill: #303030; pointer-events: none; }
        .battery .capacity-bar-fill { fill: #6fa06c; transition: height 0.3s ease-out, y 0.3s ease-out; will-change: height, transform; pointer-events: none; }
        .battery .capacity-bar-fill.low { fill: var(--clr-danger); }
        .battery .capacity-bar-fill.medium { fill: var(--clr-warning); }
        .battery .capacity-bar-fill.high { fill: var(--clr-success); }
        
        /* Controller */
        .controller .item-rect { fill: none !important; stroke: #7a7a9a; stroke-width: 2px; }
        .controller.operational .item-rect { stroke: var(--clr-success); stroke-width: 3px; }
        .controller.error .item-rect { stroke: var(--clr-danger); stroke-width: 3px; fill: #4a2020 !important; animation: pulse-error 0.5s infinite; }
        @keyframes pulse-error { 0%, 100% { stroke: var(--clr-danger); } 50% { stroke: #ff0000; } }
        .spark, .overload-flash { pointer-events: none; }
        .controller .controller-label, .controller .controller-specs { fill: #fff; text-anchor: middle; pointer-events: none; }
        .controller .controller-label { font-weight: bold; }
        .controller .port-label { fill: var(--text-muted); font-size: 9px; text-anchor: middle; pointer-events: none; }
        
        /* Breaker */
        .breaker .item-rect { fill: #3a3a4a; stroke: #6a6a8a; stroke-width: 2px; }
        .breaker.open .item-rect { stroke: var(--clr-danger); }
        .breaker.closed .item-rect { stroke: var(--clr-success); }
        
        /* Combiner */
        .combiner .item-rect { fill: #4a4a3a; stroke: #8a8a6a; stroke-width: 2px; }
        .solarcombiner .item-rect { fill: #3a4a4a; stroke: var(--clr-warning); stroke-width: 2px; }
        .solarcombiner.selected .item-rect { stroke: var(--clr-primary); stroke-width: 3px; }
        
        /* Handles (connection points) */
        .handle {
            touch-action: none; -webkit-touch-callout: none;
            -webkit-user-select: none; user-select: none;
            stroke-width: 2px; cursor: pointer; transition: r var(--transition-fast);
        }
        .handle:hover { r: 12px; }
        .handle.positive, .handle.pv-positive { fill: var(--clr-danger); stroke: #b94a48; }
        .handle.negative, .handle.pv-negative { fill: #333; stroke: #222; }
        .handle.ac { fill: var(--clr-info); stroke: #46b8da; }
        .handle.smart-battery { fill: var(--clr-success); stroke: #4cae4c; }
        
        /* Wires/Connections */
        /* Flow animations - forward (to load/consumer) and reverse (from source) */
        @keyframes flow-forward { 
            0% { stroke-dashoffset: 24; } 
            100% { stroke-dashoffset: 0; } 
        }
        @keyframes flow-reverse { 
            0% { stroke-dashoffset: 0; } 
            100% { stroke-dashoffset: 24; } 
        }
        @keyframes pulse-glow {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        /* Power flow animation - dashed line moving toward the load */
        .wire.power-flowing {
            stroke-dasharray: 8, 4;
            animation: flow-forward 0.6s linear infinite;
        }
        
        /* Resource flow animations */
        .wire.resource-consuming {
            stroke-dasharray: 6, 6;
            animation: flow-forward 0.8s linear infinite;
        }
        .wire.resource-producing {
            stroke-dasharray: 6, 6;
            animation: flow-reverse 0.8s linear infinite;
        }
        
        /* Legacy is-flowing class */
        .connection.is-flowing { stroke-dasharray: 10, 5; animation: flow-forward 0.8s linear infinite; }
        
        .wire { fill: none; stroke-width: 4px; pointer-events: stroke; cursor: pointer; }
        .wire:hover { stroke-width: 6px; }
        .wire.positive { stroke: var(--clr-danger); filter: drop-shadow(0 0 2px rgba(var(--clr-danger-rgb), 0.4)); }
        .wire.negative { stroke: #333; filter: drop-shadow(0 0 2px rgba(200,200,200,0.4)); }
        .wire.mixed { stroke: #888; }
        .wire.smart-battery { stroke: var(--clr-success); stroke-width: 6px; }
        .wire.parallel { stroke: #00a8e8; stroke-width: 6px; }
        .wire.ac { stroke: var(--clr-warning); stroke-width: 4px; }
        .wire.temp { stroke: var(--clr-primary); stroke-dasharray: 5, 5; pointer-events: none; stroke-width: 3px; }
        .wire.load { stroke-width: 4px; }
        
        /* ============================================
           HINTS AND POPUPS
           ============================================ */
        .hint-popup {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9); border: 2px solid var(--clr-primary);
            border-radius: var(--radius-lg); padding: 12px 40px;
            max-width: 800px; min-width: 600px;
            z-index: 10000; animation: slideUp var(--transition-med);
            pointer-events: auto; visibility: visible;
        }
        .hint-popup.hidden { display: none !important; visibility: hidden !important; pointer-events: none !important; opacity: 0 !important; }
        @keyframes slideUp { from { transform: translateX(-50%) translateY(50px); opacity: 0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } }
        .hint-popup h3 { margin: 0 0 8px 0; color: var(--clr-primary); font-size: 15px; }
        .hint-popup p { margin: 0; color: var(--text-secondary); font-size: 13px; line-height: 1.4; }
        .hint-popup .hint-buttons { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .hint-popup button { padding: 8px 16px; border: 1px solid; border-radius: var(--radius-sm); cursor: pointer; font-size: 13px; font-weight: bold; pointer-events: auto; flex: 1; min-width: 80px; }
        .hint-popup #hintDismiss { background: var(--clr-primary); border-color: var(--clr-primary); color: #000; }
        .hint-popup #hintDismiss:hover { background: var(--clr-primary-light); }
        .hint-popup #hintDismiss:active { background: var(--clr-primary-dark); }
        .hint-popup #hintNext { background: rgba(var(--clr-success-rgb), 0.3); border-color: var(--clr-success); color: var(--clr-success); }
        .hint-popup #hintNext:hover { background: rgba(var(--clr-success-rgb), 0.5); }
        .hint-popup #hintHide { background: rgba(var(--clr-danger-rgb), 0.3); border-color: var(--clr-danger); color: var(--clr-danger); }
        .hint-popup #hintHide:hover { background: rgba(var(--clr-danger-rgb), 0.5); }
        
        /* Achievement Overlay */
        .achievement-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 10001;
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            animation: fadeIn 0.5s ease;
        }
        .achievement-overlay.visible { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .achievement-content {
            background: var(--bg-toolbar); border: 3px solid var(--clr-success);
            border-radius: 16px; padding: 30px 40px; max-width: 600px;
            text-align: center; box-shadow: 0 0 50px rgba(var(--clr-success-rgb), 0.5);
        }
        .achievement-content h1 { color: var(--clr-success); font-size: 28px; margin: 0 0 20px 0; text-shadow: 0 0 20px rgba(var(--clr-success-rgb), 0.8); }
        .achievement-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px 0; }
        .achievement-stat { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; }
        .achievement-stat .label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; }
        .achievement-stat .value { font-size: 24px; font-weight: bold; color: var(--clr-primary); margin-top: 5px; }
        
        /* ============================================
           LIVE VIEW STYLES
           ============================================ */
        .live-view-controls-container { display: flex; gap: 10px; align-items: center; }
        .live-view-reset-btn {
            background: rgba(var(--clr-warning-rgb), 0.3); border: 1px solid var(--clr-warning);
            color: var(--clr-warning); padding: 6px 12px;
            border-radius: var(--radius-sm); cursor: pointer; font-size: 12px;
        }
        .live-view-reset-btn:hover { background: rgba(var(--clr-warning-rgb), 0.4); }
        .live-view-power-summary, .live-view-power-summary-left { display: flex; align-items: center; font-size: 13px; }
        .live-view-power-summary { gap: 20px; }
        .live-view-power-summary-left { gap: 15px; margin-left: 15px; }
        .live-view-power-item { display: flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: var(--radius-md); }
        .live-view-power-item.dc { background: rgba(var(--clr-danger-rgb), 0.15); border: 1px solid rgba(var(--clr-danger-rgb), 0.4); }
        .live-view-power-item.ac { background: rgba(var(--clr-warning-rgb), 0.15); border: 1px solid rgba(var(--clr-warning-rgb), 0.4); }
        .live-view-power-item.battery { background: rgba(var(--clr-success-rgb), 0.15); border: 1px solid rgba(var(--clr-success-rgb), 0.4); }
        .live-view-power-label { font-weight: bold; }
        .live-view-power-label.dc { color: var(--clr-danger); }
        .live-view-power-label.ac { color: var(--clr-warning); }
        .live-view-power-label.battery { color: var(--clr-success); }
        .live-view-power-value { color: #fff; font-weight: bold; font-size: 14px; }
        .live-view-power-unit { color: var(--text-dim); font-size: 11px; }
        
        .system-review-stat-disabled { color: var(--text-dim); }
    </style>
</head>
<body>
    <!-- TOOLBAR -->
    <div class="toolbar">
        <div class="toolbar-left">
            <button id="systemReviewBtn" class="system-review-button">üìä <span>System Review</span></button>
            <!-- Live View Power Summary (shown only in live mode) -->
            <div id="liveViewPowerSummaryLeft" class="live-view-power-summary-left hidden">
                <div class="live-view-power-item dc">
                    <span class="live-view-power-label dc">DC:</span>
                    <span id="liveViewDCWattsLeft" class="live-view-power-value">0</span>
                    <span class="live-view-power-unit">W</span>
                </div>
                <div class="live-view-power-item ac">
                    <span class="live-view-power-label ac">AC:</span>
                    <span id="liveViewACWattsLeft" class="live-view-power-value">0</span>
                    <span class="live-view-power-unit">W</span>
                </div>
                <div class="live-view-power-item battery">
                    <span class="live-view-power-label battery">üîã</span>
                    <span id="liveViewBatteryLevelLeft" class="live-view-power-value">0</span>
                    <span class="live-view-power-unit">kWh</span>
                    <span class="live-view-power-unit">(</span>
                    <span id="liveViewBatteryPercentLeft" class="live-view-power-label battery">0</span>
                    <span class="live-view-power-unit">%)</span>
                </div>
            </div>
        </div>
        
        <div class="toolbar-center">
            <!-- Mode toggle - always visible -->
            <div class="mode-toggle">
                <button id="buildModeBtn" class="active">Build</button>
                <button id="liveViewModeBtn">Live View</button>
                <button id="simulateModeBtn">Simulate</button>
            </div>
            
            <!-- Time display - always visible and centered -->
            <span class="time-display" id="timeDisplay">0 hours (Day 1, 00:00)</span>

            <!-- Simulate Mode Controls (hidden by default) -->
            <div id="simulateControls" class="hidden">
                <div class="play-controls">
                    <button id="playPauseButton">‚ñ∂</button>
                    <input type="range" id="speedSlider" min="1" max="100" value="10">
                    <span class="speed-label" id="speedLabel">1x</span>
                    <button id="resetSimulationBtn" style="margin-left: 10px;">Reset Simulation</button>
                </div>
            </div>
            
            <!-- Live View Mode Controls (hidden by default) -->
            <div id="liveViewControls" class="hidden">
                <div class="live-view-controls-container">
                    <button id="resetAllLoadsBtn" class="live-view-reset-btn">Reset All Loads</button>
                    <button id="resetAllBreakersBtn" class="live-view-reset-btn">Reset All Breakers</button>
                </div>
            </div>
        </div>
        
        <div class="toolbar-right">
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #aaa; cursor: pointer;">
                <input type="checkbox" id="showHintsToggle" checked style="cursor: pointer;">
                Show Hints
            </label>
            <button id="saveBtn">Save</button>
            <button id="loadBtn">Load</button>
            <!-- Simulate mode specific buttons (shown only in simulate mode) -->
            <button id="challengeModeBtn" class="hidden">Challenge Mode</button>
            <div class="weather-controls hidden">
                <label for="weatherDifficulty" style="color: white;">Weather:</label>
                <select id="weatherDifficulty" style="padding: 5px;">
                    <option value="clear" selected>Clear Sky (100%)</option>
                    <option value="easy">Easy (80-100%)</option>
                    <option value="medium">Medium (50-80%)</option>
                    <option value="hard">Hard (20-60%)</option>
                </select>
            </div>
        </div>
    </div>
    
    <!-- MAIN CONTENT -->
    <div id="main-content">
        <!-- LEFT SIDEBAR - Component Library & Scores -->
        <div id="left-sidebar">
            <button id="left-sidebar-toggle">‚óÄ</button>
            
            <!-- Score Bar Section -->
            <div class="sidebar-section system-scores-section">
                <h3>System Scores</h3>
                <div class="score-bar">
                    <div class="score-item">
                        <span class="score-label">Array Wmp</span>
                        <span class="score-value" id="scoreArrayWmp">0 W</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Array Voc</span>
                        <span class="score-value" id="scoreArrayVoc">0 V</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Array Imp</span>
                        <span class="score-value" id="scoreArrayImp">0 A</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Array Config</span>
                        <span class="score-value" id="scoreArrayConfig">-</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery</span>
                        <span class="score-value" id="scoreBatteryKwh">0 kWh</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery Config</span>
                        <span class="score-value" id="scoreBatteryConfig">-</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery Voltage</span>
                        <span class="score-value" id="scoreBatteryVoltage">-</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Optimization</span>
                        <span class="score-value" id="scoreOptimization">0%</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Total Cost</span>
                        <span class="score-value" id="scoreTotalCost">$0</span>
                    </div>
                </div>
            </div>
            
            <!-- Simulation Stats (shown in simulate mode) -->
            <div class="sidebar-section" id="simStatsSection" style="display: none;">
                <h3>Simulation Stats</h3>
                
                <!-- Date and Location Settings -->
                <div class="score-bar" style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                    <div class="score-item" style="margin-bottom: 8px;">
                        <span class="score-label">üìÖ Date</span>
                        <span class="score-value" id="simCurrentDate" style="font-size: 14px;">June 21</span>
                    </div>
                    <div class="score-item" style="margin-bottom: 8px;">
                        <span class="score-label">üåÖ Daylight</span>
                        <span class="score-value" id="simDaylightHours" style="font-size: 12px;">14.0 hrs</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
                        <label style="font-size: 11px; color: #aaa; white-space: nowrap;">üåç Latitude:</label>
                        <input type="number" id="simLatitudeInput" value="40" min="-90" max="90" step="1" 
                            style="width: 55px; padding: 3px 5px; font-size: 11px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #fff;">
                        <span style="font-size: 11px; color: #888;">¬∞</span>
                    </div>
                    <div style="font-size: 9px; color: #666; margin-top: 4px; line-height: 1.3;">
                        Examples: 64¬∞ Alaska, 52¬∞ London, 40¬∞ NYC, 34¬∞ LA, 25¬∞ Miami, -34¬∞ Sydney
                    </div>
                </div>
                
                <div class="score-bar">
                    <div class="score-item">
                        <span class="score-label">Current Solar Output</span>
                        <span class="score-value" id="simCurrentSolar">0 W</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Current Load Power</span>
                        <span class="score-value" id="simCurrentLoad">0 W</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Solar Generated</span>
                        <span class="score-value" id="simSolarGenerated">0.00 kWh</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Energy Used</span>
                        <span class="score-value" id="simEnergyUsed">0.00 kWh</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Battery Charge</span>
                        <span class="score-value" id="simBatteryCharge">0%</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Peak Power</span>
                        <span class="score-value" id="simPeakPower">0 kW</span>
                    </div>
                </div>
            </div>
            
            <!-- Component Library Section -->
            <div class="sidebar-section">
                <h3>Solar Panels</h3>
                <div class="component-library" id="panelLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Batteries</h3>
                <div class="component-library" id="batteryLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Controllers</h3>
                <div class="component-library" id="controllerLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Protection &amp; Combining</h3>
                <div class="component-library" id="breakerLibrary">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="component-library" id="combinerLibrary" style="margin-top: 10px;">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="component-library" id="solarCombinerLibrary" style="margin-top: 10px;">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>EcoFlow Ecosystem</h3>
                <div class="component-library" id="ecoflowLibrary">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>AC Distribution</h3>
                <div class="component-library" id="acBreakerLibrary">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="component-library" id="acOutletLibrary" style="margin-top: 10px;">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <!-- Custom Component Section -->
            <div class="sidebar-section">
                <h3>Add Custom</h3>
                <button id="addCustomPanelBtn">Custom Panel</button>
                <button id="addCustomBatteryBtn">Custom Battery</button>
                <button id="addCustomControllerBtn">Custom Controller</button>
            </div>
            
            <!-- Resource Containers Library -->
            <div class="sidebar-section">
                <h3>Resource Containers</h3>
                <div class="component-library" id="resourceContainerLibrary">
                    <button class="library-item" data-resource="Water">üíß Water Tank</button>
                    <button class="library-item" data-resource="Biomass">üåø Biomass Container</button>
                    <button class="library-item" data-resource="Plastic">üß± Plastic Container</button>
                    <button class="library-item" data-resource="Plastic Flakes">‚ôªÔ∏è Plastic Flakes</button>
                    <button class="library-item" data-resource="Woodgas">üí® Woodgas Tank</button>
                    <button class="library-item" data-resource="Biochar">‚ö´ Biochar Container</button>
                    <button class="library-item" data-resource="Heat">üî• Heat Storage</button>
                    <button class="library-item" data-resource="Generic">üì¶ Generic Container</button>
                </div>
            </div>
            
        </div>
        
        <!-- CANVAS -->
        <div id="canvas-container">
            <svg id="canvas"></svg>
        </div>
        
        <!-- RIGHT SIDEBAR - Inspector/Editor (opens when selecting) -->
        <div id="right-sidebar">
            <button id="right-sidebar-toggle">‚ñ∂</button>
            
            <div class="sidebar-section" id="inspectorSection">
                <h3>Inspector</h3>
                <p id="inspectorEmpty">Select a component to edit</p>
                
                <!-- Panel Inspector -->
                <div id="panelInspector" class="hidden">
                    <h4>Solar Panel</h4>
                    <label>Name: <input type="text" id="panelName"></label>
                    <label>Wmp (W): <input type="number" id="panelWmp" min="0"></label>
                    <label>Vmp (V): <input type="number" id="panelVmp" min="0" step="0.1"></label>
                    <label>Voc (V): <input type="number" id="panelVoc" min="0" step="0.1"></label>
                    <label>Isc (A): <input type="number" id="panelIsc" min="0" step="0.01"></label>
                    <label>Imp (A): <input type="number" id="panelImp" min="0" step="0.01"></label>
                    <label>Width (mm): <input type="number" id="panelWidth" min="0" step="1"></label>
                    <label>Height (mm): <input type="number" id="panelHeight" min="0" step="1"></label>
                    <label>Cost ($): <input type="number" id="panelCost" min="0" step="0.01"></label>
                    <div id="panelArrayArea" style="margin-top: 10px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; border: 1px solid rgba(255, 221, 87, 0.2);">
                        <div style="font-size: 11px; color: #aaa; margin-bottom: 4px;">Total Array Area:</div>
                        <div style="font-size: 14px; font-weight: bold; color: #ffdd57;" id="panelArrayAreaValue">0 m¬≤</div>
                    </div>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(92, 184, 92, 0.1); border-radius: 4px; font-size: 11px;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="updateArrayOnly" style="margin: 0;">
                            <span>Update only this array (all parallel strings)</span>
                        </label>
                    </div>
                    <p style="font-size: 11px; color: #f0ad4e; margin-top: 10px;">
                        Note: By default, changes apply to ALL panels. Check the box above to update only this array.
                    </p>
                    <button id="applyPanelChanges">Apply Changes</button>
                </div>
                
                <!-- Battery Inspector -->
                <div id="batteryInspector" class="hidden">
                    <h4>Battery</h4>
                    <label>Name: <input type="text" id="batteryName"></label>
                    <label>Voltage (V): <input type="number" id="batteryVoltage" min="0" step="0.1"></label>
                    <label>Capacity (Ah): <input type="number" id="batteryAh" min="0" step="0.1"></label>
                    <label>Max Discharge (A): <input type="number" id="batteryMaxDischarge" min="0" step="0.1"></label>
                    <label>Cost ($): <input type="number" id="batteryCost" min="0" step="0.01"></label>
                    <label>Width (mm): <input type="number" id="batteryWidth" min="0" step="1"></label>
                    <label>Height (mm): <input type="number" id="batteryHeight" min="0" step="1"></label>
                    
                    <!-- Low Battery Protection Settings -->
                    <div style="margin-top: 15px; padding: 10px; background: rgba(240, 173, 78, 0.1); border-radius: 4px; border: 1px solid rgba(240, 173, 78, 0.3);">
                        <h5 style="margin-top: 0; margin-bottom: 8px; font-size: 13px; color: #f0ad4e;">Low Battery Protection</h5>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="batteryEnableLowBatteryShutdown" style="margin: 0;">
                            <span style="font-size: 12px;">Enable automatic load shutdown</span>
                        </label>
                        <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 4px;">
                            Shutdown threshold (%): 
                            <input type="number" id="batteryShutdownThreshold" min="0" max="100" step="0.1" value="10" style="width: 60px; margin-left: 5px;">
                        </label>
                        <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 4px;">
                            Re-enable threshold (%): 
                            <input type="number" id="batteryReenableThreshold" min="0" max="100" step="0.1" value="15" style="width: 60px; margin-left: 5px;">
                        </label>
                        <p style="font-size: 10px; color: #888; margin-top: 8px; margin-bottom: 0;">
                            When battery SOC drops below the shutdown threshold, all loads will be automatically turned off. Loads will be re-enabled when battery recovers above the re-enable threshold.
                        </p>
                    </div>
                    
                    <p style="font-size: 11px; color: #f0ad4e; margin-top: 10px;">
                        Note: Editing this battery will update ALL batteries in the bank.
                    </p>
                    <button id="applyBatteryChanges">Apply to All Batteries</button>
                </div>
                
                <!-- Controller Inspector -->
                <div id="controllerInspector" class="hidden">
                    <h4>Controller</h4>
                    <label>Name: <input type="text" id="controllerName"></label>
                    <label>Type: 
                        <select id="controllerType">
                            <option value="charge_controller">Charge Controller</option>
                            <option value="hybrid_inverter">Hybrid Inverter</option>
                            <option value="all_in_one">All-in-One System</option>
                        </select>
                    </label>
                    <label>Max PV Voc (V): <input type="number" id="controllerMaxVoc" min="0"></label>
                    <label>Min PV Vmp (V): <input type="number" id="controllerMinVmp" min="0"></label>
                    <label>MPP Range (V): 
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <input type="number" id="controllerMppMin" min="0" style="width: 60px;"> - 
                            <input type="number" id="controllerMppMax" min="0" style="width: 60px;">
                        </div>
                    </label>
                    <label>Max PV Isc (A): <input type="number" id="controllerMaxIsc" min="0" step="0.1"></label>
                    <label>Max PV Wmp (W): <input type="number" id="controllerMaxWmp" min="0"></label>
                    <label>MPPT Count: <input type="number" id="controllerMpptCount" min="1" step="1" value="1"></label>
                    <label>Charge Current (A): <input type="number" id="controllerChargeCurrent" min="0" step="0.1"></label>
                    <div id="controllerACOutput" class="hidden">
                        <label>AC Output (W): <input type="number" id="controllerACOutputW" min="0"></label>
                        <label>Inverter Load (W): <input type="number" id="controllerInverterLoad" min="0" step="1" value="0"></label>
                        <p style="font-size: 11px; color: #aaa; margin: 2px 0 5px 0;">Power consumed by the inverter when outputting live AC</p>
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="font-size: 12px; color: #aaa;">Compatible Voltages:</span>
                        <div id="controllerVoltages" style="display: flex; gap: 10px; margin-top: 5px;">
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV12" value="12"> 12V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV24" value="24"> 24V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV36" value="36"> 36V
                            </label>
                            <label style="display: flex; align-items: center; gap: 3px; font-size: 12px;">
                                <input type="checkbox" id="controllerV48" value="48"> 48V
                            </label>
                        </div>
                    </div>
                    <label>Cost ($): <input type="number" id="controllerCost" min="0" step="0.01"></label>
                    <label>Width (mm): <input type="number" id="controllerWidth" min="0" step="1"></label>
                    <label>Height (mm): <input type="number" id="controllerHeight" min="0" step="1"></label>
                    
                    <hr style="border-color: #444; margin: 15px 0;">
                    <h5 style="margin: 10px 0 8px 0; color: #ffdd57;">Visual Styling</h5>
                    <label>Top Color: <input type="color" id="controllerTopColor" value="#c0c0c0" style="width: 60px; height: 25px;"></label>
                    <label>Bottom Color: <input type="color" id="controllerBottomColor" value="#2a2a2a" style="width: 60px; height: 25px;"></label>
                    <label>Divider Height (%): <input type="number" id="controllerDividerHeight" min="0" max="100" step="1" value="50" style="width: 60px;"></label>
                    <p style="font-size: 11px; color: #aaa; margin: 5px 0;">Controls where the color split occurs (0% = all bottom, 100% = all top)</p>
                    <label>Background Image URL (optional): <input type="text" id="controllerImageUrl" placeholder="https://..." style="width: 100%; font-size: 11px;"></label>
                    <p style="font-size: 11px; color: #aaa; margin: 5px 0;">External image URL to use as background</p>
                    
                    <button id="applyControllerChanges">Apply Changes</button>
                </div>
                
                <!-- Breaker Inspector -->
                <div id="breakerInspector" class="hidden">
                    <h4>DC Breaker</h4>
                    <label>Rating (A): 
                        <select id="breakerRating">
                            <option value="5">5A</option>
                            <option value="10">10A</option>
                            <option value="16">16A</option>
                            <option value="20">20A</option>
                            <option value="30">30A</option>
                            <option value="40">40A</option>
                            <option value="50">50A</option>
                            <option value="63">63A</option>
                            <option value="80">80A</option>
                            <option value="100">100A</option>
                        </select>
                    </label>
                    <label>Max Voltage (V): <input type="number" id="breakerMaxVoltage" min="0"></label>
                    <label>Cost ($): <input type="number" id="breakerCost" min="0" step="0.01"></label>
                    <div style="margin-top: 10px;">
                        <button id="toggleBreaker" style="width: 100%;">Toggle Breaker</button>
                    </div>
                    <p id="breakerStatus" style="text-align: center; font-weight: bold; margin-top: 10px;"></p>
                    <button id="applyBreakerChanges">Apply Changes</button>
                    <button id="autosizeBreaker" style="margin-top: 5px;">Auto-Size Breaker</button>
                </div>
                
                <!-- Combiner Inspector -->
                <div id="combinerInspector" class="hidden">
                    <h4>Combiner Box</h4>
                    <p id="combinerInfo">Combines multiple parallel strings into one output.</p>
                    <label>Number of Inputs: <span id="combinerInputCount">4</span></label>
                    <label>Max Amps/Input: <input type="number" id="combinerMaxAmps" min="0" step="0.1"></label>
                    <label>Cost ($): <input type="number" id="combinerCost" min="0" step="0.01"></label>
                    <button id="applyCombinerChanges">Apply Changes</button>
                </div>
                
                <!-- Solar Combiner Inspector -->
                <div id="solarCombinerInspector" class="hidden">
                    <h4>Solar Combiner Box</h4>
                    <p style="font-size: 11px; color: #aaa;">Combines PV strings with individual breaker protection.</p>
                    <label>Number of Inputs: <span id="solarCombinerInputCount">4</span></label>
                    <label>Breaker Rating (A): 
                        <select id="solarCombinerBreakerRating">
                            <option value="10">10A</option>
                            <option value="15">15A</option>
                            <option value="20">20A</option>
                            <option value="30">30A</option>
                        </select>
                    </label>
                    <label>Max Voltage (V): <input type="number" id="solarCombinerMaxVoltage" min="0"></label>
                    <label>Cost ($): <input type="number" id="solarCombinerCost" min="0" step="0.01"></label>
                    <div style="margin-top: 10px;">
                        <h5 style="margin: 5px 0; color: #ffdd57;">Input Breakers:</h5>
                        <div id="solarCombinerBreakers"></div>
                    </div>
                    <button id="applySolarCombinerChanges">Apply Changes</button>
                </div>
                
                <!-- Wire Inspector -->
                <div id="wireInspector" class="hidden">
                    <h4>Wire Connection</h4>
                    <p id="wireInfo">Connection details here</p>
                    <p id="wireCurrentInfo" style="font-size: 11px; color: #f0ad4e;"></p>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Wire Specifications</h5>
                    
                    <label>Wire Gauge (AWG):
                        <input type="text" id="wireGaugeDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Operating Amperage:
                        <input type="text" id="wireAmpsDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Estimated Length (feet):
                        <input type="number" id="wireLengthInput" min="0" step="0.1" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    <button id="recalculateWireLength" style="margin-top: 5px; width: 100%; padding: 5px; background: #5bc0de; border: none; color: white; border-radius: 3px; cursor: pointer;">Recalculate Length</button>
                    
                    <label>Cost per Foot ($):
                        <input type="number" id="wireCostPerFootInput" min="0" step="0.01" style="width: 100%; padding: 5px; margin-top: 3px;">
                    </label>
                    
                    <label>Total Wire Cost:
                        <input type="text" id="wireTotalCostDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #f0ad4e; border: 1px solid #444; font-weight: bold;">
                    </label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Power Loss</h5>
                    
                    <label>Wire Resistance (Œ©):
                        <input type="text" id="wireResistanceDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #fff; border: 1px solid #444;">
                    </label>
                    
                    <label>Power Loss (W):
                        <input type="text" id="wirePowerLossDisplay" readonly style="width: 100%; padding: 5px; margin-top: 3px; background: #2a2a2a; color: #d9534f; border: 1px solid #444; font-weight: bold;">
                    </label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <button id="deleteWire">Delete Connection</button>
                    <button id="addBreakerToWire" style="margin-top: 5px;">Add Breaker to Circuit</button>
                </div>
                
                <!-- Spider Box Inspector -->
                <div id="spiderboxInspector" class="hidden">
                    <h4>CEP Spider Box</h4>
                    <p style="font-size: 11px; color: #f0ad4e;">Portable power distribution unit</p>
                    <label>Input: <span style="color: #d9534f; font-weight: bold;">240V 50A</span></label>
                    <label>Max Power: <span id="spiderboxMaxPower">12,000W</span></label>
                    <label>Cost ($): <input type="number" id="spiderboxCost" min="0" step="1"></label>
                    <div style="margin-top: 15px;">
                        <h5 style="margin: 5px 0; color: #f0ad4e;">Circuit Breakers:</h5>
                        <div id="spiderboxBreakers" style="max-height: 200px; overflow-y: auto;"></div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="spiderboxAllOn" style="flex: 1;">All On</button>
                        <button id="spiderboxAllOff" style="flex: 1;">All Off</button>
                    </div>
                    <button id="applySpiderboxChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- Breaker Panel Inspector -->
                <div id="breakerpanelInspector" class="hidden">
                    <h4>Main Breaker Panel</h4>
                    <p style="font-size: 11px; color: #888;">Residential/commercial distribution panel</p>
                    <label>Main Input: <span style="color: #d9534f; font-weight: bold;">240V 100A</span></label>
                    <label>Max Power: <span id="panelMaxPower">24,000W</span></label>
                    <label>Cost ($): <input type="number" id="breakerpanelCost" min="0" step="1"></label>
                    <div style="margin-top: 15px;">
                        <h5 style="margin: 5px 0; color: #f0ad4e;">Circuit Breakers:</h5>
                        <div id="breakerpanelBreakers" style="max-height: 250px; overflow-y: auto;"></div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="breakerpanelAllOn" style="flex: 1;">All On</button>
                        <button id="breakerpanelAllOff" style="flex: 1;">All Off</button>
                    </div>
                    <button id="applyBreakerpanelChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- AC Load Inspector -->
                <div id="acloadInspector" class="hidden">
                    <h4>Appliance / Load</h4>
                    
                    <!-- Live View Toggle (only shown in live view mode) -->
                    <div id="loadToggleSection" class="hidden" style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px; border: 1px solid #444;">
                        <label style="display: flex; align-items: center; justify-content: space-between;">
                            <span>Power:</span>
                            <button id="loadToggleBtn" style="padding: 5px 15px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold;">
                                OFF
                            </button>
                        </label>
                        <p id="loadStatusText" style="font-size: 10px; color: #888; margin: 5px 0 0 0;"></p>
                    </div>
                    
                    <label>Preset:
                        <select id="loadPreset" style="width: 100%; padding: 5px; margin-top: 3px;">
                            <!-- Populated by JavaScript -->
                        </select>
                    </label>
                    <label>Name: <input type="text" id="loadName"></label>
                    <label>Voltage (V): 
                        <select id="loadVoltage">
                            <option value="120">120V</option>
                            <option value="240">240V</option>
                        </select>
                    </label>
                    <label>Max Watts: <input type="number" id="loadMaxWatts" min="0"></label>
                    <label>Icon: <input type="text" id="loadIcon" maxlength="2" style="width: 50px;"></label>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #f0ad4e;">Power &amp; Behavior</h5>
                    <label>Power Draw (W): <input type="number" id="loadAvgWatts" min="0"></label>
                    <p style="font-size: 10px; color: #888; margin: 3px 0 8px 0;">Power consumed when running. Use automations to control when it runs.</p>
                    
                    <label>Type:
                        <select id="loadBehaviorType" style="width: 100%; padding: 5px; margin-top: 3px;">
                            <option value="simple">Simple (on/off)</option>
                            <option value="recipe">Recipe Processor</option>
                        </select>
                    </label>
                    
                    <!-- Simple behavior (default) -->
                    <div id="behaviorSimple" class="behavior-section">
                        <p style="font-size: 10px; color: #888; margin: 8px 0 0 0;">Draws power when on. Use automation rules below to control scheduling.</p>
                    </div>
                    
                    <!-- Recipe behavior -->
                    <div id="behaviorRecipe" class="behavior-section hidden">
                        <p style="font-size: 10px; color: #888; margin: 8px 0;">Processes inputs into outputs. Connect to resource containers.</p>
                        
                        <div id="recipeList" style="max-height: 300px; overflow-y: auto; background: #1a1a1a; border-radius: 4px; padding: 8px; margin-top: 8px;">
                            <!-- Populated by JS -->
                        </div>
                        <button id="addRecipeBtn" style="margin-top: 8px; font-size: 11px; width: 100%;">+ Add Recipe</button>
                        
                        <!-- Inline Recipe Editor (hidden by default) -->
                        <div id="recipeEditor" class="hidden" style="background: #252525; border-radius: 4px; padding: 10px; margin-top: 8px; border: 1px solid #f0ad4e;">
                            <h6 style="margin: 0 0 8px 0; color: #f0ad4e;">Recipe Editor</h6>
                            
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Recipe Name:
                                <input type="text" id="recipeEditorName" placeholder="e.g., Make Biochar" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Duration (minutes):
                                <input type="number" id="recipeEditorDuration" min="1" value="60" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Energy per Batch (Wh):
                                <input type="number" id="recipeEditorEnergy" min="0" value="100" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            
                            <hr style="border-color: #444; margin: 10px 0;">
                            <div style="display: flex; gap: 10px;">
                                <!-- Inputs column -->
                                <div style="flex: 1;">
                                    <h6 style="margin: 0 0 6px 0; color: #5cb85c; font-size: 11px;">Inputs (consumes)</h6>
                                    <div id="recipeEditorInputs" style="background: #1a1a1a; padding: 6px; border-radius: 4px; min-height: 60px;">
                                        <!-- Populated by JS -->
                                    </div>
                                    <button id="addRecipeInputBtn" style="margin-top: 4px; font-size: 10px; padding: 3px 6px;">+ Input</button>
                                </div>
                                <!-- Outputs column -->
                                <div style="flex: 1;">
                                    <h6 style="margin: 0 0 6px 0; color: #5bc0de; font-size: 11px;">Outputs (produces)</h6>
                                    <div id="recipeEditorOutputs" style="background: #1a1a1a; padding: 6px; border-radius: 4px; min-height: 60px;">
                                        <!-- Populated by JS -->
                                    </div>
                                    <button id="addRecipeOutputBtn" style="margin-top: 4px; font-size: 10px; padding: 3px 6px;">+ Output</button>
                                </div>
                            </div>
                            
                            <div style="display: flex; gap: 8px; margin-top: 10px;">
                                <button id="saveRecipeBtn" style="flex: 1; background: #5cb85c; border: none; color: white; padding: 6px; border-radius: 3px; cursor: pointer;">Save Recipe</button>
                                <button id="cancelRecipeBtn" style="flex: 1; background: #666; border: none; color: white; padding: 6px; border-radius: 3px; cursor: pointer;">Cancel</button>
                            </div>
                        </div>
                    </div>
                    
                    <hr style="border-color: #444; margin: 12px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #5bc0de;">Automation Rules</h5>
                    <p style="font-size: 10px; color: #888; margin: 5px 0 8px 0;">Automatically turn this appliance on/off based on conditions.</p>
                    <div id="automationList" style="max-height: 200px; overflow-y: auto; background: #1a1a1a; border-radius: 4px; padding: 5px; margin-bottom: 8px;">
                        <!-- Populated by JS -->
                    </div>
                    <button id="addAutomationBtn" style="font-size: 11px; margin-bottom: 8px;">+ Add Automation Rule</button>
                    
                    <!-- Automation Editor (hidden by default) -->
                    <div id="automationEditor" class="hidden" style="background: #252525; border-radius: 4px; padding: 10px; margin-top: 8px; border: 1px solid #444;">
                        <h6 style="margin: 0 0 8px 0; color: #5bc0de;">Edit Automation Rule</h6>
                        <label style="display: block; margin-bottom: 6px; font-size: 11px;">Action:
                            <select id="automationAction" style="width: 100%; padding: 4px; margin-top: 2px;">
                                <option value="turnOn">Turn ON</option>
                                <option value="turnOff">Turn OFF</option>
                                <option value="startRecipe">Start Recipe</option>
                            </select>
                        </label>
                        <label style="display: block; margin-bottom: 6px; font-size: 11px;">Trigger Type:
                            <select id="automationTriggerType" style="width: 100%; padding: 4px; margin-top: 2px;">
                                <option value="timeOfDay">Time of Day</option>
                                <option value="batteryLevel">Battery Level</option>
                                <option value="solarInput">Solar Input</option>
                                <option value="containerValue">Container Value</option>
                            </select>
                        </label>
                        
                        <!-- Time of Day fields -->
                        <div id="automationTimeFields" class="automation-param-fields">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Start Hour (0-23):
                                <input type="number" id="automationStartHour" min="0" max="23" value="18" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">End Hour (0-23):
                                <input type="number" id="automationEndHour" min="0" max="23" value="6" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                        </div>
                        
                        <!-- Battery Level fields -->
                        <div id="automationBatteryFields" class="automation-param-fields hidden">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Target Battery:
                                <select id="automationBatteryLabel" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="">Select Battery...</option>
                                    <!-- Populated by JS -->
                                </select>
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Condition:
                                <select id="automationBatteryCondition" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="above">Above</option>
                                    <option value="below">Below</option>
                                </select>
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Threshold (%):
                                <input type="number" id="automationBatteryThreshold" min="0" max="100" value="80" step="1" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                        </div>
                        
                        <!-- Solar Input fields -->
                        <div id="automationSolarFields" class="automation-param-fields hidden">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Target Solar Array Name:
                                <input type="text" id="automationSolarLabel" placeholder="Solar Array" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Condition:
                                <select id="automationSolarCondition" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="aboveZero">Above Zero</option>
                                    <option value="zero">Zero</option>
                                </select>
                            </label>
                        </div>
                        
                        <!-- Container Value fields -->
                        <div id="automationContainerFields" class="automation-param-fields hidden">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Target Container Name:
                                <input type="text" id="automationContainerLabel" placeholder="Container" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Condition:
                                <select id="automationContainerCondition" style="width: 100%; padding: 4px; margin-top: 2px;">
                                    <option value="above">Above</option>
                                    <option value="below">Below</option>
                                    <option value="equals">Equals</option>
                                </select>
                            </label>
                            <label style="display: block; margin-bottom: 6px; font-size: 11px;">Threshold:
                                <input type="number" id="automationContainerThreshold" min="0" value="10" step="0.1" style="width: 100%; padding: 4px; margin-top: 2px;">
                            </label>
                        </div>
                        
                        <!-- Recipe Selection fields (shown when action is startRecipe) -->
                        <div id="automationRecipeFields" class="automation-action-fields hidden" style="background: #333; padding: 8px; border-radius: 4px; margin-top: 6px; border: 1px solid #f0ad4e;">
                            <label style="display: block; margin-bottom: 6px; font-size: 11px; color: #f0ad4e;">
                                <strong>üìã Recipe to Start:</strong>
                                <select id="automationRecipeSelect" style="width: 100%; padding: 4px; margin-top: 4px;">
                                    <option value="">-- Select Recipe --</option>
                                </select>
                            </label>
                            <div id="automationRecipeDetails" style="font-size: 10px; color: #888; margin-top: 4px; padding: 4px; background: #222; border-radius: 3px;">
                                Select a recipe to see details
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 6px; margin-top: 8px;">
                            <button id="saveAutomationBtn" style="flex: 1; padding: 6px; font-size: 11px; background: #5cb85c; color: white; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                            <button id="cancelAutomationBtn" style="flex: 1; padding: 6px; font-size: 11px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                    
                    <button id="applyLoadChanges" style="margin-top: 10px;">Apply Changes</button>
                </div>
                
                <!-- Resource Container Inspector -->
                <div id="resourceContainerInspector" class="hidden">
                    <h4>üì¶ Resource Container</h4>
                    
                    <label style="display: block; margin-bottom: 8px;">Name:
                        <input type="text" id="containerName" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Resource Type:
                        <select id="containerResourceType" style="width: 100%; padding: 4px; margin-top: 2px;">
                            <option value="Water">üíß Water</option>
                            <option value="Biomass">üåø Biomass</option>
                            <option value="Plastic">üß± Plastic</option>
                            <option value="Plastic Flakes">‚ôªÔ∏è Plastic Flakes</option>
                            <option value="Woodgas">üí® Woodgas</option>
                            <option value="Biochar">‚ö´ Biochar</option>
                            <option value="Heat">üî• Heat</option>
                            <option value="Wind Turbines">üåÄ Wind Turbines</option>
                            <option value="Generic">üì¶ Generic (Any Type)</option>
                        </select>
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Capacity:
                        <input type="number" id="containerCapacity" min="0" step="1" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Current Value:
                        <input type="number" id="containerValue" step="0.1" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <label style="display: block; margin-bottom: 8px;">Unit:
                        <input type="text" id="containerUnit" placeholder="e.g., kg, L, units" style="width: 100%; padding: 4px; margin-top: 2px;">
                    </label>
                    
                    <div style="margin-top: 10px; padding: 8px; background: #1a1a1a; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #888; font-size: 11px;">Fill Level:</span>
                            <span id="containerFillPercent" style="color: #5cb85c; font-size: 11px;">0%</span>
                        </div>
                        <div style="height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                            <div id="containerFillBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #5cb85c, #f0ad4e); transition: width 0.3s;"></div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 8px;">
                        <button id="containerFillBtn" style="flex: 1; background: #5cb85c;">Fill to 100%</button>
                        <button id="containerEmptyBtn" style="flex: 1; background: #d9534f;">Empty</button>
                    </div>
                    
                    <button id="applyContainerChanges" style="margin-top: 10px; width: 100%;">Apply Changes</button>
                    
                    <button id="deleteContainerBtn" style="margin-top: 8px; width: 100%; background: #d9534f;">üóëÔ∏è Delete Container</button>
                </div>
                
            </div>
        </div>
    </div>
    
    <!-- HINT POPUP -->
    <div id="hintPopup" class="hint-popup hidden">
        <h3 id="hintTitle">Hint</h3>
        <p id="hintText"></p>
        <div class="hint-buttons">
            <button id="hintNext">Next</button>
            <button id="hintDismiss">Got it!</button>
            <button id="hintHide">Hide Hints</button>
        </div>
    </div>
    
    <!-- ACHIEVEMENT OVERLAY -->
    <div id="achievementOverlay" class="achievement-overlay">
        <div class="achievement-content">
            <h1 id="achievementTitle">System Operational!</h1>
            <div class="achievement-stats" id="achievementStats">
                <!-- Populated by JavaScript -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="achievementClose">Continue Building</button>
                <button id="startSimulation" style="background: #5cb85c;">‚ñ∂ Start Simulation</button>
            </div>
        </div>
    </div>
    
    <!-- BILL OF MATERIALS OVERLAY -->
    <div id="bomOverlay" class="achievement-overlay" style="display: none;">
        <div class="achievement-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h1>Bill of Materials</h1>
            <div id="bomContent">
                <!-- Populated by JavaScript -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="bomExportBtn" style="background: #5bc0de;">Export BOM</button>
                <button id="bomCloseBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SOLAR BUILDER & SIMULATOR - MAIN SCRIPT
        // ============================================
        
        // ============================================
        // CONSTANTS AND PRESETS
        // ============================================
        
        const PANEL_WIDTH = 100;
        const PANEL_HEIGHT = 60;
        const BATTERY_WIDTH = 80;
        const BATTERY_HEIGHT = 120;
        const CONTROLLER_WIDTH = 140;
        const CONTROLLER_HEIGHT = 200; // Doubled from 100 to 200
        const BREAKER_WIDTH = 60;
        const BREAKER_HEIGHT = 80;
        const COMBINER_WIDTH = 100;
        const COMBINER_HEIGHT = 80;
        const SOLAR_COMBINER_WIDTH = 120;
        const SOLAR_COMBINER_HEIGHT = 100;
        const HANDLE_RADIUS = 12; // Increased for better touch targets on mobile devices
        
        // Common breaker sizes (Amps)
        const BREAKER_SIZES = [5, 10, 16, 20, 30, 40, 50, 63, 80, 100];
        
        // Wire gauge specifications (AWG size, ampacity, visual width, name)
        const WIRE_GAUGE_SPECS = {
            '18': { gauge: '18', amps: 14, width: 1, name: '18 AWG', resistancePer1000ft: 6.385 }, // ohms per 1000 feet
            '16': { gauge: '16', amps: 18, width: 1.5, name: '16 AWG', resistancePer1000ft: 4.016 },
            '14': { gauge: '14', amps: 20, width: 2, name: '14 AWG', resistancePer1000ft: 2.525 },
            '12': { gauge: '12', amps: 25, width: 2.5, name: '12 AWG', resistancePer1000ft: 1.588 },
            '10': { gauge: '10', amps: 30, width: 3, name: '10 AWG', resistancePer1000ft: 0.999 },
            '8': { gauge: '8', amps: 40, width: 3.5, name: '8 AWG', resistancePer1000ft: 0.628 },
            '6': { gauge: '6', amps: 55, width: 4, name: '6 AWG', resistancePer1000ft: 0.395 },
            '4': { gauge: '4', amps: 70, width: 4.5, name: '4 AWG', resistancePer1000ft: 0.249 },
            '2': { gauge: '2', amps: 95, width: 5, name: '2 AWG', resistancePer1000ft: 0.156 },
            '1/0': { gauge: '1/0', amps: 125, width: 5.5, name: '1/0 AWG', resistancePer1000ft: 0.0983 },
            '2/0': { gauge: '2/0', amps: 145, width: 6, name: '2/0 AWG', resistancePer1000ft: 0.0779 },
            '3/0': { gauge: '3/0', amps: 165, width: 6.5, name: '3/0 AWG', resistancePer1000ft: 0.0618 },
            '4/0': { gauge: '4/0', amps: 195, width: 7, name: '4/0 AWG', resistancePer1000ft: 0.0490 }
        };
        
        // Wire cost per foot by AWG size (default prices, user can override)
        const WIRE_COST_PER_FOOT = {
            '18': 0.15,
            '16': 0.18,
            '14': 0.22,
            '12': 0.28,
            '10': 0.35,
            '8': 0.50,
            '6': 0.75,
            '4': 1.10,
            '2': 1.60,
            '1/0': 2.20,
            '2/0': 2.80,
            '3/0': 3.50,
            '4/0': 4.20
        };
        
        // Safety margin for wire sizing (amps)
        const WIRE_SAFETY_MARGIN_AMPS = 5;
        
        // Function to calculate and display total array area
        function updatePanelArrayArea() {
            const panels = allItems.filter(i => i.type === 'panel');
            let totalAreaM2 = 0;
            
            panels.forEach(panel => {
                const width = panel.specs.width || 0;
                const height = panel.specs.height || 0;
                if (width > 0 && height > 0) {
                    // Convert mm¬≤ to m¬≤
                    const areaM2 = (width * height) / 1000000;
                    totalAreaM2 += areaM2;
                }
            });
            
            const areaElement = document.getElementById('panelArrayAreaValue');
            if (areaElement) {
                areaElement.textContent = totalAreaM2 > 0 ? `${totalAreaM2.toFixed(2)} m¬≤` : '0 m¬≤';
            }
        }
        
        // Function to auto-size breaker based on expected current
        function autosizeBreaker(expectedAmps) {
            // Add 5-10A margin (use 25% above expected, minimum 5A margin)
            const targetAmps = expectedAmps * 1.25;
            const minTarget = expectedAmps + 5;
            const withMargin = Math.max(targetAmps, minTarget);
            
            // Find nearest breaker size that's >= withMargin
            for (const size of BREAKER_SIZES) {
                if (size >= withMargin) return size;
            }
            return BREAKER_SIZES[BREAKER_SIZES.length - 1]; // Return largest if exceeded
        }
        
        // Function to get wire gauge for given amperage
        function getWireGaugeForAmps(amps) {
            if (!amps || amps <= 0) {
                return { gauge: '10', amps: 30, width: 3, name: '10 AWG' }; // Default to 10 AWG for zero/negative amps
            }
            
            // Add safety margin
            const requiredAmps = amps + WIRE_SAFETY_MARGIN_AMPS;
            
            // Sort gauges by ampacity in ascending order (smallest first)
            const sortedGauges = Object.entries(WIRE_GAUGE_SPECS)
                .sort((a, b) => a[1].amps - b[1].amps);
            
            // Find the smallest gauge that can handle the required current
            for (const [gauge, spec] of sortedGauges) {
                if (requiredAmps <= spec.amps) {
                    return { gauge, ...spec };
                }
            }
            
            // If amps exceed all ratings, return the largest gauge
            const largestGauge = sortedGauges[sortedGauges.length - 1];
            return { gauge: largestGauge[0], ...largestGauge[1] };
        }
        
        // Component presets - optimized with factory functions for defaults
        // Panel dimensions: [width, height] in mm. Common sizes: 60-cell=1650x992, 72-cell=2108x1048
        const PANEL_PRESETS = [
            { name: "Generic 250W", wmp: 250, vmp: 30.5, voc: 37.5, isc: 8.8, imp: 8.2, cost: 120 },
            { name: "Alrska Flexible 100W", wmp: 100, vmp: 18, voc: 21.6, isc: 6.1, imp: 5.56, cost: 80, width: 1050, height: 540 },
            { name: "Ecoflow 400W", wmp: 400, vmp: 41, voc: 48, isc: 11, imp: 9.76, cost: 300, width: 2108, height: 1048 },
            { name: "Trina Solar 260W", wmp: 260, vmp: 32.5, voc: 39.5, isc: 9.75, imp: 8, cost: 150 },
            { name: "REC Alpha 410W", wmp: 410, vmp: 33.2, voc: 40.1, isc: 12.8, imp: 12.35, cost: 280, width: 2108, height: 1048 },
            { name: "EcoFlow Folding 400W", wmp: 400, vmp: 41, voc: 48, isc: 11, imp: 9.76, cost: 300, width: 2108, height: 1048 },
            { name: "Solaria 400XT", wmp: 400, vmp: 40, voc: 48.5, isc: 10.8, imp: 10, cost: 320, width: 2108, height: 1048 },
            { name: "Sunpower 435W", wmp: 435, vmp: 41.5, voc: 49, isc: 11.2, imp: 10.5, cost: 380, width: 2108, height: 1048 },
            { name: "Alrska 120W Rigid", wmp: 120, vmp: 20, voc: 24, isc: 6.5, imp: 6, cost: 90, width: 1200, height: 600 },
            { name: "Ecoflow 100W Rigid", wmp: 100, vmp: 18, voc: 21.6, isc: 6.1, imp: 5.56, cost: 85, width: 1050, height: 540 },
            { name: "BougeRV CIGs 200W", wmp: 200, vmp: 18, voc: 22, isc: 11.5, imp: 11.1, cost: 250, width: 1400, height: 1000 }
        ].map(p => ({ width: 1650, height: 992, ...p })); // Default 60-cell dimensions
        
        // Battery presets - dimensions derived from capacity, voltage defaults applied
        const _BATT_DIMS = { 100: [200,300], 200: [250,350], 280: [280,400] }; // ah -> [w,h]
        const _battPreset = (name, v, ah, cost, extra={}) => ({ 
            name, voltage: v, ah, maxDischarge: extra.maxDischarge ?? ah, 
            width: extra.width ?? (_BATT_DIMS[ah]?.[0] ?? 200), 
            height: extra.height ?? (_BATT_DIMS[ah]?.[1] ?? 300), 
            cost, ...extra 
        });
        const BATTERY_PRESETS = [
            // 12V LiFePO4
            _battPreset("12V 100Ah LiFePO4", 12.8, 100, 400),
            _battPreset("12V 200Ah LiFePO4", 12.8, 200, 700),
            _battPreset("12V 100Ah AGM", 12, 100, 200, { maxDischarge: 50 }),
            // 48V LiFePO4 (voltage 51.2V nominal)
            _battPreset("48V 100Ah LiFePO4", 51.2, 100, 1500),
            _battPreset("EG4 48V 100Ah LiFePO4", 51.2, 100, 1400),
            _battPreset("EG4 48V 200Ah LiFePO4", 51.2, 200, 2600),
            _battPreset("EG4 48V 280Ah LiFePO4", 51.2, 280, 3200),
            _battPreset("Zoom 48V 100Ah LiFePO4", 51.2, 100, 1350),
            _battPreset("Zoom 48V 200Ah LiFePO4", 51.2, 200, 2500),
            _battPreset("Ruixu 48V 100Ah LiFePO4", 51.2, 100, 1300),
            _battPreset("Ruixu 48V 200Ah LiFePO4", 51.2, 200, 2400),
            _battPreset("Server Rack 48V 100Ah", 51.2, 100, 1200),
            _battPreset("Server Rack 48V 200Ah", 51.2, 200, 2200),
            _battPreset("Big Battery 48V 100Ah LiFePO4", 51.2, 100, 1450),
            _battPreset("Big Battery 48V 200Ah LiFePO4", 51.2, 200, 2700),
            _battPreset("EcoWorthy 12V 100Ah LiFePO4", 12.8, 100, 380),
            _battPreset("EcoWorthy 12V 200Ah LiFePO4", 12.8, 200, 680),
            _battPreset("EcoWorthy 48V 100Ah LiFePO4", 51.2, 100, 1380),
            // EcoFlow Smart Batteries
            _battPreset("EcoFlow DELTA Pro Smart Battery", 48, 75, 1800, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow DELTA 2 Smart Battery", 48, 20.8, 800, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow DELTA 2 Max Smart Battery", 48, 41.7, 1100, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow RIVER 2 Max Smart Battery", 48, 10.7, 400, { smartBattery: true, ecosystemType: 'ecoflow' }),
            _battPreset("EcoFlow RIVER 2 Pro Smart Battery", 48, 16, 500, { smartBattery: true, ecosystemType: 'ecoflow' })
        ];
        
        // Controller presets - factory with common defaults
        const _CTRL_DEFAULTS = { type: 'charge_controller', minVmp: 15, mppVoltageMin: 18, supportedVoltages: [12,24,48], width: 400, height: 600 };
        const _ctrlPreset = (name, specs) => ({ ..._CTRL_DEFAULTS, name, mppVoltageMax: specs.maxVoc - 5, ...specs });
        const CONTROLLER_PRESETS = [
            // Charge Controllers
            _ctrlPreset("Generic MPPT 150/50", { maxVoc: 150, maxIsc: 50, maxWmp: 2400, ratedChargeCurrent: 50, cost: 250 }),
            _ctrlPreset("Victron SmartSolar 150/35", { maxVoc: 150, maxIsc: 35, maxWmp: 2000, ratedChargeCurrent: 35, supportedVoltages: [12,24,36,48], width: 350, height: 550, cost: 400 }),
            _ctrlPreset("Generic MPPT 100/20", { maxVoc: 100, maxIsc: 20, maxWmp: 520, mppVoltageMax: 95, ratedChargeCurrent: 20, supportedVoltages: [12,24], width: 300, height: 500, cost: 80 }),
            _ctrlPreset("Victron SmartSolar 250/100", { maxVoc: 250, maxIsc: 100, maxWmp: 5800, mppVoltageMax: 230, ratedChargeCurrent: 100, supportedVoltages: [12,24,36,48], height: 650, cost: 800 }),
            _ctrlPreset("Renogy Rover 40A MPPT", { maxVoc: 100, maxIsc: 40, maxWmp: 1040, mppVoltageMax: 95, ratedChargeCurrent: 40, supportedVoltages: [12,24], width: 320, height: 520, cost: 120 }),
            // Hybrid Inverters
            _ctrlPreset("PowMR 5000W", { type: 'hybrid_inverter', maxVoc: 145, maxIsc: 80, maxWmp: 5000, minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 115, ratedChargeCurrent: 80, supportedVoltages: [48], maxACOutputW: 5000, width: 450, height: 700, cost: 600 }),
            _ctrlPreset("Victron MultiPlus-II 48/5000", { type: 'hybrid_inverter', maxVoc: 150, maxIsc: 100, maxWmp: 7000, minVmp: 60, mppVoltageMin: 60, ratedChargeCurrent: 100, supportedVoltages: [48], maxACOutputW: 5000, width: 500, height: 750, cost: 2500 }),
            _ctrlPreset("Renogy 3000W Inverter", { type: 'hybrid_inverter', maxVoc: 145, maxIsc: 50, maxWmp: 4000, minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 140, ratedChargeCurrent: 50, supportedVoltages: [12,24], maxACOutputW: 3000, width: 420, height: 650, cost: 600 }),
            _ctrlPreset("PowMR 3000W Hybrid", { type: 'hybrid_inverter', maxVoc: 145, maxIsc: 60, maxWmp: 3000, minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 115, ratedChargeCurrent: 60, supportedVoltages: [48], maxACOutputW: 3000, width: 420, height: 650, cost: 500 }),
            _ctrlPreset("LuxPower 6000XP", { type: 'hybrid_inverter', mpptCount: 2, maxVoc: 480, maxIsc: 34, maxWmp: 8000, minVmp: 100, mppVoltageMin: 120, mppVoltageMax: 385, ratedChargeCurrent: 125, supportedVoltages: [48], maxACOutputW: 6000, width: 500, height: 750, cost: 1450 }),
            _ctrlPreset("GroWatt 3000W Inverter", { type: 'hybrid_inverter', maxVoc: 145, maxIsc: 50, maxWmp: 3000, minVmp: 60, mppVoltageMin: 60, mppVoltageMax: 115, ratedChargeCurrent: 50, supportedVoltages: [48], maxACOutputW: 3000, width: 420, height: 650, cost: 550 }),
            // All-in-One (EcoFlow ecosystem)
            _ctrlPreset("EcoFlow DELTA Pro", { type: 'all_in_one', maxVoc: 150, maxIsc: 15, maxWmp: 1600, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 30, supportedVoltages: [48], internalBatteryKWh: 3.6, maxACOutputW: 3600, smartBatteryPorts: 2, smartBatteryKWh: 3.6, parallelCapable: true, ecosystemType: 'ecoflow', width: 500, height: 800, cost: 3500 }),
            _ctrlPreset("EcoFlow DELTA 2", { type: 'all_in_one', maxVoc: 60, maxIsc: 15, maxWmp: 500, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 15, supportedVoltages: [48], internalBatteryKWh: 1, maxACOutputW: 1800, smartBatteryPorts: 1, smartBatteryKWh: 1, ecosystemType: 'ecoflow', cost: 1000 }),
            _ctrlPreset("EcoFlow DELTA 2 Max", { type: 'all_in_one', maxVoc: 60, maxIsc: 15, maxWmp: 500, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 15, supportedVoltages: [48], internalBatteryKWh: 2, maxACOutputW: 2400, smartBatteryPorts: 2, smartBatteryKWh: 2, ecosystemType: 'ecoflow', height: 650, cost: 2100 }),
            _ctrlPreset("EcoFlow RIVER 2", { type: 'all_in_one', maxVoc: 60, maxIsc: 10, maxWmp: 220, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 8, supportedVoltages: [48], internalBatteryKWh: 0.256, maxACOutputW: 300, ecosystemType: 'ecoflow', width: 300, height: 400, cost: 250 }),
            _ctrlPreset("EcoFlow RIVER 2 Max", { type: 'all_in_one', maxVoc: 60, maxIsc: 13, maxWmp: 220, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 10, supportedVoltages: [48], internalBatteryKWh: 0.512, maxACOutputW: 500, smartBatteryPorts: 1, smartBatteryKWh: 0.512, ecosystemType: 'ecoflow', width: 320, height: 450, cost: 450 }),
            _ctrlPreset("EcoFlow RIVER 2 Pro", { type: 'all_in_one', maxVoc: 60, maxIsc: 13, maxWmp: 220, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 10, supportedVoltages: [48], internalBatteryKWh: 0.768, maxACOutputW: 800, smartBatteryPorts: 1, smartBatteryKWh: 0.768, ecosystemType: 'ecoflow', width: 320, height: 480, cost: 600 }),
            _ctrlPreset("Anker Solix F3800", { type: 'all_in_one', maxVoc: 150, maxIsc: 20, maxWmp: 2400, minVmp: 11, mppVoltageMin: 11, ratedChargeCurrent: 40, supportedVoltages: [48], internalBatteryKWh: 3.84, maxACOutputW: 3800, parallelCapable: true, width: 500, height: 800, cost: 4000 })
        ];
        
        // Simple presets - compact format with shared defaults
        const BREAKER_PRESETS = [10,20,30,40,50,63].map((r,i) => ({ name: `DC Breaker ${r}A`, rating: r, maxVoltage: 150, cost: 15 + i*4 }));
        
        const GENERATOR_PRESETS = [
            { name: "Honda Generator 2000W", outputWatts: 2000, voltage: 120, fuelType: "gasoline", cost: 1000 },
            { name: "Honda Generator 3000W", outputWatts: 3000, voltage: 120, fuelType: "gasoline", cost: 1500 },
            { name: "48V 1000W Range Extender", outputWatts: 1000, voltage: 48, fuelType: "DC", cost: 800 },
            { name: "EcoFlow Smart Generator", outputWatts: 4000, voltage: 120, fuelType: "propane", cost: 2000 },
            { name: "Diesel Generator 6kW", outputWatts: 6000, voltage: 240, fuelType: "diesel", cost: 5000 },
            { name: "VAWT Wind Turbine 500W", outputWatts: 500, voltage: 48, fuelType: "wind", cost: 1200 },
            { name: "HAWT Wind Turbine 1000W", outputWatts: 1000, voltage: 48, fuelType: "wind", cost: 2000 },
            { name: "HydroTurbine 2000W", outputWatts: 2000, voltage: 48, fuelType: "hydro", cost: 3000 }
        ];
        
        const AC_DISTRIBUTION_PRESETS = [{ name: "Shelly 4pm", circuits: 4, maxAmpsPerCircuit: 16, voltage: 120, cost: 80 }];
        const COMBINER_PRESETS = [2,4,6].map(n => ({ name: `${n}-String Combiner`, inputs: n, maxAmpsPerInput: 15, cost: 10 + n*10 }));
        const SOLAR_COMBINER_PRESETS = [2,4,6].map(n => ({ name: `${n}-String Solar Combiner Box`, inputs: n, breakerRating: 15, maxVoltage: 150, cost: 20 + n*20 }));
        
        // Calculate max watts based on battery voltage and charge current
        // Charging voltage is typically ~1.2x nominal (14.4V for 12V, 28.8V for 24V, 57.6V for 48V)
        // Also respects the controller's maxWmp (max PV input) if specified
        function getMaxWattsForController(controller, batteryVoltage) {
            const chargingVoltage = batteryVoltage * 1.2;
            const calculatedMax = Math.round(controller.specs.ratedChargeCurrent * chargingVoltage);
            
            // If controller has a maxWmp limit, use the lower of the two
            if (controller.specs.maxWmp && controller.specs.maxWmp > 0) {
                return Math.min(calculatedMax, controller.specs.maxWmp);
            }
            return calculatedMax;
        }
        
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentMode = 'build'; // 'build', 'live', or 'simulate'
        
        // ============================================
        // LIVE VIEW MODULE
        // ============================================
        const LiveView = {
            // State management
            state: {
                active: false,
                loadStates: {},      // { loadId: true/false }
                breakerStates: {},   // { breakerId: { isClosed: true/false, wasTripped: false } }
                powerFlow: {},       // { connectionId: { watts, amps, voltage, direction } }
                powerFlowCache: {}   // Cache for power flow calculations
            },
            
            // Power flow calculations
            PowerFlow: {
                calculate: function() {
                    LiveView.state.powerFlow = {};
                    
                    // Calculate DC power flow (solar ‚Üí controller ‚Üí battery)
                    const controllers = allItems.filter(i => i.type === 'controller');
                    controllers.forEach(controller => {
                        // Calculate array output
                        const arraySpecs = calculateConnectedArraySpecs(controller);
                        const arrayWatts = arraySpecs.wmp || 0;
                        
                        // Find connections from panels to controller
                        if (controller.handles?.pvPositive?.connectedTo && controller.handles?.pvNegative?.connectedTo) {
                            controller.handles.pvPositive.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Estimate current based on array specs
                                    const voltage = arraySpecs.vmp || arraySpecs.voc || 48;
                                    const amps = arrayWatts / voltage;
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: arrayWatts / (controller.handles.pvPositive.connectedTo.length || 1),
                                        amps: amps / (controller.handles.pvPositive.connectedTo.length || 1),
                                        voltage: voltage,
                                        direction: 'to-controller'
                                    };
                                }
                            });
                        }
                        
                        // Calculate AC output from controller
                        if (controller.handles?.acOutput) {
                            controller.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // AC output is limited by controller max AC output
                                    const maxACWatts = controller.specs.maxACOutputW || 0;
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: maxACWatts,
                                        amps: maxACWatts / 120, // Default 120V
                                        voltage: 120,
                                        direction: 'from-controller'
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate AC power flow (controller ‚Üí breaker ‚Üí outlet ‚Üí load)
                    const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                    acBreakers.forEach(breaker => {
                        // Use unified breaker state checking
                        if (!LiveView.BreakerManager.isBreakerClosed(breaker)) return;
                        
                        // Verify breaker is connected to a power source
                        if (!hasPowerSourceConnection(breaker)) return;
                        
                        // Calculate circuit amperage
                        const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                        
                        // Update connections from breaker to outlets
                        // Show power flow even when no loads are connected (circuit is live)
                        if (breaker.handles?.loadOut) {
                            breaker.handles.loadOut.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const voltage = breaker.specs.voltage || 120;
                                    const totalWatts = circuitInfo.totalWatts;
                                    // Set power flow even if watts is 0 - circuit is live
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: totalWatts,
                                        amps: circuitInfo.totalAmps,
                                        voltage: voltage,
                                        direction: 'from-breaker',
                                        isLive: true // Mark as live circuit
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate AC power flow for breaker panel circuits
                    const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                    breakerPanels.forEach(panel => {
                        if (panel.mainBreakerOn === false) return;
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        
                        for (let i = 0; i < 8; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = panel.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) continue;
                            
                            // Verify panel is connected to a power source
                            if (!hasPowerSourceConnection(panel)) continue;
                            
                            const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, circuitHandle);
                            
                            // Update connections from circuit handle to outlets
                            if (circuitHandle.connectedTo) {
                                circuitHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        const voltage = circuitHandle.voltage || 120;
                                        const totalWatts = circuitInfo.totalWatts;
                                        // Set power flow even if watts is 0 - circuit is live
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: totalWatts,
                                            amps: circuitInfo.totalAmps,
                                            voltage: voltage,
                                            direction: 'from-breaker',
                                            isLive: true // Mark as live circuit
                                        };
                                    }
                                });
                            }
                        }
                    });
                    
                    // Calculate AC power flow for spider box circuits
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    spiderBoxes.forEach(spiderbox => {
                        if (!spiderbox.handles) return;
                        
                        // Check each circuit
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) continue;
                            
                            // Verify spider box is connected to a power source
                            if (!hasPowerSourceConnection(spiderbox)) continue;
                            
                            // Calculate circuit info (spider box circuits work like breaker panel circuits)
                            const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, circuitHandle);
                            
                            // Update connections from circuit handle to outlets
                            if (circuitHandle.connectedTo) {
                                circuitHandle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        const voltage = circuitHandle.voltage || 120;
                                        const totalWatts = circuitInfo.totalWatts;
                                        // Set power flow even if watts is 0 - circuit is live
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: totalWatts,
                                            amps: circuitInfo.totalAmps,
                                            voltage: voltage,
                                            direction: 'from-breaker',
                                            isLive: true // Mark as live circuit
                                        };
                                    }
                                });
                            }
                        }
                    });
                    
                    // Calculate power flow for outlet-to-load connections
                    const outlets = allItems.filter(i => i.type === 'acoutlet');
                    outlets.forEach(outlet => {
                        // Check if outlet is live
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) return;
                        
                        const outletVoltage = outlet.specs.voltage || 120;
                        
                        // Check connections from outlet to loads
                        if (outlet.handles?.load) {
                            outlet.handles.load.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Find the load
                                    const load = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acload'
                                    );
                                    if (load) {
                                        const loadWatts = LiveView.state.loadStates[load.id] ? getLoadWatts(load) : 0;
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: loadWatts,
                                            amps: loadWatts / outletVoltage,
                                            voltage: outletVoltage,
                                            direction: 'to-load',
                                            isLive: true
                                        };
                                    }
                                }
                            });
                        }
                        
                        // Check daisy-chain connections (outlet to outlet)
                        if (outlet.handles?.output) {
                            outlet.handles.output.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    // Check if this connects to another outlet's input
                                    const otherOutlet = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acoutlet' &&
                                        i.id !== outlet.id
                                    );
                                    if (otherOutlet) {
                                        // Calculate total power downstream from this outlet
                                        const downstreamInfo = LiveView.PowerFlow.calculateDownstreamPower(otherOutlet);
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: downstreamInfo.totalWatts,
                                            amps: downstreamInfo.totalAmps,
                                            voltage: outletVoltage,
                                            direction: 'to-outlet',
                                            isLive: true
                                        };
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for parallel connections (Delta Pro to double voltage hub)
                    controllers.forEach(controller => {
                        if (controller.handles?.parallelPort) {
                            controller.handles.parallelPort.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const targetItem = allItems.find(i => 
                                        i.id === connObj.targetItemId || i.id === connObj.sourceItemId
                                    );
                                    if (targetItem && targetItem.type === 'doublevoltagehub') {
                                        // Calculate AC output from controller (parallel connection)
                                        const arraySpecs = calculateConnectedArraySpecs(controller);
                                        const dcInputWatts = arraySpecs.wmp || 0;
                                        const acOutputWatts = Math.min(dcInputWatts, controller.specs.maxACOutputW || 0);
                                        
                                        // Mark as live when connected (controller has power capability or internal battery)
                                        const hasPowerSource = dcInputWatts > 0 || controller.specs.internalBatteryKWh > 0;
                                        
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: acOutputWatts,
                                            amps: acOutputWatts / 120,
                                            voltage: 120, // Each unit outputs 120V
                                            direction: 'to-hub',
                                            isLive: true // Always live when connected to hub
                                        };
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for double voltage hub AC output (240V to breaker panel/spiderbox)
                    const hubs = allItems.filter(i => i.type === 'doublevoltagehub');
                    hubs.forEach(hub => {
                        // Check if hub has both inputs connected (both Delta Pros connected)
                        const input1Connected = hub.handles?.input1?.connectedTo?.length > 0;
                        const input2Connected = hub.handles?.input2?.connectedTo?.length > 0;
                        
                        if (input1Connected && input2Connected && hub.handles?.acOutput) {
                            // Calculate total power from both inputs
                            let totalWatts = 0;
                            let hasLiveInput = false;
                            
                            hub.handles.input1.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const powerFlow = LiveView.state.powerFlow[connObj.id];
                                    if (powerFlow) {
                                        totalWatts += powerFlow.watts || 0;
                                        if (powerFlow.isLive) hasLiveInput = true;
                                    }
                                }
                            });
                            hub.handles.input2.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const powerFlow = LiveView.state.powerFlow[connObj.id];
                                    if (powerFlow) {
                                        totalWatts += powerFlow.watts || 0;
                                        if (powerFlow.isLive) hasLiveInput = true;
                                    }
                                }
                            });
                            
                            // Mark as live if both inputs are connected and at least one has live power
                            hub.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    LiveView.state.powerFlow[connObj.id] = {
                                        watts: totalWatts,
                                        amps: totalWatts / 240, // 240V split-phase
                                        voltage: 240,
                                        direction: 'from-hub',
                                        isLive: hasLiveInput || (input1Connected && input2Connected) // Live when both inputs connected
                                    };
                                }
                            });
                        }
                    });
                    
                    // Calculate power flow for controller/hub to breaker panel connections
                    // Reuse controllers variable from DC power flow calculation above
                    controllers.forEach(controller => {
                        // Check AC output connections
                        if (controller.handles?.acOutput) {
                            controller.handles.acOutput.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const targetItem = allItems.find(i => 
                                        i.id === connObj.targetItemId || i.id === connObj.sourceItemId
                                    );
                                    if (targetItem && (targetItem.type === 'breakerpanel' || targetItem.type === 'acbreaker' || targetItem.type === 'spiderbox')) {
                                        // Calculate AC output from controller
                                        const arraySpecs = calculateConnectedArraySpecs(controller);
                                        const dcInputWatts = arraySpecs.wmp || 0;
                                        const acOutputWatts = Math.min(dcInputWatts, controller.specs.maxACOutputW || 0);
                                        
                                        LiveView.state.powerFlow[connObj.id] = {
                                            watts: acOutputWatts,
                                            amps: acOutputWatts / 120, // Assume 120V for calculation
                                            voltage: 120,
                                            direction: 'from-controller',
                                            isLive: acOutputWatts > 0
                                        };
                                    }
                                }
                            });
                        }
                    });
                },
                
                // Helper function to calculate downstream power from an outlet
                calculateDownstreamPower: function(outlet) {
                    let totalWatts = 0;
                    let totalAmps = 0;
                    const outletVoltage = outlet.specs.voltage || 120;
                    const visited = new Set();
                    
                    function traceDownstream(currentOutlet) {
                        if (visited.has(currentOutlet.id)) return;
                        visited.add(currentOutlet.id);
                        
                        // Check loads connected to this outlet
                        if (currentOutlet.handles?.load) {
                            currentOutlet.handles.load.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const load = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acload'
                                    );
                                    if (load && LiveView.state.loadStates[load.id]) {
                                        totalWatts += getLoadWatts(load);
                                    }
                                }
                            });
                        }
                        
                        // Check downstream outlets
                        if (currentOutlet.handles?.output) {
                            currentOutlet.handles.output.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    const nextOutlet = allItems.find(i => 
                                        (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                        i.type === 'acoutlet' &&
                                        i.id !== currentOutlet.id
                                    );
                                    if (nextOutlet) {
                                        traceDownstream(nextOutlet);
                                    }
                                }
                            });
                        }
                    }
                    
                    traceDownstream(outlet);
                    totalAmps = totalWatts / outletVoltage;
                    return { totalWatts, totalAmps };
                },
                
                // Calculate AC circuit amperage for a breaker
                calculateACCircuit: function(breaker) {
                    // Use unified breaker state checking - must be closed AND not tripped
                    if (!breaker || !LiveView.BreakerManager.isBreakerClosed(breaker)) {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    // Get circuit voltage from breaker specs
                    let circuitVoltage = breaker.specs.voltage || 120;
                    
                    // For breaker panels and spider boxes, check the circuit voltage
                    if (breaker.handles?.circuitName) {
                        // This is a circuit from a breaker panel or spider box
                        const circuitHandle = Object.values(breaker.handles).find(h => h.circuitName);
                        if (circuitHandle && circuitHandle.voltage) {
                            circuitVoltage = circuitHandle.voltage;
                        }
                    }
                    
                    let totalWatts = 0;
                    const contributingLoads = [];
                    
                    // Trace from breaker output through all connected outlets
                    function traceCircuitFromHandle(handle, visited = new Set(), currentVoltage = circuitVoltage) {
                        if (!handle || !handle.connectedTo) return;
                        
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // Find the item on the other end of this connection
                            // Check which item contains this handle
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            
                            let nextItem = null;
                            // Check if this handle belongs to the source item
                            if (sourceItem && sourceItem.handles && 
                                (connObj.sourceHandleId === handle.id || 
                                 Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                                // This handle is on the source item, so next item is the target
                                nextItem = targetItem;
                            } else if (targetItem && targetItem.handles && 
                                       (connObj.targetHandleId === handle.id ||
                                        Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                                // This handle is on the target item, so next item is the source
                                nextItem = sourceItem;
                            }
                            
                            if (!nextItem || visited.has(nextItem.id)) return;
                            visited.add(nextItem.id);
                            
                            // If it's an outlet, check for loads connected to it
                            if (nextItem.type === 'acoutlet') {
                                // Use outlet's voltage if specified, otherwise use circuit voltage
                                const outletVoltage = nextItem.specs?.voltage || nextItem.handles?.input?.voltage || currentVoltage;
                                
                                // Check load port for connected loads
                                if (nextItem.handles?.load) {
                                    nextItem.handles.load.connectedTo.forEach(loadConn => {
                                        const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                        if (loadConnObj) {
                                            // Find the load - could be source or target
                                            let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                            if (!load || load.type !== 'acload') {
                                                load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                            }
                                            
                                            if (load && load.type === 'acload') {
                                                // Check if load is ON
                                                if (LiveView.state.loadStates[load.id]) {
                                                    // Verify load voltage matches outlet voltage (or is compatible)
                                                    const loadVoltage = load.specs.voltage || 120;
                                                    if (loadVoltage === outletVoltage || (outletVoltage === 240 && loadVoltage === 120)) {
                                                        const loadWatts = getLoadWatts(load);
                                                        totalWatts += loadWatts;
                                                        contributingLoads.push({
                                                            id: load.id,
                                                            name: load.specs.name,
                                                            watts: loadWatts,
                                                            voltage: loadVoltage
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also trace through outlet output (daisy-chained outlets)
                                if (nextItem.handles?.output) {
                                    traceCircuitFromHandle(nextItem.handles.output, visited, outletVoltage);
                                }
                            }
                        });
                    }
                    
                    // Start tracing from breaker output
                    if (breaker.handles?.loadOut) {
                        traceCircuitFromHandle(breaker.handles.loadOut);
                    }
                    
                    // Calculate amps based on circuit voltage
                    // For 240V circuits, use 240V. For 120V circuits, use 120V.
                    // For split-phase (120V from 240V), still use 120V for calculation
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    
                    return {
                        totalWatts: totalWatts,
                        totalAmps: totalAmps,
                        loads: contributingLoads,
                        voltage: circuitVoltage
                    };
                },
                
                // Calculate AC circuit amperage for a breaker panel or spider box circuit handle
                calculateBreakerPanelCircuit: function(panel, circuitHandle) {
                    if (!panel || !circuitHandle || !circuitHandle.connectedTo) {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    // Use unified breaker state checking - must be closed AND not tripped
                    const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                    
                    // Check if it's a breaker panel or spider box
                    if (panel.type === 'breakerpanel') {
                        if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, circuitIndex)) {
                            return { totalWatts: 0, totalAmps: 0, loads: [] };
                        }
                    } else if (panel.type === 'spiderbox') {
                        if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(panel, circuitIndex)) {
                            return { totalWatts: 0, totalAmps: 0, loads: [] };
                        }
                    } else {
                        return { totalWatts: 0, totalAmps: 0, loads: [] };
                    }
                    
                    const circuitVoltage = circuitHandle.voltage || 120;
                    let totalWatts = 0;
                    const contributingLoads = [];
                    const visited = new Set();
                    const visitedItems = new Set(); // Track visited items to prevent cross-circuit contamination
                    
                    // Track the original circuit handle ID to prevent tracing back to other circuits
                    const originalCircuitHandleId = circuitHandle.id;
                    
                    // Trace from circuit handle through all connected outlets
                    // IMPORTANT: Only trace from the specific circuit handle we're checking
                    function traceCircuitFromHandle(handle, currentVoltage = circuitVoltage) {
                        if (!handle || !handle.connectedTo || visited.has(handle.id)) return;
                        visited.add(handle.id);
                        
                        handle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // CRITICAL: Verify this connection is actually from our circuit handle
                            // The connection must have our handle ID on one end, and it must be the EXACT handle we're tracing from
                            const isFromOurHandle = (connObj.sourceHandleId === handle.id || connObj.targetHandleId === handle.id);
                            if (!isFromOurHandle) return;
                            
                            // Double-check: ensure the handle ID matches exactly (not just a substring match)
                            if (connObj.sourceHandleId !== handle.id && connObj.targetHandleId !== handle.id) return;
                            
                            // CRITICAL: If this is the initial circuit handle and the connection leads to another circuit handle, STOP
                            // This prevents any possibility of cross-circuit contamination at the source
                            if (handle.id === originalCircuitHandleId) {
                                const otherHandleId = connObj.sourceHandleId === handle.id ? connObj.targetHandleId : connObj.sourceHandleId;
                                if (otherHandleId && otherHandleId.startsWith(`${panel.id}-circuit-`) && otherHandleId !== originalCircuitHandleId) {
                                    return; // This connection goes to another circuit - don't follow it
                                }
                            }
                            
                            // CRITICAL: If this connection leads to another circuit handle on the same panel, STOP
                            // This prevents cross-circuit contamination
                            if (connObj.sourceHandleId !== handle.id && connObj.sourceHandleId.startsWith(`${panel.id}-circuit-`)) {
                                // This is a different circuit handle - don't follow it
                                if (connObj.sourceHandleId !== originalCircuitHandleId) return;
                            }
                            if (connObj.targetHandleId !== handle.id && connObj.targetHandleId.startsWith(`${panel.id}-circuit-`)) {
                                // This is a different circuit handle - don't follow it
                                if (connObj.targetHandleId !== originalCircuitHandleId) return;
                            }
                            
                            // Find the item on the other end of this connection (not the panel)
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            
                            let nextItem = null;
                            // The circuit handle is on the panel, so the next item is the one that's NOT the panel
                            if (sourceItem && sourceItem.id === panel.id) {
                                nextItem = targetItem;
                            } else if (targetItem && targetItem.id === panel.id) {
                                nextItem = sourceItem;
                            } else {
                                // Neither is the panel - this shouldn't happen, but handle it
                                if (sourceItem && sourceItem.handles && 
                                    (connObj.sourceHandleId === handle.id || 
                                     Object.values(sourceItem.handles).some(h => h.id === handle.id))) {
                                    nextItem = targetItem;
                                } else if (targetItem && targetItem.handles && 
                                           (connObj.targetHandleId === handle.id ||
                                            Object.values(targetItem.handles).some(h => h.id === handle.id))) {
                                    nextItem = sourceItem;
                                }
                            }
                            
                            // CRITICAL: If nextItem is the panel itself, skip it (we're already past the circuit handle)
                            if (nextItem && nextItem.id === panel.id) return;
                            
                            // CRITICAL: If nextItem is another circuit handle on the panel, skip it
                            if (nextItem && nextItem.type === 'breakerpanel' && nextItem.id === panel.id) {
                                // Check if any of the handles on this item are other circuit handles
                                const otherCircuitHandle = Object.values(nextItem.handles || {}).find(h => 
                                    h.id && h.id.startsWith(`${panel.id}-circuit-`) && h.id !== originalCircuitHandleId
                                );
                                if (otherCircuitHandle) return; // Don't follow connections to other circuits
                            }
                            
                            if (!nextItem || visitedItems.has(nextItem.id)) return;
                            visitedItems.add(nextItem.id);
                            
                            // If it's an outlet, check for loads connected to it
                            if (nextItem.type === 'acoutlet') {
                                // CRITICAL: Verify this outlet is actually connected to our circuit
                                // We should only reach this outlet by tracing from our circuit handle
                                // Double-check that the outlet's input is connected to a handle we've visited (part of our circuit)
                                const outletInputHandle = nextItem.handles?.input;
                                if (!outletInputHandle) return;
                                
                                // Verify the outlet input is connected to our circuit path
                                // If we reached here through tracing, the connection should be valid, but verify anyway
                                let outletConnectedToOurPath = false;
                                if (outletInputHandle.connectedTo) {
                                    for (const outletConn of outletInputHandle.connectedTo) {
                                        const outletConnObj = connections.find(c => c.id === outletConn.connectionId);
                                        if (outletConnObj) {
                                            // Check if either end of this connection is a handle we've visited (part of our circuit)
                                            if (visited.has(outletConnObj.sourceHandleId) || visited.has(outletConnObj.targetHandleId)) {
                                                outletConnectedToOurPath = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // If we can't verify the outlet is connected to our circuit path, skip it
                                if (!outletConnectedToOurPath) return;
                                
                                const outletVoltage = nextItem.specs?.voltage || nextItem.handles?.input?.voltage || currentVoltage;
                                
                                // Check load port for connected loads
                                if (nextItem.handles?.load) {
                                    nextItem.handles.load.connectedTo.forEach(loadConn => {
                                        const loadConnObj = connections.find(c => c.id === loadConn.connectionId);
                                        if (loadConnObj) {
                                            let load = allItems.find(i => i.id === loadConnObj.targetItemId);
                                            if (!load || load.type !== 'acload') {
                                                load = allItems.find(i => i.id === loadConnObj.sourceItemId);
                                            }
                                            
                                            if (load && load.type === 'acload') {
                                                if (LiveView.state.loadStates[load.id]) {
                                                    const loadVoltage = load.specs.voltage || 120;
                                                    if (loadVoltage === outletVoltage || (outletVoltage === 240 && loadVoltage === 120)) {
                                                        const loadWatts = getLoadWatts(load);
                                                        totalWatts += loadWatts;
                                                        contributingLoads.push({
                                                            id: load.id,
                                                            name: load.specs.name,
                                                            watts: loadWatts,
                                                            voltage: loadVoltage
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also trace through outlet output (daisy-chained outlets)
                                // IMPORTANT: Only trace if this outlet's output is actually connected
                                // and we haven't already visited it from a different circuit
                                if (nextItem.handles?.output && !visited.has(nextItem.handles.output.id)) {
                                    // Verify the outlet's output is connected to something
                                    if (nextItem.handles.output.connectedTo && nextItem.handles.output.connectedTo.length > 0) {
                                        // CRITICAL: Check that the output doesn't connect back to another circuit handle
                                        let connectsToOtherCircuit = false;
                                        for (const outputConn of nextItem.handles.output.connectedTo) {
                                            const outputConnObj = connections.find(c => c.id === outputConn.connectionId);
                                            if (outputConnObj) {
                                                // Check if this connection leads to another circuit handle on the panel
                                                if (outputConnObj.sourceHandleId && outputConnObj.sourceHandleId.startsWith(`${panel.id}-circuit-`)) {
                                                    if (outputConnObj.sourceHandleId !== originalCircuitHandleId) {
                                                        connectsToOtherCircuit = true;
                                                        break;
                                                    }
                                                }
                                                if (outputConnObj.targetHandleId && outputConnObj.targetHandleId.startsWith(`${panel.id}-circuit-`)) {
                                                    if (outputConnObj.targetHandleId !== originalCircuitHandleId) {
                                                        connectsToOtherCircuit = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        
                                        // Only trace if it doesn't connect to another circuit
                                        if (!connectsToOtherCircuit) {
                                            traceCircuitFromHandle(nextItem.handles.output, outletVoltage);
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Start tracing from circuit handle - ONLY trace from this specific handle
                    // Clear visited sets to ensure we start fresh for each circuit calculation
                    visited.clear();
                    visitedItems.clear();
                    traceCircuitFromHandle(circuitHandle);
                    
                    const totalAmps = circuitVoltage > 0 ? totalWatts / circuitVoltage : 0;
                    
                    return {
                        totalWatts: totalWatts,
                        totalAmps: totalAmps,
                        loads: contributingLoads,
                        voltage: circuitVoltage
                    };
                }
            },
            
            // Breaker management
            BreakerManager: {
                // Helper function to get breaker state from LiveView.state
                getBreakerState: function(breakerId) {
                    return LiveView.state.breakerStates[breakerId] || null;
                },
                
                // Check if a regular AC breaker is closed and not tripped
                isBreakerClosed: function(breaker) {
                    if (!breaker) return false;
                    const breakerState = LiveView.state.breakerStates[breaker.id];
                    // Breaker must be closed AND not tripped
                    return breaker.isClosed === true && !(breakerState && breakerState.wasTripped);
                },
                
                // Check if a breaker panel circuit is closed and not tripped
                isBreakerPanelCircuitClosed: function(panel, circuitIndex) {
                    if (!panel) return false;
                    // Check main breaker first
                    if (panel.mainBreakerOn === false) return false;
                    // Check circuit breaker state
                    const circuitOn = panel.breakerStates && panel.breakerStates[circuitIndex] !== false;
                    if (!circuitOn) return false;
                    // Check if tripped in live view state
                    const breakerId = `${panel.id}-circuit-${circuitIndex + 1}`;
                    const breakerState = LiveView.state.breakerStates[breakerId];
                    return !(breakerState && breakerState.wasTripped);
                },
                
                // Check if a spider box circuit is closed and not tripped
                isSpiderBoxCircuitClosed: function(spiderbox, circuitIndex) {
                    if (!spiderbox || !spiderbox.handles) return false;
                    // Check main breaker first
                    if (spiderbox.mainBreakerOn === false) return false;
                    const handleKey = `circuit${circuitIndex + 1}`;
                    const circuitHandle = spiderbox.handles[handleKey];
                    if (!circuitHandle) return false;
                    // Check if circuit breaker is closed
                    const circuitOn = circuitHandle.isClosed !== false;
                    if (!circuitOn) return false;
                    // Check if tripped in live view state
                    const breakerId = `${spiderbox.id}-circuit-${circuitIndex + 1}`;
                    const breakerState = LiveView.state.breakerStates[breakerId];
                    return !(breakerState && breakerState.wasTripped);
                },
                
                checkTripping: function() {
                    // PHASE 1: Collect all breakers/circuits that need checking (before any state changes)
                    const acBreakersToCheck = [];
                    const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                    
                    acBreakers.forEach(breaker => {
                        // Only check if breaker is currently closed and not tripped
                        if (LiveView.BreakerManager.isBreakerClosed(breaker)) {
                            acBreakersToCheck.push(breaker);
                        }
                    });
                    
                    const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                    const panelCircuitsToCheck = [];
                    
                    breakerPanels.forEach(panel => {
                        // Check main breaker first
                        if (panel.mainBreakerOn === false) return;
                        
                        // Initialize breaker states if needed
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        
                        // Collect all circuits that need to be checked
                        for (let i = 0; i < 8; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = panel.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified helper to check if circuit is closed
                            if (LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) {
                                panelCircuitsToCheck.push({
                                    panel: panel,
                                    index: i,
                                    handle: circuitHandle,
                                    breakerId: `${panel.id}-circuit-${i + 1}`
                                });
                            }
                        }
                    });
                    
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    const spiderBoxCircuitsToCheck = [];
                    
                    spiderBoxes.forEach(spiderbox => {
                        if (!spiderbox.handles || !spiderbox.specs.circuits) return;
                        
                        // Collect all circuits that need to be checked
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Use unified helper to check if circuit is closed
                            if (LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) {
                                spiderBoxCircuitsToCheck.push({
                                    spiderbox: spiderbox,
                                    index: i,
                                    handle: circuitHandle,
                                    breakerId: `${spiderbox.id}-circuit-${i + 1}`
                                });
                            }
                        }
                    });
                    
                    // PHASE 2: Calculate all circuit info (before any state changes)
                    const acBreakerResults = [];
                    acBreakersToCheck.forEach(breaker => {
                        const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                        const breakerRating = breaker.specs.rating || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            acBreakerResults.push({
                                breaker: breaker,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    const panelCircuitResults = [];
                    panelCircuitsToCheck.forEach(({ panel, index, handle, breakerId }) => {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, handle);
                        const breakerRating = handle.maxAmps || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            panelCircuitResults.push({
                                panel: panel,
                                index: index,
                                handle: handle,
                                breakerId: breakerId,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    const spiderBoxCircuitResults = [];
                    spiderBoxCircuitsToCheck.forEach(({ spiderbox, index, handle, breakerId }) => {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, handle);
                        const breakerRating = handle.maxAmps || 0;
                        
                        if (circuitInfo.totalAmps > breakerRating) {
                            spiderBoxCircuitResults.push({
                                spiderbox: spiderbox,
                                index: index,
                                handle: handle,
                                breakerId: breakerId,
                                circuitInfo: circuitInfo,
                                breakerRating: breakerRating
                            });
                        }
                    });
                    
                    // PHASE 3: Apply state changes (all calculations done, now apply trips)
                    let anyTrips = false;
                    
                    acBreakerResults.forEach(({ breaker, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip the breaker - update both isClosed and LiveView.state atomically
                        breaker.isClosed = false;
                        if (!LiveView.state.breakerStates[breaker.id]) {
                            LiveView.state.breakerStates[breaker.id] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breaker.id].isClosed = false;
                            LiveView.state.breakerStates[breaker.id].wasTripped = true;
                        }
                        
                        // Show notification
                        showHint("‚ö†Ô∏è Breaker Tripped", 
                            `Circuit breaker (${breakerRating}A) has tripped due to overcurrent (${circuitInfo.totalAmps.toFixed(1)}A). All loads on this circuit have been turned off.`);
                        
                        // Turn off all loads on this circuit
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    panelCircuitResults.forEach(({ panel, index, handle, breakerId, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip ONLY this specific circuit breaker - update both states atomically
                        panel.breakerStates[index] = false;
                        
                        if (!LiveView.state.breakerStates[breakerId]) {
                            LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breakerId].isClosed = false;
                            LiveView.state.breakerStates[breakerId].wasTripped = true;
                        }
                        
                        // Show notification
                        showHint("‚ö†Ô∏è Breaker Tripped", 
                            `Circuit ${handle.circuitName} (${breakerRating}A) has tripped due to overcurrent (${circuitInfo.totalAmps.toFixed(1)}A). All loads on this circuit have been turned off.`);
                        
                        // Turn off all loads on this circuit ONLY
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    spiderBoxCircuitResults.forEach(({ spiderbox, index, handle, breakerId, circuitInfo, breakerRating }) => {
                        anyTrips = true;
                        // Trip ONLY this specific circuit breaker - update both states atomically
                        handle.isClosed = false;
                        
                        if (!LiveView.state.breakerStates[breakerId]) {
                            LiveView.state.breakerStates[breakerId] = { isClosed: false, wasTripped: true };
                        } else {
                            LiveView.state.breakerStates[breakerId].isClosed = false;
                            LiveView.state.breakerStates[breakerId].wasTripped = true;
                        }
                        
                        // Show notification
                        showHint("‚ö†Ô∏è Breaker Tripped", 
                            `Spider Box Circuit ${handle.circuitName} (${breakerRating}A) has tripped due to overcurrent (${circuitInfo.totalAmps.toFixed(1)}A). All loads on this circuit have been turned off.`);
                        
                        // Turn off all loads on this circuit ONLY
                        circuitInfo.loads.forEach(loadInfo => {
                            LiveView.state.loadStates[loadInfo.id] = false;
                        });
                    });
                    
                    // Schedule update if any breakers tripped
                    if (anyTrips) {
                        // Immediately recalculate power flow to clear isLive for tripped circuits
                        LiveView.PowerFlow.calculate();
                        LiveView.Animation.scheduleUpdate();
                    }
                }
            },
            
            // Display updates
            Display: {
                update: function() {
                    if (!LiveView.state.active) return;
                    
                    // Calculate total DC and AC power
                    let totalDCWatts = 0;
                    let totalACWatts = 0;
                    
                    // Sum DC power from all controllers
                    const controllers = allItems.filter(i => i.type === 'controller');
                    controllers.forEach(controller => {
                        const arraySpecs = calculateConnectedArraySpecs(controller);
                        totalDCWatts += arraySpecs.wmp || 0;
                    });
                    
                    // Helper function to check if a load's circuit is live (breaker is on and not tripped)
                    // Reuse checkLoadCircuitStatus for consistency
                    function isLoadCircuitLive(load) {
                        const circuitStatus = checkLoadCircuitStatus(load);
                        return circuitStatus.isLive;
                    }
                    
                    // Sum AC power from all ON loads that are on live circuits
                    // (Load shutdown is now handled in event handlers for immediate response)
                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                        if (LiveView.state.loadStates[loadId]) {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                // Check if circuit is live
                                if (isLoadCircuitLive(load)) {
                                    // Circuit is live - count power
                                    totalACWatts += getLoadWatts(load);
                                }
                            }
                        }
                    });
                    
                    // Update power summary (both old center and new left-side displays)
                    const dcWattsEl = document.getElementById('liveViewDCWatts');
                    const acWattsEl = document.getElementById('liveViewACWatts');
                    const dcWattsElLeft = document.getElementById('liveViewDCWattsLeft');
                    const acWattsElLeft = document.getElementById('liveViewACWattsLeft');
                    
                    const dcText = totalDCWatts.toFixed(0);
                    const acText = totalACWatts.toFixed(0);
                    
                    if (dcWattsEl && dcWattsEl.textContent !== dcText) {
                        dcWattsEl.textContent = dcText;
                    }
                    if (acWattsEl && acWattsEl.textContent !== acText) {
                        acWattsEl.textContent = acText;
                    }
                    if (dcWattsElLeft && dcWattsElLeft.textContent !== dcText) {
                        dcWattsElLeft.textContent = dcText;
                    }
                    if (acWattsElLeft && acWattsElLeft.textContent !== acText) {
                        acWattsElLeft.textContent = acText;
                    }
                    
                    // Calculate battery level
                    let maxBatteryKwh = 0;
                    controllers.forEach(controller => {
                        const batterySpecs = calculateConnectedBatterySpecs(controller);
                        maxBatteryKwh += batterySpecs.kWh || 0;
                    });
                    
                    // For now, assume battery starts at 50% and changes based on net power
                    const batteryPercent = maxBatteryKwh > 0 ? 50 : 0; // Simplified
                    const batteryLevelText = (maxBatteryKwh * 0.5).toFixed(1);
                    const batteryPercentText = batteryPercent.toFixed(0);
                    
                    const batteryLevelEl = document.getElementById('liveViewBatteryLevel');
                    const batteryPercentEl = document.getElementById('liveViewBatteryPercent');
                    const batteryLevelElLeft = document.getElementById('liveViewBatteryLevelLeft');
                    const batteryPercentElLeft = document.getElementById('liveViewBatteryPercentLeft');
                    
                    if (batteryLevelEl && batteryLevelEl.textContent !== batteryLevelText) {
                        batteryLevelEl.textContent = batteryLevelText;
                    }
                    if (batteryPercentEl && batteryPercentEl.textContent !== batteryPercentText) {
                        batteryPercentEl.textContent = batteryPercentText;
                    }
                    if (batteryLevelElLeft && batteryLevelElLeft.textContent !== batteryLevelText) {
                        batteryLevelElLeft.textContent = batteryLevelText;
                    }
                    if (batteryPercentElLeft && batteryPercentElLeft.textContent !== batteryPercentText) {
                        batteryPercentElLeft.textContent = batteryPercentText;
                    }
                }
            },
            
            // Animation (event-driven updates)
            Animation: {
                updateScheduled: false,
                updateTimeout: null,
                
                start: function() {
                    // No continuous loop - updates will be triggered by events
                    // Perform initial update
                    LiveView.Animation.update();
                },
                
                stop: function() {
                    // Clear any pending updates
                    if (LiveView.Animation.updateTimeout) {
                        clearTimeout(LiveView.Animation.updateTimeout);
                        LiveView.Animation.updateTimeout = null;
                    }
                    LiveView.Animation.updateScheduled = false;
                },
                
                // Perform a full update cycle
                update: function() {
                    if (!LiveView.state.active) return;
                    
                    // Calculate power flow
                    LiveView.PowerFlow.calculate();
                    
                    // Check breaker tripping
                    LiveView.BreakerManager.checkTripping();
                    
                    // Update displays
                    LiveView.Display.update();
                    
                    // Re-render to show changes
                    render();
                    
                    LiveView.Animation.updateScheduled = false;
                },
                
                // Schedule an update (debounced to prevent excessive renders)
                scheduleUpdate: function() {
                    if (!LiveView.state.active) return;
                    
                    // If already scheduled, don't schedule again
                    if (LiveView.Animation.updateScheduled) return;
                    
                    LiveView.Animation.updateScheduled = true;
                    
                    // Clear any existing timeout
                    if (LiveView.Animation.updateTimeout) {
                        clearTimeout(LiveView.Animation.updateTimeout);
                    }
                    
                    // Schedule update on next frame (debounced)
                    LiveView.Animation.updateTimeout = requestAnimationFrame(() => {
                        LiveView.Animation.update();
                    });
                }
            },
            
            // Main functions
            initialize: function() {
                // Validate system
                const controllers = allItems.filter(i => i.type === 'controller');
                if (controllers.length === 0) {
                    showHint("‚ö†Ô∏è No Controller", "You need at least one controller to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                // Check for panels and batteries (solar panels are now optional for testing/designing)
                const panels = allItems.filter(i => i.type === 'panel');
                const batteries = allItems.filter(i => i.type === 'battery' || i.type === 'smartbattery');
                
                let hasPanels = false;
                let hasBatteries = false;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    if (arraySpecs.wmp > 0) hasPanels = true;
                    if (batterySpecs.kWh > 0) hasBatteries = true;
                });
                
                // Solar panels are now optional - allow live mode with batteries only for testing/designing
                // Removed the solar panel requirement check
                
                if (!hasBatteries && batteries.length === 0) {
                    showHint("‚ö†Ô∏è No Batteries", "You need connected batteries to use Live View mode.");
                    setMode('build');
                    return;
                }
                
                // Initialize live view state
                LiveView.state.active = true;
                LiveView.state.loadStates = {};
                LiveView.state.breakerStates = {};
                LiveView.state.powerFlow = {};
                LiveView.state.powerFlowCache = {};
                
                // Initialize all loads to OFF
                allItems.filter(i => i.type === 'acload').forEach(load => {
                    LiveView.state.loadStates[load.id] = false;
                });
                
                // Initialize breaker states (use current state, but track separately)
                allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker').forEach(breaker => {
                    LiveView.state.breakerStates[breaker.id] = {
                        isClosed: breaker.isClosed !== false,
                        wasTripped: false
                    };
                });
                
                // Start live view (initial update)
                LiveView.Animation.start();
            },
            
            stop: function() {
                LiveView.Animation.stop();
                LiveView.state.active = false;
            }
        };
        
        // Legacy state variables - synced with LiveView.state for backward compatibility
        // These are getters/setters that proxy to LiveView.state
        Object.defineProperty(window, 'liveViewActive', {
            get: function() { return LiveView.state.active; },
            set: function(val) { LiveView.state.active = val; }
        });
        Object.defineProperty(window, 'liveViewLoadStates', {
            get: function() { return LiveView.state.loadStates; },
            set: function(val) { LiveView.state.loadStates = val; }
        });
        Object.defineProperty(window, 'liveViewBreakerStates', {
            get: function() { return LiveView.state.breakerStates; },
            set: function(val) { LiveView.state.breakerStates = val; }
        });
        Object.defineProperty(window, 'liveViewPowerFlow', {
            get: function() { return LiveView.state.powerFlow; },
            set: function(val) { LiveView.state.powerFlow = val; }
        });
        
        // ============================================
        // SIMULATE MODE POWER FLOW MODULE
        // ============================================
        const SimulateMode = {
            // Power flow state for simulation
            powerFlow: {}, // { connectionId: { watts, amps, voltage, direction, isLive } }
            resourceFlow: {}, // { connectionId: { isFlowing, direction: 'consuming'|'producing', resourceType } }
            
            // Calculate resource flow for recipe-based loads
            calculateResourceFlow: function() {
                SimulateMode.resourceFlow = {};
                
                if (currentMode !== 'simulate') return;
                
                // Find all active recipe loads
                const recipeLoads = allItems.filter(i => 
                    i.type === 'acload' && 
                    i.specs.recipes && 
                    i.specs.recipes.length > 0 &&
                    i.isProcessing
                );
                
                recipeLoads.forEach(load => {
                    const activeRecipeIndex = load.activeRecipeIndex || 0;
                    const recipe = load.specs.recipes[activeRecipeIndex];
                    if (!recipe) return;
                    
                    // Mark input connections as consuming
                    Object.values(load.handles || {}).forEach(handle => {
                        if (handle.polarity === 'input' && handle.connectedTo) {
                            handle.connectedTo.forEach(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (connObj) {
                                    SimulateMode.resourceFlow[connObj.id] = {
                                        isFlowing: true,
                                        direction: 'consuming',
                                        resourceType: handle.resourceType
                                    };
                                }
                            });
                        }
                        
                        // Mark output connections as producing (only if recipe is near completion or has outputs)
                        if (handle.polarity === 'output' && handle.connectedTo) {
                            // Check if recipe produces outputs
                            const recipeOutputs = recipe.outputs || [];
                            if (recipeOutputs.length > 0) {
                                handle.connectedTo.forEach(conn => {
                                    const connObj = connections.find(c => c.id === conn.connectionId);
                                    if (connObj) {
                                        SimulateMode.resourceFlow[connObj.id] = {
                                            isFlowing: true,
                                            direction: 'producing',
                                            resourceType: handle.resourceType
                                        };
                                    }
                                });
                            }
                        }
                    });
                });
            },
            
            // Calculate power flow during simulation
            calculatePowerFlow: function() {
                SimulateMode.powerFlow = {};
                
                // Also calculate resource flow
                SimulateMode.calculateResourceFlow();
                
                // Calculate power flow even when paused, so wire glow works
                if (currentMode !== 'simulate') return;
                
                // Calculate total AC power being consumed
                let totalACWatts = 0;
                const allLoads = allItems.filter(i => i.type === 'acload' || i.type === 'processor');
                allLoads.forEach(load => {
                    if (load.simState && load.simState.isRunning) {
                        totalACWatts += load.simState.currentPowerWatts || 0;
                    }
                });
                
                // Helper to get watts for a specific load
                const getLoadPowerWatts = (load) => {
                    if (load.simState && load.simState.isRunning) {
                        return load.simState.currentPowerWatts || 0;
                    }
                    return 0;
                };
                
                // Helper to calculate total watts for all loads connected to an outlet
                const getOutletTotalWatts = (outlet) => {
                    let watts = 0;
                    const checkConnection = (conn) => {
                        const connObj = connections.find(c => c.id === conn.connectionId);
                        if (connObj) {
                            const load = allItems.find(i => 
                                (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                                (i.type === 'acload' || i.type === 'processor')
                            );
                            if (load) {
                                watts += getLoadPowerWatts(load);
                            }
                        }
                    };
                    if (outlet.handles?.load) outlet.handles.load.connectedTo.forEach(checkConnection);
                    if (outlet.handles?.output) outlet.handles.output.connectedTo.forEach(checkConnection);
                    return watts;
                };
                
                // Helper to mark a connection as live with power flow
                const markConnectionLive = (connId, watts, voltage = 120, direction = 'power') => {
                    SimulateMode.powerFlow[connId] = {
                        watts: watts,
                        amps: watts / voltage,
                        voltage: voltage,
                        direction: direction,
                        isLive: true
                    };
                };
                
                // STEP 1: Mark all connections from controllers to panels/breakers
                const controllers = allItems.filter(i => i.type === 'controller');
                controllers.forEach(controller => {
                    const controllerACEnabled = simStats.controllerACOutputEnabled !== false;
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    const batteryCharge = simStats.batteryCharge || 0;
                    const hasBattery = (batterySpecs.kWh || 0) > 0 && batteryCharge > 0;
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const hasSolar = arraySpecs.wmp > 0;
                    const hasPowerSource = hasBattery || hasSolar;
                    const isLive = controllerACEnabled && hasPowerSource;
                    
                    if (isLive && controller.handles?.acOutput) {
                        controller.handles.acOutput.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj) {
                                markConnectionLive(connObj.id, totalACWatts, 120, 'from-controller');
                            }
                        });
                    }
                });
                
                // STEP 2: Mark all breaker panel circuit connections
                const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                breakerPanels.forEach(panel => {
                    if (panel.mainBreakerOn === false) return;
                    
                    // Mark main input connection
                    if (panel.handles?.mainInput) {
                        panel.handles.mainInput.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj && totalACWatts > 0) {
                                markConnectionLive(connObj.id, totalACWatts, 240, 'to-panel');
                            }
                        });
                    }
                    
                    // Mark each circuit connection
                    for (let i = 0; i < 8; i++) {
                        if (panel.breakerStates && panel.breakerStates[i] === false) continue;
                        
                        const circuitHandle = panel.handles[`circuit${i + 1}`];
                        if (!circuitHandle || !circuitHandle.connectedTo) continue;
                        
                        const circuitVoltage = circuitHandle.voltage || 120;
                        
                        circuitHandle.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            // Find the outlet connected to this circuit
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            const outlet = (sourceItem?.type === 'acoutlet') ? sourceItem : 
                                          (targetItem?.type === 'acoutlet') ? targetItem : null;
                            
                            if (outlet) {
                                const circuitWatts = getOutletTotalWatts(outlet);
                                if (circuitWatts > 0) {
                                    markConnectionLive(connObj.id, circuitWatts, circuitVoltage, 'from-panel');
                                }
                            }
                        });
                    }
                });
                
                // STEP 3: Mark all outlet input connections
                const outlets = allItems.filter(i => i.type === 'acoutlet');
                outlets.forEach(outlet => {
                    const circuitStatus = checkOutletCircuitStatus(outlet);
                    if (!circuitStatus.isLive) return;
                    
                    const outletVoltage = outlet.specs.voltage || 120;
                    const outletWatts = getOutletTotalWatts(outlet);
                    
                    // Mark input port connections
                    if (outlet.handles?.input) {
                        outlet.handles.input.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj && outletWatts > 0) {
                                markConnectionLive(connObj.id, outletWatts, outletVoltage, 'to-outlet');
                            }
                        });
                    }
                    
                    // Mark load and output port connections
                    const markLoadConnections = (conn) => {
                        const connObj = connections.find(c => c.id === conn.connectionId);
                        if (!connObj) return;
                        
                        const load = allItems.find(i => 
                            (i.id === connObj.sourceItemId || i.id === connObj.targetItemId) &&
                            (i.type === 'acload' || i.type === 'processor')
                        );
                        if (load) {
                            const loadWatts = getLoadPowerWatts(load);
                            if (loadWatts > 0) {
                                markConnectionLive(connObj.id, loadWatts, outletVoltage, 'to-load');
                            }
                        }
                    };
                    
                    if (outlet.handles?.load) outlet.handles.load.connectedTo.forEach(markLoadConnections);
                    if (outlet.handles?.output) outlet.handles.output.connectedTo.forEach(markLoadConnections);
                });
                
                // STEP 4: Mark standalone AC breaker connections
                const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                acBreakers.forEach(breaker => {
                    if (!LiveView.BreakerManager.isBreakerClosed(breaker)) return;
                    if (!hasPowerSourceConnection(breaker)) return;
                    
                    const breakerVoltage = breaker.specs.voltage || 120;
                    
                    // Mark line input connections
                    if (breaker.handles?.lineIn) {
                        breaker.handles.lineIn.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (connObj && totalACWatts > 0) {
                                markConnectionLive(connObj.id, totalACWatts, breakerVoltage, 'to-breaker');
                            }
                        });
                    }
                    
                    // Mark load output connections
                    if (breaker.handles?.loadOut) {
                        breaker.handles.loadOut.connectedTo.forEach(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return;
                            
                            const sourceItem = allItems.find(i => i.id === connObj.sourceItemId);
                            const targetItem = allItems.find(i => i.id === connObj.targetItemId);
                            const outlet = (sourceItem?.type === 'acoutlet') ? sourceItem : 
                                          (targetItem?.type === 'acoutlet') ? targetItem : null;
                            
                            if (outlet) {
                                const circuitWatts = getOutletTotalWatts(outlet);
                                if (circuitWatts > 0) {
                                    markConnectionLive(connObj.id, circuitWatts, breakerVoltage, 'from-breaker');
                                }
                            }
                        });
                    }
                });
                
                // Controller AC output power flow already calculated above (before breaker panels)
            }
        };
        
        // Resource types (matching simulator.html)
        const RESOURCE_TYPES = {
            POWER: 'Power',
            WATER: 'Water',
            HEAT: 'Heat',
            USER_DEFINED: 'User Defined',
            GENERIC: 'Generic', // Can connect to any input/output type
            // Legacy types
            PLASTIC: 'Plastic',
            PLASTIC_FLAKES: 'Plastic Flakes',
            WIND_TURBINES: 'Wind Turbines',
            BIOMASS: 'Biomass',
            WOODGAS: 'Woodgas',
            BIOCHAR: 'Biochar',
            CUSTOM_PRODUCT_A: 'Custom Product A',
            CUSTOM_PRODUCT_B: 'Custom Product B'
        };
        
        // Core resource types that require strict type matching
        const CORE_RESOURCE_TYPES = [RESOURCE_TYPES.POWER, RESOURCE_TYPES.WATER, RESOURCE_TYPES.HEAT];
        
        // Helper function to get default unit for resource type
        function getDefaultUnitForResource(resourceType) {
            const units = {
                [RESOURCE_TYPES.POWER]: 'kWh',
                [RESOURCE_TYPES.WATER]: 'L',
                [RESOURCE_TYPES.HEAT]: 'BTU',
                [RESOURCE_TYPES.BIOMASS]: 'kg',
                [RESOURCE_TYPES.WOODGAS]: 'm¬≥',
                [RESOURCE_TYPES.BIOCHAR]: 'kg',
                [RESOURCE_TYPES.PLASTIC]: 'kg',
                [RESOURCE_TYPES.PLASTIC_FLAKES]: 'kg',
                [RESOURCE_TYPES.WIND_TURBINES]: 'units',
                [RESOURCE_TYPES.GENERIC]: 'units'
            };
            return units[resourceType] || 'units';
        }
        
        // Helper function to get default capacity for resource type
        function getDefaultCapacityForResource(resourceType) {
            const capacities = {
                [RESOURCE_TYPES.POWER]: 10, // 10 kWh default
                [RESOURCE_TYPES.WATER]: 1000, // 1000 L default
                [RESOURCE_TYPES.HEAT]: 50000, // 50k BTU default
                [RESOURCE_TYPES.BIOMASS]: 500, // 500 kg default
                [RESOURCE_TYPES.WOODGAS]: 100, // 100 m¬≥ default
                [RESOURCE_TYPES.BIOCHAR]: 200, // 200 kg default
                [RESOURCE_TYPES.PLASTIC]: 100, // 100 kg default
                [RESOURCE_TYPES.PLASTIC_FLAKES]: 100, // 100 kg default
                [RESOURCE_TYPES.WIND_TURBINES]: 10, // 10 units default
                [RESOURCE_TYPES.GENERIC]: 1000 // 1000 units default
            };
            return capacities[resourceType] || 100;
        }
        
        let allItems = [];
        let connections = [];
        let selectedItem = null;
        let selectedConnection = null;
        let selectedArray = null; // Array of all panels in selected array
        let itemIdCounter = 0;
        let connectionIdCounter = 0;
        
        // === PERFORMANCE: Caching and indexing ===
        const _specsCache = { array: new Map(), battery: new Map(), version: 0 };
        let _connectionIndex = null; // { byItemId: Map<itemId, connection[]> }
        let _renderPending = false;
        
        // Invalidate caches when connections change
        function invalidateSpecsCache() {
            _specsCache.array.clear();
            _specsCache.battery.clear();
            _specsCache.version++;
            _connectionIndex = null;
        }
        
        // Build connection index for fast lookups
        function getConnectionIndex() {
            if (_connectionIndex) return _connectionIndex;
            _connectionIndex = { byItemId: new Map() };
            connections.forEach(c => {
                if (!_connectionIndex.byItemId.has(c.sourceItemId)) _connectionIndex.byItemId.set(c.sourceItemId, []);
                if (!_connectionIndex.byItemId.has(c.targetItemId)) _connectionIndex.byItemId.set(c.targetItemId, []);
                _connectionIndex.byItemId.get(c.sourceItemId).push(c);
                _connectionIndex.byItemId.get(c.targetItemId).push(c);
            });
            return _connectionIndex;
        }
        
        // Get connections for an item (optimized)
        function getConnectionsForItem(itemId) {
            return getConnectionIndex().byItemId.get(itemId) || [];
        }
        
        // Debounced render - batches multiple render() calls within same frame
        function scheduleRender() {
            if (_renderPending) return;
            _renderPending = true;
            requestAnimationFrame(() => {
                _renderPending = false;
                render();
            });
        }
        
        // Simulation state
        let isPlaying = false;
        let simulationSpeed = 1;
        let elapsedHours = 0;
        let lastProcessedHour = 0; // Track the last hour that was fully processed
        let previousDisplayHour = 0; // Track previous hour for visual updates
        let animationFrameId = null;
        let lastTimestamp = 0;
        
        // Latitude and seasonal simulation settings
        let simulationLatitude = 40; // Default latitude (NYC/Madrid area)
        let simulationStartDayOfYear = 172; // Default: June 21 (summer solstice for Northern Hemisphere)
        let currentDayOfYear = 172; // Tracks current day during simulation
        
        // Drag state
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        let dragOffset = { x: 0, y: 0 };
        let tempWire = null;
        let draggingHandle = null;
        
        // Tutorial state
        let tutorialStep = 0;
        let tutorialCompleted = false;
        
        const TUTORIAL_STEPS = [
            {
                id: 'connect-battery',
                title: 'üîã Connect the Battery',
                text: 'Drag from the controller\'s BATT+ handle (red, bottom) to the battery\'s + terminal (red, top). Then connect BATT- to the battery\'s - terminal.',
                successTitle: '‚ú® Nice work!',
                successText: 'Now connect the solar panel to the controller. Drag from the panel\'s + terminal to the controller\'s PV+ handle (orange, top).',
                check: (controller) => {
                    return controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                           controller.handles?.batteryNegative?.connectedTo?.length > 0;
                }
            },
            {
                id: 'connect-solar',
                title: '‚òÄÔ∏è Connect the Solar Panel',
                text: 'Drag from the panel\'s + terminal to the controller\'s PV+ handle (orange, top), and - to PV- (blue).',
                successTitle: 'üéâ System Operational!',
                successText: 'Excellent! Try adding more panels by dragging from a panel terminal to empty space.',
                check: (controller) => {
                    return controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                           controller.handles?.pvNegative?.connectedTo?.length > 0;
                }
            }
        ];
        
        // Track if user connected solar before battery (out of order)
        let connectedSolarFirst = false;
        
        // Track series hint state
        let seriesHintShown = false;
        let seriesVoltageInterval = null;
        
        // Track if optimal array hint was shown
        let optimalArrayHintShown = false;
        
        // Track last connected array wattage to detect new parallel strings
        let lastConnectedArrayWmp = 0;
        
        // ============================================
        // D3 SETUP
        // ============================================
        
        const svg = d3.select("#canvas");
        let svgWidth, svgHeight;
        
        const zoomBehavior = d3.zoom()
            .touchable(true) // Enable touch support for zoom/pan
            .scaleExtent([0.25, 4])
            .filter(event => {
                // Don't zoom on double-click
                if (event.type.includes('dblclick')) return false;
                // Don't pan when clicking on items or handles
                if (event.target.closest('.item-group') || event.target.closest('.handle')) return false;
                return true;
            })
            .on("zoom", (event) => {
                zoomGroup.attr("transform", event.transform);
            });
        
        svg.call(zoomBehavior);
        
        // Add SVG filters for wire glow effects
        const defs = svg.append("defs");
        
        // Yellow glow filter for 120V AC - creates a bright yellow glow
        const yellowGlow = defs.append("filter")
            .attr("id", "yellow-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        yellowGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        yellowGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1 0 0 0 0  0 1 0.5 0 0  0 0 1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const yellowMerge = yellowGlow.append("feMerge");
        yellowMerge.append("feMergeNode").attr("in", "coloredBlur");
        yellowMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Red glow filter for 240V AC - creates a darker red glow
        const redGlow = defs.append("filter")
            .attr("id", "red-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        redGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        redGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "1.2 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const redMerge = redGlow.append("feMerge");
        redMerge.append("feMergeNode").attr("in", "coloredBlur");
        redMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Blue glow filter for parallel connections - creates a bright blue glow
        const blueGlow = defs.append("filter")
            .attr("id", "blue-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        blueGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "6")
            .attr("result", "blur");
        blueGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "0 0 0 0 0  0.3 0.5 1 0 0  0.5 0.8 1 0 0  0 0 0 1.5 0")
            .attr("result", "coloredBlur");
        const blueMerge = blueGlow.append("feMerge");
        blueMerge.append("feMergeNode").attr("in", "coloredBlur");
        blueMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Green glow filter for resource connections - creates a bright green glow
        const greenGlow = defs.append("filter")
            .attr("id", "green-glow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        greenGlow.append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", "5")
            .attr("result", "blur");
        greenGlow.append("feColorMatrix")
            .attr("in", "blur")
            .attr("type", "matrix")
            .attr("values", "0.2 0 0 0 0  0 1 0 0 0  0.3 0.5 0.3 0 0  0 0 0 1.3 0")
            .attr("result", "coloredBlur");
        const greenMerge = greenGlow.append("feMerge");
        greenMerge.append("feMergeNode").attr("in", "coloredBlur");
        greenMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        const zoomGroup = svg.append("g").attr("class", "zoom-group");
        const wiresGroup = zoomGroup.append("g").attr("class", "wires-layer");
        const itemsGroup = zoomGroup.append("g").attr("class", "items-layer");
        const tempGroup = zoomGroup.append("g").attr("class", "temp-layer");
        const previewGroup = zoomGroup.append("g").attr("class", "preview-layer").style("opacity", 0.5);
        
        function updateSvgDimensions() {
            const container = document.getElementById('canvas-container');
            svgWidth = container.clientWidth;
            svgHeight = container.clientHeight;
        }
        
        // ============================================
        // COMPONENT CREATION
        // ============================================
        
        function createPanel(x, y, specs = PANEL_PRESETS[0]) {
            const id = `panel-${++itemIdCounter}`;
            // Ensure IMP is calculated if missing
            let imp = specs.imp;
            if (!imp && specs.wmp && specs.vmp) {
                imp = specs.wmp / specs.vmp;
            } else if (!imp && specs.isc) {
                // Fallback: IMP is typically about 90% of ISC
                imp = specs.isc * 0.9;
            } else if (!imp) {
                imp = 0;
            }
            
            // Calculate dynamic dimensions based on panel specs (in mm)
            // Scale: 1 meter (1000mm) = base height in pixels
            // Use panel height as the scale reference
            const panelHeightMm = specs.height || 992; // Default to typical 60-cell panel height
            const panelWidthMm = specs.width || 1650; // Default to typical 60-cell panel width
            
            // Base scale: 1 meter (1000mm) = 120px (makes panels reasonably sized)
            const baseScale = 120; // pixels per meter
            const pixelsPerMm = baseScale / 1000; // 0.12 pixels per mm
            
            // Calculate panel dimensions in pixels, maintaining aspect ratio
            const panelHeightPx = Math.max(80, Math.min(200, panelHeightMm * pixelsPerMm)); // Clamp between 80-200px
            const panelWidthPx = (panelWidthMm / panelHeightMm) * panelHeightPx; // Maintain aspect ratio
            
            return {
                id,
                type: 'panel',
                x, y,
                width: panelWidthPx,
                height: panelHeightPx,
                specs: { 
                    ...specs, 
                    imp: parseFloat(imp.toFixed(2)),
                    // Store scale factor for wire distance calculations
                    scaleFactor: panelHeightPx / (panelHeightMm / 1000) // pixels per meter for this panel
                },
                handles: {
                    // Positive on left side, negative on right side (standard convention)
                    positive: { id: `${id}-pos`, polarity: 'positive', x: 0, y: panelHeightPx / 2, side: 'left', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: panelWidthPx, y: panelHeightPx / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        function createBattery(x, y, specs = BATTERY_PRESETS[0]) {
            const id = `battery-${++itemIdCounter}`;
            const kWh = (specs.voltage * specs.ah) / 1000;
            
            // Dynamic sizing based on real-world dimensions (mm)
            const batteryHeightMm = specs.height || 300; // Default to 300mm
            const batteryWidthMm = specs.width || 200;  // Default to 200mm
            
            // Base scale: 1 meter (1000mm) = 120 pixels (same as panels and controllers)
            const baseScale = 120; // pixels per meter
            const pixelsPerMm = baseScale / 1000;
            
            // Calculate pixel dimensions, clamp height to a reasonable range
            let batteryHeightPx = batteryHeightMm * pixelsPerMm;
            batteryHeightPx = Math.max(60, Math.min(150, batteryHeightPx)); // Clamp between 60px and 150px
            
            // Maintain aspect ratio for width
            const aspectRatio = batteryWidthMm / batteryHeightMm;
            let batteryWidthPx = batteryHeightPx * aspectRatio;
            batteryWidthPx = Math.max(80, Math.min(200, batteryWidthPx)); // Clamp width too
            
            // Store the actual scale factor for this battery
            const scaleFactor = batteryHeightPx / (batteryHeightMm / 1000); // Pixels per meter
            
            return {
                id,
                type: 'battery',
                x, y,
                width: batteryWidthPx,
                height: batteryHeightPx,
                specs: { 
                    ...specs, 
                    kWh,
                    scaleFactor: scaleFactor
                },
                handles: {
                    // Terminals on top (like real batteries)
                    positive: { id: `${id}-pos`, polarity: 'positive', x: batteryWidthPx * 0.25, y: -5, side: 'top', connectedTo: [] },
                    negative: { id: `${id}-neg`, polarity: 'negative', x: batteryWidthPx * 0.75, y: -5, side: 'top', connectedTo: [] }
                }
            };
        }
        
        const SMART_BATTERY_WIDTH = 100;
        const SMART_BATTERY_HEIGHT = 80;
        
        function createSmartBattery(x, y, kWh = 3.6, parentControllerId = null) {
            const id = `smartbattery-${++itemIdCounter}`;
            return {
                id,
                type: 'smartbattery',
                x, y,
                width: SMART_BATTERY_WIDTH,
                height: SMART_BATTERY_HEIGHT,
                parentControllerId,
                specs: { 
                    name: 'Smart Battery',
                    kWh,
                    voltage: 48,
                    cost: 2700
                },
                handles: {
                    // Smart battery ports on both sides for daisy-chaining
                    smartPort1: { id: `${id}-smart-1`, polarity: 'smart-battery', x: SMART_BATTERY_WIDTH + 5, y: SMART_BATTERY_HEIGHT * 0.5, side: 'right', connectedTo: [] },
                    smartPort2: { id: `${id}-smart-2`, polarity: 'smart-battery', x: -5, y: SMART_BATTERY_HEIGHT * 0.5, side: 'left', connectedTo: [] }
                }
            };
        }
        
        const ALL_IN_ONE_HEIGHT = 140; // Taller for all-in-one with internal battery
        
        function createController(x, y, specs = CONTROLLER_PRESETS[0]) {
            const id = `controller-${++itemIdCounter}`;
            const isHybrid = specs.type === 'hybrid_inverter' || specs.type === 'all_in_one';
            const isAllInOne = specs.type === 'all_in_one';
            
            // Dynamic sizing based on real-world dimensions (mm)
            const controllerHeightMm = specs.height || 600; // Default to 600mm
            const controllerWidthMm = specs.width || 400;  // Default to 400mm
            
            // Base scale: 1 meter (1000mm) = 120 pixels (same as panels)
            const baseScale = 120; // pixels per meter
            const pixelsPerMm = baseScale / 1000;
            
            // Calculate pixel dimensions, clamp height to a reasonable range
            let controllerHeightPx = controllerHeightMm * pixelsPerMm;
            controllerHeightPx = Math.max(80, Math.min(200, controllerHeightPx)); // Clamp between 80px and 200px
            
            // Maintain aspect ratio for width
            const aspectRatio = controllerWidthMm / controllerHeightMm;
            let controllerWidthPx = controllerHeightPx * aspectRatio;
            controllerWidthPx = Math.max(100, Math.min(300, controllerWidthPx)); // Clamp width too
            
            // Store the actual scale factor for this controller
            const scaleFactor = controllerHeightPx / (controllerHeightMm / 1000); // Pixels per meter
            
            const nodeHeight = controllerHeightPx;
            
            // Get MPPT count (default to 1 if not specified)
            const mpptCount = specs.mpptCount || 1;
            
            const handles = {};
            
            // Create PV input ports based on MPPT count
            // Center align ports: for single MPPT, center them; for multiple, distribute evenly
            if (mpptCount === 1) {
                // Single MPPT: center the ports
                handles.pvPositive = { id: `${id}-pv-pos`, polarity: 'pv-positive', x: controllerWidthPx * 0.375, y: -5, side: 'top', connectedTo: [], mpptIndex: 0 };
                handles.pvNegative = { id: `${id}-pv-neg`, polarity: 'pv-negative', x: controllerWidthPx * 0.625, y: -5, side: 'top', connectedTo: [], mpptIndex: 0 };
            } else {
                // Multiple MPPTs: distribute ports with more spacing to prevent overlap
                // Use wider spacing: leave more margin on sides and between pairs
                const margin = 25; // Margin on each side
                const availableWidth = controllerWidthPx - (2 * margin);
                const pairWidth = 35; // Width of each port pair (distance between + and -)
                
                // Calculate spacing: distribute pairs evenly across available width
                // For 2 MPPTs: centers at margin + (availableWidth - pairWidth)/2 and margin + availableWidth - (availableWidth - pairWidth)/2
                // For more: evenly space between first and last
                for (let i = 0; i < mpptCount; i++) {
                    let xPos;
                    if (mpptCount === 1) {
                        xPos = controllerWidthPx / 2;
                    } else {
                        // Distribute evenly: first at margin + pairWidth/2, last at controllerWidthPx - margin - pairWidth/2
                        const firstCenter = margin + pairWidth / 2;
                        const lastCenter = controllerWidthPx - margin - pairWidth / 2;
                        xPos = firstCenter + ((lastCenter - firstCenter) / (mpptCount - 1)) * i;
                    }
                    
                    handles[`pvPositive${i + 1}`] = { 
                        id: `${id}-pv-pos-${i + 1}`, 
                        polarity: 'pv-positive', 
                        x: xPos - pairWidth / 2, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [], 
                        mpptIndex: i 
                    };
                    handles[`pvNegative${i + 1}`] = { 
                        id: `${id}-pv-neg-${i + 1}`, 
                        polarity: 'pv-negative', 
                        x: xPos + pairWidth / 2, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [], 
                        mpptIndex: i 
                    };
                }
                // Also create legacy handles for backward compatibility (point to first MPPT)
                handles.pvPositive = handles.pvPositive1;
                handles.pvNegative = handles.pvNegative1;
            }
            
            // All-in-one units have internal battery, so no external battery handles
            // Regular controllers and hybrid inverters need external battery connections
            // Center align battery ports
            if (!isAllInOne) {
                handles.batteryPositive = { id: `${id}-batt-pos`, polarity: 'positive', x: controllerWidthPx * 0.375, y: nodeHeight + 5, side: 'bottom', connectedTo: [] };
                handles.batteryNegative = { id: `${id}-batt-neg`, polarity: 'negative', x: controllerWidthPx * 0.625, y: nodeHeight + 5, side: 'bottom', connectedTo: [] };
            }
            
            // Add AC output for hybrid inverters and all-in-ones
            if (isHybrid) {
                handles.acOutput = { id: `${id}-ac-out`, polarity: 'ac', x: controllerWidthPx + 5, y: nodeHeight * 0.5, side: 'right', connectedTo: [] };
            }
            
            // Add smart battery ports for all-in-one units with expansion capability
            if (isAllInOne && specs.smartBatteryPorts) {
                for (let i = 0; i < specs.smartBatteryPorts; i++) {
                    const portY = nodeHeight * 0.35 + (i * 35);
                    handles[`smartBattery${i + 1}`] = { 
                        id: `${id}-smart-batt-${i + 1}`, 
                        polarity: 'smart-battery', 
                        x: -5, 
                        y: portY, 
                        side: 'left', 
                        connectedTo: [],
                        portIndex: i + 1
                    };
                }
            }
            
            // Add parallel port for units that support hub connection (e.g., Delta Pro)
            if (specs.parallelCapable) {
                handles.parallelPort = { 
                    id: `${id}-parallel`, 
                    polarity: 'parallel', 
                    x: controllerWidthPx + 5, 
                    y: nodeHeight * 0.25, 
                    side: 'right', 
                    connectedTo: [] 
                };
            }
            
            return {
                id,
                type: 'controller',
                subtype: specs.type,
                x, y,
                width: controllerWidthPx,
                height: nodeHeight,
                specs: { 
                    ...specs,
                    topColor: specs.topColor || '#c0c0c0',
                    bottomColor: specs.bottomColor || '#2a2a2a',
                    dividerHeight: specs.dividerHeight !== undefined ? specs.dividerHeight : 50,
                    imageUrl: specs.imageUrl || null,
                    scaleFactor: scaleFactor
                },
                handles
            };
        }
        
        function createBreaker(x, y, specs = BREAKER_PRESETS[1]) {
            const id = `breaker-${++itemIdCounter}`;
            return {
                id,
                type: 'breaker',
                x, y,
                width: BREAKER_WIDTH,
                height: BREAKER_HEIGHT,
                isClosed: true, // Breaker state: true = closed (conducting), false = open (tripped/off)
                specs: { ...specs },
                handles: {
                    // Line side (input) on top
                    linePositive: { id: `${id}-line-pos`, polarity: 'positive', x: BREAKER_WIDTH * 0.3, y: -5, side: 'top', connectedTo: [] },
                    lineNegative: { id: `${id}-line-neg`, polarity: 'negative', x: BREAKER_WIDTH * 0.7, y: -5, side: 'top', connectedTo: [] },
                    // Load side (output) on bottom
                    loadPositive: { id: `${id}-load-pos`, polarity: 'positive', x: BREAKER_WIDTH * 0.3, y: BREAKER_HEIGHT + 5, side: 'bottom', connectedTo: [] },
                    loadNegative: { id: `${id}-load-neg`, polarity: 'negative', x: BREAKER_WIDTH * 0.7, y: BREAKER_HEIGHT + 5, side: 'bottom', connectedTo: [] }
                }
            };
        }
        
        function createCombiner(x, y, specs = COMBINER_PRESETS[1]) {
            const id = `combiner-${++itemIdCounter}`;
            const numInputs = specs.inputs || 4;
            const handles = {};
            
            // Create input handles on top (one pair per string)
            for (let i = 0; i < numInputs; i++) {
                const xRatio = (i + 0.5) / numInputs;
                handles[`input${i}Positive`] = { 
                    id: `${id}-in${i}-pos`, 
                    polarity: 'positive', 
                    x: COMBINER_WIDTH * xRatio - 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
                handles[`input${i}Negative`] = { 
                    id: `${id}-in${i}-neg`, 
                    polarity: 'negative', 
                    x: COMBINER_WIDTH * xRatio + 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
            }
            
            // Combined output on bottom - positive left, negative right
            handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: COMBINER_WIDTH * 0.30, y: COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: COMBINER_WIDTH * 0.70, y: COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            
            return {
                id,
                type: 'combiner',
                x, y,
                width: COMBINER_WIDTH,
                height: COMBINER_HEIGHT,
                specs: { ...specs },
                handles
            };
        }
        
        function createSolarCombinerBox(x, y, specs = SOLAR_COMBINER_PRESETS[1]) {
            const id = `solarcombiner-${++itemIdCounter}`;
            const numInputs = specs.inputs || 4;
            const handles = {};
            
            // Create input handles on top (one pair per string, each with its own breaker)
            for (let i = 0; i < numInputs; i++) {
                const xRatio = (i + 0.5) / numInputs;
                handles[`input${i}Positive`] = { 
                    id: `${id}-in${i}-pos`, 
                    polarity: 'pv-positive', 
                    x: SOLAR_COMBINER_WIDTH * xRatio - 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i,
                    breakerClosed: true // Each input has its own breaker
                };
                handles[`input${i}Negative`] = { 
                    id: `${id}-in${i}-neg`, 
                    polarity: 'pv-negative', 
                    x: SOLAR_COMBINER_WIDTH * xRatio + 8, 
                    y: -5, 
                    side: 'top', 
                    connectedTo: [],
                    inputIndex: i
                };
            }
            
            // Combined output on bottom - positive left, negative right
            handles.outputPositive = { id: `${id}-out-pos`, polarity: 'pv-positive', x: SOLAR_COMBINER_WIDTH * 0.30, y: SOLAR_COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            handles.outputNegative = { id: `${id}-out-neg`, polarity: 'pv-negative', x: SOLAR_COMBINER_WIDTH * 0.70, y: SOLAR_COMBINER_HEIGHT + 5, side: 'bottom', connectedTo: [] };
            
            return {
                id,
                type: 'solarcombiner',
                x, y,
                width: SOLAR_COMBINER_WIDTH,
                height: SOLAR_COMBINER_HEIGHT,
                specs: { ...specs },
                breakerStates: new Array(numInputs).fill(true), // All breakers closed by default
                handles
            };
        }
        
        // EcoFlow Double Voltage Hub - connects two Delta Pro units for 240V split-phase output
        const DOUBLE_VOLTAGE_HUB_WIDTH = 100;
        const DOUBLE_VOLTAGE_HUB_HEIGHT = 60;
        
        function createDoubleVoltageHub(x, y) {
            const id = `hub-${++itemIdCounter}`;
            return {
                id,
                type: 'doublevoltagehub',
                x, y,
                width: DOUBLE_VOLTAGE_HUB_WIDTH,
                height: DOUBLE_VOLTAGE_HUB_HEIGHT,
                specs: {
                    name: 'Double Voltage Hub',
                    maxInputControllers: 2,
                    outputVoltage: '120V/240V',
                    maxOutputW: 7200,
                    cost: 400
                },
                handles: {
                    // Two parallel inputs on left side
                    input1: { id: `${id}-in1`, polarity: 'parallel', x: -5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.33, side: 'left', connectedTo: [] },
                    input2: { id: `${id}-in2`, polarity: 'parallel', x: -5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.67, side: 'left', connectedTo: [] },
                    // Combined AC output on right
                    acOutput: { id: `${id}-ac-out`, polarity: 'ac', x: DOUBLE_VOLTAGE_HUB_WIDTH + 5, y: DOUBLE_VOLTAGE_HUB_HEIGHT * 0.5, side: 'right', connectedTo: [] }
                }
            };
        }
        
        // AC Circuit Components
        const AC_BREAKER_WIDTH = 50;
        const AC_BREAKER_HEIGHT = 40;
        const AC_OUTLET_WIDTH = 50;
        const AC_OUTLET_HEIGHT = 50;
        
        const AC_BREAKER_PRESETS = [
            { name: "AC 15A", rating: 15, voltage: 120, maxWatts: 1800, cost: 10 },
            { name: "AC 20A", rating: 20, voltage: 120, maxWatts: 2400, cost: 12 },
            { name: "AC 30A", rating: 30, voltage: 120, maxWatts: 3600, cost: 18 },
            { name: "AC 30A 240V", rating: 30, voltage: 240, maxWatts: 7200, cost: 25 },
            { name: "AC 50A 240V", rating: 50, voltage: 240, maxWatts: 12000, cost: 35 }
        ];
        
        function createACBreaker(x, y, specs = AC_BREAKER_PRESETS[0]) {
            const id = `acbreaker-${++itemIdCounter}`;
            return {
                id,
                type: 'acbreaker',
                x, y,
                width: AC_BREAKER_WIDTH,
                height: AC_BREAKER_HEIGHT,
                isClosed: true,
                specs: { ...specs },
                handles: {
                    // Line (input) on left
                    lineIn: { id: `${id}-line`, polarity: 'ac', x: -5, y: AC_BREAKER_HEIGHT / 2, side: 'left', connectedTo: [] },
                    // Load (output) on right
                    loadOut: { id: `${id}-load`, polarity: 'ac', x: AC_BREAKER_WIDTH + 5, y: AC_BREAKER_HEIGHT / 2, side: 'right', connectedTo: [] }
                }
            };
        }
        
        function createACOutlet(x, y, voltage = 120) {
            const id = `outlet-${++itemIdCounter}`;
            const is240V = voltage === 240;
            return {
                id,
                type: 'acoutlet',
                x, y,
                width: AC_OUTLET_WIDTH,
                height: AC_OUTLET_HEIGHT,
                specs: {
                    name: is240V ? '240V Outlet' : '120V Outlet',
                    voltage: voltage,
                    maxAmps: is240V ? 30 : 15,
                    cost: is240V ? 25 : 5
                },
                handles: {
                    // Input on left (for daisy-chaining)
                    input: { id: `${id}-in`, polarity: 'ac', x: -5, y: AC_OUTLET_HEIGHT / 2, side: 'left', connectedTo: [], voltage: voltage },
                    // Output on right (for daisy-chaining to next outlet)
                    output: { id: `${id}-out`, polarity: 'ac', x: AC_OUTLET_WIDTH + 5, y: AC_OUTLET_HEIGHT / 2, side: 'right', connectedTo: [], voltage: voltage },
                    // Load port on bottom (for connecting appliances)
                    load: { id: `${id}-load`, polarity: 'load', x: AC_OUTLET_WIDTH / 2, y: AC_OUTLET_HEIGHT + 5, side: 'bottom', connectedTo: [], voltage: voltage }
                }
            };
        }
        
        // AC Load / Appliance component
        const AC_LOAD_WIDTH = 90;
        const AC_LOAD_HEIGHT = 95; // Increased from 75 to prevent button overlap with name label
        const RECIPE_LOAD_WIDTH = 140; // Larger width for recipe-based appliances
        const RECIPE_LOAD_HEIGHT = 140; // Larger height for recipe-based appliances with multiple ports
        
        const APPLIANCE_PRESETS = [
            // Simple appliances (on/off, use automations for scheduling)
            { name: "Custom Load", voltage: 120, maxWatts: 100, avgWatts: 50, icon: "‚ö°", behavior: { type: "simple" } },
            { name: "LED Light", voltage: 120, maxWatts: 15, avgWatts: 10, icon: "üí°", behavior: { type: "simple" } },
            { name: "CFL Light", voltage: 120, maxWatts: 23, avgWatts: 20, icon: "üí°", behavior: { type: "simple" } },
            { name: "Laptop", voltage: 120, maxWatts: 65, avgWatts: 45, icon: "üíª", behavior: { type: "simple" } },
            { name: "Desktop PC", voltage: 120, maxWatts: 500, avgWatts: 200, icon: "üñ•Ô∏è", behavior: { type: "simple" } },
            { name: "TV (LED 55\")", voltage: 120, maxWatts: 120, avgWatts: 80, icon: "üì∫", behavior: { type: "simple" } },
            { name: "Refrigerator", voltage: 120, maxWatts: 400, avgWatts: 150, icon: "üßä", behavior: { type: "simple" } },
            { name: "Space Heater", voltage: 120, maxWatts: 1500, avgWatts: 1500, icon: "üî•", behavior: { type: "simple" } },
            { name: "Window AC", voltage: 120, maxWatts: 1400, avgWatts: 1000, icon: "‚ùÑÔ∏è", behavior: { type: "simple" } },
            { name: "EV Charger (L2)", voltage: 240, maxWatts: 7200, avgWatts: 6000, icon: "üöó", behavior: { type: "simple" } },
            { name: "Well Pump", voltage: 240, maxWatts: 2000, avgWatts: 1000, icon: "üíß", behavior: { type: "simple" } },
            { name: "Hot Tub", voltage: 240, maxWatts: 6000, avgWatts: 4000, icon: "üõÅ", behavior: { type: "simple" } },
            { name: "Central AC", voltage: 240, maxWatts: 5000, avgWatts: 3500, icon: "üè†", behavior: { type: "simple" } },
            { name: "Phone Charger", voltage: 120, maxWatts: 20, avgWatts: 15, icon: "üì±", behavior: { type: "simple" } },
            { name: "Tablet Charger", voltage: 120, maxWatts: 30, avgWatts: 20, icon: "üì≤", behavior: { type: "simple" } },
            { name: "EUC/Ebike Charger", voltage: 120, maxWatts: 300, avgWatts: 250, icon: "üõ¥", behavior: { type: "simple" } },
            { name: "Onewheel Charger", voltage: 120, maxWatts: 300, avgWatts: 250, icon: "üõπ", behavior: { type: "simple" } },
            
            // Recipe-based appliances (process inputs into outputs)
            { 
                name: "Biochar Reactor", voltage: 120, maxWatts: 1500, avgWatts: 1200, icon: "üî•",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Process Biomass", 
                        inputs: [{ resourceType: RESOURCE_TYPES.BIOMASS, amount: 5, unit: "kg" }],
                        outputs: [
                            { resourceType: RESOURCE_TYPES.WOODGAS, amount: 0.25, unit: "m¬≥" },
                            { resourceType: RESOURCE_TYPES.BIOCHAR, amount: 1, unit: "kg" }
                        ],
                        durationHours: 6, energyWh: 6000
                    }
                ]
            },
            { 
                name: "Plastic Shredder", voltage: 120, maxWatts: 600, avgWatts: 600, icon: "üî©",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Shred Plastic", 
                        inputs: [{ resourceType: RESOURCE_TYPES.PLASTIC, amount: 1, unit: "kg" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.PLASTIC_FLAKES, amount: 1, unit: "kg" }],
                        durationHours: 0.167, energyWh: 100
                    }
                ]
            },
            { 
                name: "Trash Printer", voltage: 120, maxWatts: 250, avgWatts: 150, icon: "üñ®Ô∏è",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Print Object", 
                        inputs: [{ resourceType: RESOURCE_TYPES.PLASTIC_FLAKES, amount: 0.2, unit: "kg" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.WIND_TURBINES, amount: 0.2, unit: "units" }],
                        durationHours: 4, energyWh: 1000
                    }
                ]
            },
            { 
                name: "Water Purifier", voltage: 120, maxWatts: 50, avgWatts: 30, icon: "üíß",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Purify Water", 
                        inputs: [{ resourceType: RESOURCE_TYPES.WATER, amount: 10, unit: "L" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.WATER, amount: 9, unit: "L" }],
                        durationHours: 0.5, energyWh: 25
                    }
                ]
            },
            { 
                name: "Electric Oven", voltage: 240, maxWatts: 5000, avgWatts: 2500, icon: "üç≥",
                behavior: { type: "recipe" },
                recipes: [
                    { 
                        name: "Bake 1hr", 
                        inputs: [{ resourceType: RESOURCE_TYPES.HEAT, amount: 0, unit: "BTU" }],
                        outputs: [{ resourceType: RESOURCE_TYPES.HEAT, amount: 5000, unit: "BTU" }],
                        durationHours: 1, energyWh: 2000
                    }
                ]
            }
        ];
        
        function createACLoad(x, y, preset = APPLIANCE_PRESETS[0]) {
            const id = `load-${++itemIdCounter}`;
            // Deep copy behavior to avoid shared references
            const behavior = preset.behavior ? JSON.parse(JSON.stringify(preset.behavior)) : { type: 'simple' };
            // Deep copy recipes if they exist
            const recipes = preset.recipes ? JSON.parse(JSON.stringify(preset.recipes)) : undefined;
            
            // Use larger dimensions for recipe-based loads
            const isRecipeBased = recipes && recipes.length > 0;
            const loadWidth = isRecipeBased ? RECIPE_LOAD_WIDTH : AC_LOAD_WIDTH;
            const loadHeight = isRecipeBased ? RECIPE_LOAD_HEIGHT : AC_LOAD_HEIGHT;
            
            const load = {
                id,
                type: 'acload',
                x, y,
                width: loadWidth,
                height: loadHeight,
                specs: { 
                    name: preset.name,
                    voltage: preset.voltage,
                    maxWatts: preset.maxWatts,
                    avgWatts: preset.avgWatts,
                    icon: preset.icon,
                    behavior: behavior,
                    recipes: recipes,
                    cost: 0 
                },
                handles: {
                    // Cord input - on left side for recipe loads, top for simple loads
                    cord: isRecipeBased 
                        ? { id: `${id}-cord`, polarity: 'load', x: -5, y: loadHeight / 2, side: 'left', connectedTo: [] }
                        : { id: `${id}-cord`, polarity: 'load', x: loadWidth / 2, y: -5, side: 'top', connectedTo: [] }
                },
                // Recipe processing state
                activeRecipeIndex: null,
                recipeTimeElapsed: 0,
                isProcessing: false,
                awaitingInputs: false,
                portOrientation: 'vertical',
                flipped: false,
                // Automation rules
                automations: []
            };
            
            // Generate resource ports from recipes if they exist
            if (isRecipeBased) {
                regeneratePortsForLoad(load);
            }
            
            return load;
        }
        
        // Create a resource container (water tank, biomass container, etc.)
        function createResourceContainer(x, y, resourceType = RESOURCE_TYPES.WATER, capacity = null) {
            const id = `resource-${++itemIdCounter}`;
            const defaultCapacity = capacity || getDefaultCapacityForResource(resourceType);
            const unit = getDefaultUnitForResource(resourceType);
            
            return {
                id,
                type: 'resourcecontainer',
                x, y,
                width: 150,
                height: 200,
                specs: {
                    name: `${resourceType} Container`,
                    resourceType: resourceType,
                    capacity: defaultCapacity,
                    value: 0, // Current amount stored
                    unit: unit,
                    cost: 0
                },
                handles: {
                    input: { 
                        id: `${id}-input`, 
                        polarity: 'input', 
                        resourceType: resourceType,
                        x: 75, 
                        y: -5, 
                        side: 'top', 
                        connectedTo: [] 
                    },
                    output: { 
                        id: `${id}-output`, 
                        polarity: 'output', 
                        resourceType: resourceType,
                        x: 75, 
                        y: 205, 
                        side: 'bottom', 
                        connectedTo: [] 
                    }
                }
            };
        }
        
        // Processor node presets
        // Regenerate ports for a load based on its recipes
        function regeneratePortsForLoad(load) {
            if (!load || load.type !== 'acload') return;
            
            const recipes = load.specs.recipes || [];
            if (recipes.length === 0) return;
            
            // Collect all unique resource types from all recipes
            const inputResources = new Map(); // resourceType -> { name, amount, unit }
            const outputResources = new Map();
            
            recipes.forEach(recipe => {
                (recipe.inputs || []).forEach(input => {
                    if (input.resourceType && input.resourceType !== RESOURCE_TYPES.POWER) {
                        if (!inputResources.has(input.resourceType)) {
                            inputResources.set(input.resourceType, {
                                name: input.name || input.resourceType,
                                amount: input.amount || 0,
                                unit: input.unit || 'units'
                            });
                        }
                    }
                });
                (recipe.outputs || []).forEach(output => {
                    if (output.resourceType) {
                        if (!outputResources.has(output.resourceType)) {
                            outputResources.set(output.resourceType, {
                                name: output.name || output.resourceType,
                                amount: output.amount || 0,
                                unit: output.unit || 'units'
                            });
                        }
                    }
                });
            });
            
            // Update load size for recipe-based loads
            const isRecipeBased = inputResources.size > 0 || outputResources.size > 0;
            if (isRecipeBased && load.width < RECIPE_LOAD_WIDTH) {
                load.width = RECIPE_LOAD_WIDTH;
                load.height = RECIPE_LOAD_HEIGHT;
            }
            
            // Remove old resource port handles (keep cord handle)
            const cordHandle = load.handles.cord;
            // Update cord position for recipe loads (on left side)
            if (isRecipeBased) {
                cordHandle.x = -5;
                cordHandle.y = load.height / 2;
                cordHandle.side = 'left';
            }
            load.handles = { cord: cordHandle };
            
            const orientation = load.portOrientation || 'vertical';
            const isFlipped = load.flipped || false;
            
            if (orientation === 'vertical') {
                // Top/bottom orientation: inputs on top, outputs on bottom
                const inputArray = Array.from(inputResources.entries());
                let inputPortXRatioStep = inputArray.length > 0 ? 1 / (inputArray.length + 1) : 0.5;
                inputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-in-${idx}`;
                    const xRatio = inputPortXRatioStep * (idx + 1);
                    load.handles[`input-${idx}`] = {
                        id: portId,
                        polarity: 'input',
                        resourceType: resourceType,
                        name: info.name,
                        x: load.width * xRatio,
                        y: isFlipped ? load.height + 5 : -5,
                        side: isFlipped ? 'bottom' : 'top',
                        connectedTo: []
                    };
                });
                
                const outputArray = Array.from(outputResources.entries());
                let outputPortXRatioStep = outputArray.length > 0 ? 1 / (outputArray.length + 1) : 0.5;
                outputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-out-${idx}`;
                    const xRatio = outputPortXRatioStep * (idx + 1);
                    load.handles[`output-${idx}`] = {
                        id: portId,
                        polarity: 'output',
                        resourceType: resourceType,
                        name: info.name,
                        x: load.width * xRatio,
                        y: isFlipped ? -5 : load.height + 5,
                        side: isFlipped ? 'top' : 'bottom',
                        connectedTo: []
                    };
                });
            } else {
                // Left/right orientation: inputs on left, outputs on right
                const inputArray = Array.from(inputResources.entries());
                let inputPortYRatioStep = inputArray.length > 0 ? 1 / (inputArray.length + 1) : 0.5;
                inputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-in-${idx}`;
                    const yRatio = inputPortYRatioStep * (idx + 1);
                    load.handles[`input-${idx}`] = {
                        id: portId,
                        polarity: 'input',
                        resourceType: resourceType,
                        name: info.name,
                        x: isFlipped ? load.width + 5 : -5,
                        y: load.height * yRatio,
                        side: isFlipped ? 'right' : 'left',
                        connectedTo: []
                    };
                });
                
                const outputArray = Array.from(outputResources.entries());
                let outputPortYRatioStep = outputArray.length > 0 ? 1 / (outputArray.length + 1) : 0.5;
                outputArray.forEach(([resourceType, info], idx) => {
                    const portId = `p-${load.id}-out-${idx}`;
                    const yRatio = outputPortYRatioStep * (idx + 1);
                    load.handles[`output-${idx}`] = {
                        id: portId,
                        polarity: 'output',
                        resourceType: resourceType,
                        name: info.name,
                        x: isFlipped ? -5 : load.width + 5,
                        y: load.height * yRatio,
                        side: isFlipped ? 'left' : 'right',
                        connectedTo: []
                    };
                });
            }
        }
        
        
        // Auto-size breaker based on source watts
        function getAutoSizedACBreaker(sourceWatts, voltage = 120) {
            // Find smallest breaker that can handle the load with 80% safety margin
            const requiredAmps = (sourceWatts / voltage) * 1.25;
            const preset = AC_BREAKER_PRESETS.find(b => b.voltage === voltage && b.rating >= requiredAmps) 
                || AC_BREAKER_PRESETS.find(b => b.voltage === voltage);
            return preset || AC_BREAKER_PRESETS[0];
        }
        
        // CEP Spider Box - Portable power distribution for job sites
        // Takes 240V 50A input, breaks out to multiple 120V/240V circuits
        const SPIDERBOX_WIDTH = 220;
        const SPIDERBOX_HEIGHT = 180; // Increased to fit all 6 circuits
        
        function createSpiderBox(x, y) {
            const id = `spiderbox-${++itemIdCounter}`;
            const handles = {
                // 240V 50A input on left
                input: { id: `${id}-in`, polarity: 'ac', x: -5, y: SPIDERBOX_HEIGHT / 2, side: 'left', connectedTo: [], voltage: 240 }
            };
            
            // 6 output circuits on right side
            // 4x 120V 20A circuits (from split-phase)
            // 2x 240V 30A circuits
            const circuits = [
                { name: '120V-1', voltage: 120, amps: 20 },
                { name: '120V-2', voltage: 120, amps: 20 },
                { name: '120V-3', voltage: 120, amps: 20 },
                { name: '120V-4', voltage: 120, amps: 20 },
                { name: '240V-1', voltage: 240, amps: 30 },
                { name: '240V-2', voltage: 240, amps: 30 }
            ];
            
            circuits.forEach((circuit, i) => {
                const yPos = 50 + (i * 18); // Aligned with visual circuit positions
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: SPIDERBOX_WIDTH + 5,
                    y: yPos,
                    side: 'right',
                    connectedTo: [],
                    voltage: circuit.voltage,
                    maxAmps: circuit.amps,
                    circuitName: circuit.name,
                    isClosed: true
                };
            });
            
            return {
                id,
                type: 'spiderbox',
                x, y,
                width: SPIDERBOX_WIDTH,
                height: SPIDERBOX_HEIGHT,
                specs: {
                    name: 'CEP Spider Box',
                    inputVoltage: 240,
                    inputAmps: 50,
                    maxInputWatts: 12000,
                    circuits: circuits,
                    cost: 450
                },
                handles,
                mainBreakerOn: true // Main breaker state (50A 240V)
            };
        }
        
        // Household Main Breaker Panel - 100A service
        // Takes 240V input, provides multiple circuits
        const BREAKER_PANEL_WIDTH = 200;
        const BREAKER_PANEL_HEIGHT = 240;
        
        function createBreakerPanel(x, y) {
            const id = `panel-${++itemIdCounter}`;
            const handles = {
                // Main 240V input on top
                mainInput: { id: `${id}-main-in`, polarity: 'ac', x: BREAKER_PANEL_WIDTH / 2, y: -5, side: 'top', connectedTo: [], voltage: 240 }
            };
            
            // 8 circuit outputs - mix of 120V and 240V
            const circuits = [
                { name: 'Circuit 1', voltage: 120, amps: 15 },
                { name: 'Circuit 2', voltage: 120, amps: 15 },
                { name: 'Circuit 3', voltage: 120, amps: 20 },
                { name: 'Circuit 4', voltage: 120, amps: 20 },
                { name: 'Circuit 5', voltage: 120, amps: 20 },
                { name: 'Circuit 6', voltage: 120, amps: 20 },
                { name: '240V-A', voltage: 240, amps: 30 },
                { name: '240V-B', voltage: 240, amps: 50 }
            ];
            
            // Left side circuits (1-4) - match visual breaker positions
            for (let i = 0; i < 4; i++) {
                const yPos = 75 + (i * 42); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: -5,
                    y: yPos,
                    side: 'left',
                    connectedTo: [],
                    voltage: circuits[i].voltage,
                    maxAmps: circuits[i].amps,
                    circuitName: circuits[i].name
                };
            }
            
            // Right side circuits (5-8) - match visual breaker positions
            for (let i = 4; i < 8; i++) {
                const yPos = 75 + ((i - 4) * 42); // Increased spacing for larger size
                handles[`circuit${i + 1}`] = {
                    id: `${id}-circuit-${i + 1}`,
                    polarity: 'ac',
                    x: BREAKER_PANEL_WIDTH + 5,
                    y: yPos,
                    side: 'right',
                    connectedTo: [],
                    voltage: circuits[i].voltage,
                    maxAmps: circuits[i].amps,
                    circuitName: circuits[i].name
                };
            }
            
            return {
                id,
                type: 'breakerpanel',
                x, y,
                width: BREAKER_PANEL_WIDTH,
                height: BREAKER_PANEL_HEIGHT,
                specs: {
                    name: '100A Breaker Panel',
                    inputVoltage: 240,
                    inputAmps: 100,
                    maxInputWatts: 24000,
                    circuits: circuits,
                    cost: 250
                },
                handles,
                mainBreakerOn: true, // Main breaker state
                breakerStates: new Array(8).fill(true) // Individual breakers on by default
            };
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        function render() {
            renderItems();
            renderWires();
            updateScores();
            
            // Recalculate power flow in simulate mode to update wire glow
            if (currentMode === 'simulate') {
                SimulateMode.calculatePowerFlow();
            }
        }
        
        function renderItems() {
            const itemGroups = itemsGroup.selectAll(".item-group")
                .data(allItems, d => d.id);
            
            // Remove old items
            itemGroups.exit().remove();
            
            // Add new items
            const newItems = itemGroups.enter()
                .append("g")
                .attr("class", d => `item-group ${d.type}`)
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .call(d3.drag()
                    .touchable(true) // Enable touch support
                    .on("start", function(event, d) {
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                            event.sourceEvent.preventDefault();
                        }
                        dragStarted.call(this, event, d);
                    })
                    .on("drag", function(event, d) {
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                            event.sourceEvent.preventDefault();
                        }
                        dragged.call(this, event, d);
                    })
                    .on("end", function(event, d) {
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                            event.sourceEvent.preventDefault();
                        }
                        dragEnded.call(this, event, d);
                    })
                )
                .on("click", (event, d) => {
                    event.stopPropagation();
                    // In live or simulate mode, toggle loads when clicked
                    if (d.type === 'acload') {
                        if (currentMode === 'live' && LiveView.state.active) {
                            toggleLoad(d);
                        } else if (currentMode === 'simulate') {
                            // In simulate mode, toggle load state
                            toggleLoadInSimulate(d);
                        }
                    }
                    // Always select the item to open inspector
                    selectItem(d);
                })
                .on("touchend", (event, d) => {
                    // Handle touch as click for mobile devices
                    event.stopPropagation();
                    event.preventDefault();
                    // Only trigger if it wasn't a drag (check if moved significantly)
                    if (event.changedTouches && event.changedTouches.length > 0) {
                        const touch = event.changedTouches[0];
                        // Check if this was a tap (not a drag) by checking drag state
                        if (!isDragging || (Math.abs(touch.clientX - dragStartPos.x) < 10 && Math.abs(touch.clientY - dragStartPos.y) < 10)) {
                            // In live or simulate mode, toggle loads when tapped
                            if (d.type === 'acload') {
                                if (currentMode === 'live' && LiveView.state.active) {
                                    toggleLoad(d);
                                } else if (currentMode === 'simulate') {
                                    toggleLoadInSimulate(d);
                                }
                            }
                            // Always select the item to open inspector
                            selectItem(d);
                        }
                    }
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    // In live or simulate mode, toggle loads on double-click too
                    if (d.type === 'acload') {
                        if (currentMode === 'live' && LiveView.state.active) {
                            toggleLoad(d);
                        } else if (currentMode === 'simulate') {
                            toggleLoadInSimulate(d);
                        }
                    }
                    selectItem(d); // Also open inspector on double-click
                });
            
            // Render based on type
            newItems.each(function(d) {
                const g = d3.select(this);
                
                if (d.type === 'panel') {
                    renderPanel(g, d);
                } else if (d.type === 'battery') {
                    renderBattery(g, d);
                } else if (d.type === 'controller') {
                    renderController(g, d);
                } else if (d.type === 'breaker') {
                    renderBreaker(g, d);
                } else if (d.type === 'combiner') {
                    renderCombiner(g, d);
                } else if (d.type === 'solarcombiner') {
                    renderSolarCombiner(g, d);
                } else if (d.type === 'smartbattery') {
                    renderSmartBattery(g, d);
                } else if (d.type === 'doublevoltagehub') {
                    renderDoubleVoltageHub(g, d);
                } else if (d.type === 'acbreaker') {
                    renderACBreaker(g, d);
                } else if (d.type === 'acoutlet') {
                    renderACOutlet(g, d);
                } else if (d.type === 'spiderbox') {
                    renderSpiderBox(g, d);
                } else if (d.type === 'breakerpanel') {
                    renderBreakerPanel(g, d);
                } else if (d.type === 'acload') {
                    renderACLoad(g, d);
                } else if (d.type === 'resourcecontainer') {
                    renderResourceContainer(g, d);
                }
            });
            
            // Update existing items
            itemGroups.attr("transform", d => `translate(${d.x}, ${d.y})`)
                .classed("selected", d => {
                    if (selectedItem && selectedItem.id === d.id) return true;
                    if (selectedArray && d.type === 'panel' && selectedArray.some(p => p.id === d.id)) return true;
                    return false;
                });
            
            // For controllers, check if they need to be re-rendered with new styling
            itemGroups.filter(d => d.type === 'controller').each(function(d) {
                const g = d3.select(this);
                const hasDefs = g.select("defs").node() !== null;
                const hasContainer = g.select("g[clip-path]").node() !== null;
                const hasTopPath = g.select("path.controller-top-section").node() !== null;
                const hasBottomPath = g.select("path.controller-bottom-section").node() !== null;
                const oldRect = g.select("rect.item-rect");
                const hasOldStyleRect = oldRect.node() !== null && oldRect.attr("fill") !== "none" && oldRect.attr("fill") !== null;
                
                // If missing new structure or has old style, fully re-render
                if (!hasDefs || !hasContainer || !hasTopPath || !hasBottomPath || hasOldStyleRect) {
                    g.selectAll("*").remove();
                    renderController(g, d);
                }
            });
            
            // Update item content - merge enter and update selections to update ALL items
            const allItemGroups = newItems.merge(itemGroups);
            allItemGroups.each(function(d) {
                const g = d3.select(this);
                updateItemContent(g, d);
            });
        }
        
        // === RENDER HELPERS (consolidated) ===
        
        // Base rectangle with common attributes
        function _renderRect(g, d, opts = {}) {
            return g.append("rect")
                .attr("class", opts.cls || "item-rect")
                .attr("width", opts.w || d.width)
                .attr("height", opts.h || d.height)
                .attr("x", opts.x || 0)
                .attr("y", opts.y || 0)
                .attr("rx", opts.rx || 4)
                .attr("ry", opts.ry || opts.rx || 4)
                .attr("fill", opts.fill || "#2a2a2a")
                .attr("stroke", opts.stroke || "#666")
                .attr("stroke-width", opts.sw || 2);
        }
        
        // Common busbar rendering for combiners
        function _renderBusbars(g, d, y1Pct = 0.35, y2Pct = 0.55) {
            g.append("rect").attr("class", "combiner-busbar positive-bus")
                .attr("x", 8).attr("y", d.height * y1Pct).attr("width", d.width - 16).attr("height", 4).attr("fill", "#f0ad4e");
            g.append("rect").attr("class", "combiner-busbar negative-bus")
                .attr("x", 8).attr("y", d.height * y2Pct).attr("width", d.width - 16).attr("height", 4).attr("fill", "#5bc0de");
        }
        
        // Port labels (INPUT/OUTPUT text above/below component)
        function _renderPortLabels(g, d, topText, bottomText) {
            if (topText) g.append("text").attr("class", "port-label").attr("x", d.width / 2).attr("y", -18).attr("text-anchor", "middle").text(topText);
            if (bottomText) g.append("text").attr("class", "port-label").attr("x", d.width / 2).attr("y", d.height + 22).attr("text-anchor", "middle").text(bottomText);
        }
        
        // Centered text label
        function _renderLabel(g, opts) {
            return g.append("text")
                .attr("class", opts.cls || "item-label")
                .attr("x", opts.x)
                .attr("y", opts.y)
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", opts.baseline || "auto")
                .attr("font-size", opts.size || "10px")
                .attr("font-weight", opts.bold ? "bold" : "normal")
                .attr("fill", opts.fill || "#fff")
                .text(opts.text);
        }
        
        // Main breaker toggle (shared by SpiderBox and BreakerPanel)
        function _renderMainBreakerToggle(g, d, cfg) {
            const mainOn = d.mainBreakerOn !== false;
            const group = g.append("g").style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) LiveView.state.loadStates[loadId] = false;
                            }
                        });
                    }
                    if (cfg.onToggle) cfg.onToggle();
                    if (LiveView.state.active) { LiveView.Animation.scheduleUpdate(); } else { render(); }
                });
            
            // Body
            group.append("rect")
                .attr("x", cfg.x).attr("y", cfg.y).attr("width", cfg.w).attr("height", cfg.h).attr("rx", cfg.rx || 4)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555").attr("stroke-width", 2);
            
            // Toggle indicator
            group.append("rect")
                .attr("x", mainOn ? cfg.toggleOnX : cfg.toggleOffX).attr("y", cfg.toggleY)
                .attr("width", 10).attr("height", cfg.toggleH || 14).attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            // Labels
            _renderLabel(group, { x: cfg.labelX, y: cfg.labelY1, text: "MAIN", size: "8px", bold: true, fill: mainOn ? "#fff" : "#666" });
            _renderLabel(group, { x: cfg.labelX, y: cfg.labelY2, text: cfg.rating || "50A", size: "7px", fill: mainOn ? "#f88" : "#555" });
            
            return { group, mainOn };
        }
        
        // Circuit breaker toggle track+slider (shared rendering for panel circuits)
        function _renderBreakerToggleSwitch(group, cfg) {
            const { x, y, w, h, isOn, toggleX, toggleW, is240V, isTripped } = cfg;
            const onColor = is240V ? "#ff4444" : "#ffd700";
            const offColor = "#ff4444";
            const color = isTripped ? "#ff4444" : (isOn ? onColor : offColor);
            
            // Track
            group.append("rect").attr("class", "breaker-toggle-track")
                .attr("x", x).attr("y", y).attr("width", w).attr("height", h).attr("rx", 3)
                .attr("fill", isOn ? "#4a4a2a" : "#2a2a2a")
                .attr("stroke", isOn ? onColor : "#666").attr("stroke-width", 2);
            
            // Slider
            group.append("rect").attr("class", "breaker-toggle-slider")
                .attr("x", toggleX).attr("y", y + 2).attr("width", toggleW).attr("height", h - 4).attr("rx", 2)
                .attr("fill", color).attr("stroke", isOn ? "#fff700" : "#ff6666").attr("stroke-width", 1.5);
            
            // ON/OFF label
            _renderLabel(group, { x: x + w/2, y: y + h/2 + 3, text: isOn ? "ON" : "OFF", size: "7px", bold: true, fill: isOn ? "#fff" : "#888" });
        }
        
        // Unified combiner rendering
        function _renderCombinerBase(g, d, isSolar) {
            _renderRect(g, d, { rx: isSolar ? 6 : 4 });
            
            if (isSolar) {
                // Breaker indicators for each input
                const numInputs = d.specs.inputs;
                for (let i = 0; i < numInputs; i++) {
                    const xPos = ((i + 0.5) / numInputs) * d.width;
                    const isClosed = d.breakerStates[i];
                    g.append("rect").attr("class", `input-breaker input-breaker-${i}`)
                        .attr("x", xPos - 8).attr("y", d.height * 0.15).attr("width", 16).attr("height", 12).attr("rx", 2)
                        .attr("fill", isClosed ? "#5cb85c" : "#d9534f").attr("stroke", "#333").attr("stroke-width", 1);
                }
                _renderBusbars(g, d, 0.4, 0.55);
                _renderLabel(g, { x: d.width/2, y: d.height * 0.78, text: "SOLAR COMBINER", size: "9px", bold: true, cls: "solarcombiner-label" });
                _renderLabel(g, { x: d.width/2, y: d.height * 0.92, text: `${numInputs}x ${d.specs.breakerRating}A`, size: "8px", fill: "#aaa", cls: "solarcombiner-specs", baseline: "middle" });
                _renderPortLabels(g, d, "PV STRINGS", "TO CONTROLLER");
            } else {
                _renderBusbars(g, d);
                _renderLabel(g, { x: d.width/2, y: d.height * 0.85, text: d.specs.inputs + "-STRING", size: "10px", cls: "combiner-label", baseline: "middle" });
                _renderPortLabels(g, d, "INPUTS", "OUTPUT");
            }
            renderHandles(g, d);
        }
        
        function renderPanel(g, d) {
            // Main panel body with improved styling
            const panelRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#1a2a3a")
                .attr("stroke", "#3a5a7a")
                .attr("stroke-width", 2);
            
            // Add subtle gradient effect for depth
            const gradient = g.append("defs").append("linearGradient")
                .attr("id", `panelGradient-${d.id}`)
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");
            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "#2a4a6a")
                .attr("stop-opacity", 1);
            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "#1a2a3a")
                .attr("stop-opacity", 1);
            panelRect.attr("fill", `url(#panelGradient-${d.id})`);
            
            // Panel cell grid - more detailed for larger panels
            const cellCols = Math.max(6, Math.floor(d.width / 15)); // More cells for wider panels
            const cellRows = Math.max(3, Math.floor(d.height / 20)); // More rows for taller panels
            
            // Vertical cell lines
            for (let i = 1; i < cellCols; i++) {
                g.append("line")
                    .attr("class", "panel-cells")
                    .attr("x1", (d.width / cellCols) * i)
                    .attr("y1", 6)
                    .attr("x2", (d.width / cellCols) * i)
                    .attr("y2", d.height - 6)
                    .attr("stroke", "#0f1a25")
                    .attr("stroke-width", 1)
                    .attr("opacity", 0.6);
            }
            
            // Horizontal cell lines
            for (let i = 1; i < cellRows; i++) {
                g.append("line")
                    .attr("class", "panel-cells")
                    .attr("x1", 6)
                    .attr("y1", (d.height / cellRows) * i)
                    .attr("x2", d.width - 6)
                    .attr("y2", (d.height / cellRows) * i)
                    .attr("stroke", "#0f1a25")
                    .attr("stroke-width", 1)
                    .attr("opacity", 0.6);
            }
            
            // Add border frame effect
            g.append("rect")
                .attr("x", 3)
                .attr("y", 3)
                .attr("width", d.width - 6)
                .attr("height", d.height - 6)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", "none")
                .attr("stroke", "#4a6a8a")
                .attr("stroke-width", 1)
                .attr("opacity", 0.5);
            
            // Add corner mounting brackets (small squares)
            const bracketSize = 4;
            g.append("rect").attr("x", 2).attr("y", 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            g.append("rect").attr("x", d.width - bracketSize - 2).attr("y", 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            g.append("rect").attr("x", 2).attr("y", d.height - bracketSize - 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            g.append("rect").attr("x", d.width - bracketSize - 2).attr("y", d.height - bracketSize - 2).attr("width", bracketSize).attr("height", bracketSize).attr("fill", "#5a7a9a");
            
            // Label - show real-time output in live view
            let panelOutputWatts = d.specs.wmp;
            if (liveViewActive) {
                // Calculate actual output (simplified - assume full output for now)
                panelOutputWatts = d.specs.wmp;
            }
            
            // Power label with better styling
            g.append("text")
                .attr("class", "panel-label wmp-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 - 10)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#ffdd57")
                .attr("font-size", Math.max(10, Math.min(14, d.height / 8)))
                .attr("font-weight", "bold")
                .text(panelOutputWatts + "W");
            
            // Voltage label
            g.append("text")
                .attr("class", "panel-specs voc-label")
                .attr("x", d.width / 2)
                .attr("y", d.height / 2 + 8)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#aaccff")
                .attr("font-size", Math.max(8, Math.min(11, d.height / 10)))
                .text(d.specs.voc.toFixed(1) + "V");
            
            // Polarity labels on sides
            g.append("text")
                .attr("class", "port-label")
                .attr("x", -15)
                .attr("y", d.height / 2)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .text("+");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width + 15)
                .attr("y", d.height / 2)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .text("-");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderBattery(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Capacity bar background (for charge visualization)
            g.append("rect")
                .attr("class", "capacity-bar-bg")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Capacity bar fill (will be updated based on charge)
            const capacityBarFill = g.append("rect")
                .attr("class", "capacity-bar-fill")
                .attr("x", 0)
                .attr("y", d.height)
                .attr("width", d.width)
                .attr("height", 0)
                .attr("rx", 6)
                .attr("ry", 6);
            
            // Terminal indicators (positioned to match handle locations)
            g.append("rect")
                .attr("class", "battery-terminal-pos")
                .attr("x", d.width * 0.25 - 10)
                .attr("y", -12)
                .attr("width", 20)
                .attr("height", 12)
                .attr("rx", 2);
            
            g.append("rect")
                .attr("class", "battery-terminal-neg")
                .attr("x", d.width * 0.75 - 10)
                .attr("y", -12)
                .attr("width", 20)
                .attr("height", 12)
                .attr("rx", 2);
            
            // Labels
            g.append("text")
                .attr("class", "battery-label voltage-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.35)
                .attr("dominant-baseline", "middle")
                .text(d.specs.voltage.toFixed(1) + "V");
            
            g.append("text")
                .attr("class", "battery-label ah-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.55)
                .attr("dominant-baseline", "middle")
                .text(d.specs.ah + "Ah");
            
            // Show real-time charge in live view or simulation
            const showCharge = liveViewActive || currentMode === 'simulate';
            if (showCharge) {
                // Find controller connected to this battery to get system battery specs
                const controllers = allItems.filter(i => i.type === 'controller');
                let batteryKwh = d.specs.kWh || 0;
                let batteryPercent = 50; // Default
                let currentCharge = 0;
                
                // Try to find connected controller
                controllers.forEach(controller => {
                    if (controller.handles?.batteryPositive) {
                        controller.handles.batteryPositive.connectedTo.forEach(conn => {
                            const batt = allItems.find(i => i.id === conn.itemId);
                            if (batt && batt.id === d.id) {
                                const batterySpecs = calculateConnectedBatterySpecs(controller);
                                batteryKwh = batterySpecs.kWh || batteryKwh;
                                
                                // Get current charge from simulation stats if in simulate mode
                                if (currentMode === 'simulate' && simStats.maxBatteryCapacity > 0) {
                                    currentCharge = simStats.batteryCharge;
                                    batteryPercent = (currentCharge / simStats.maxBatteryCapacity) * 100;
                                } else {
                                    batteryPercent = 50; // Default for live view
                                }
                            }
                        });
                    }
                });
                
                // Update capacity bar fill based on charge
                const fillRatio = batteryKwh > 0 ? Math.max(0, Math.min(1, currentCharge / batteryKwh)) : 0;
                const fillHeight = fillRatio * d.height;
                
                capacityBarFill
                    .attr("y", d.height - fillHeight)
                    .attr("height", fillHeight)
                    .classed("low", batteryPercent < 20)
                    .classed("medium", batteryPercent >= 20 && batteryPercent < 50)
                    .classed("high", batteryPercent >= 50);
                
                g.append("text")
                    .attr("class", "battery-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height * 0.75)
                    .attr("dominant-baseline", "middle")
                    .attr("fill", batteryPercent >= 50 ? "#5cb85c" : batteryPercent >= 20 ? "#f0ad4e" : "#d9534f")
                    .text(`${currentCharge > 0 ? currentCharge.toFixed(1) : batteryKwh.toFixed(1)}kWh (${batteryPercent.toFixed(0)}%)`);
            } else {
                g.append("text")
                    .attr("class", "battery-specs")
                    .attr("x", d.width / 2)
                    .attr("y", d.height * 0.75)
                    .attr("dominant-baseline", "middle")
                    .text(d.specs.kWh.toFixed(2) + " kWh");
                
                // Hide capacity bar in build mode
                capacityBarFill.attr("height", 0);
            }
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderController(g, d) {
            const isHybrid = d.specs.type === 'hybrid_inverter' || d.specs.type === 'all_in_one';
            
            // Get styling options or use defaults
            const topColor = d.specs.topColor || '#c0c0c0';
            const bottomColor = d.specs.bottomColor || '#2a2a2a';
            const dividerHeight = d.specs.dividerHeight !== undefined ? d.specs.dividerHeight : 50; // Percentage from top
            const imageUrl = d.specs.imageUrl;
            
            // Calculate divider position
            const dividerY = (d.height * dividerHeight) / 100;
            const radius = 8;
            
            // SIMPLEST APPROACH: Use two rects with rounded corners
            // Render order: base rect -> top section -> border -> image -> text
            // This ensures styled rectangles are visible and not covered
            
            // Invisible hit area rect FIRST - this captures pointer events for dragging
            // Must be first so it's behind everything visually but captures events
            g.append("rect")
                .attr("class", "controller-hit-area")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", radius)
                .attr("ry", radius)
                .attr("fill", "transparent")
                .style("pointer-events", "all") // This captures drag events
                .style("cursor", "grab");
            
            // Main border/stroke (visual only, doesn't capture events)
            const borderRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", radius)
                .attr("ry", radius)
                .attr("fill", "none")
                .style("fill", "none") // Force transparent fill
                .style("pointer-events", "none") // Don't block drag events
                .attr("stroke", d.destroyed ? "#ff0000" : (isHybrid ? "#5c6bc0" : "#888"))
                .attr("stroke-width", d.destroyed ? 4 : 2);
            
            // Base background (bottom color) - render AFTER border so it's visible
            const baseRect = g.append("rect")
                .attr("class", "controller-base")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", radius)
                .attr("ry", radius)
                .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : bottomColor)
                .attr("stroke", "none")
                .style("pointer-events", "none") // Don't block drag events
                .style("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : bottomColor); // Force fill via style
            
            // Top section (overlay on top of base) - only if divider is not at bottom
            // Use sharp corners at the bottom (divider line) and rounded corners at the top
            if (dividerY > 0 && dividerY < d.height) {
                // Create a path for the top section with rounded top corners only
                const topPath = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                g.append("path")
                    .attr("class", "controller-top-section")
                    .attr("d", topPath)
                    .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                    .attr("stroke", "none")
                    .style("pointer-events", "none") // Don't block drag events
                    .style("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor); // Force fill via style
            } else if (dividerY >= d.height) {
                // Divider at or beyond bottom - entire controller is top color
                baseRect
                    .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                    .style("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor);
            }
            
            // Background image if provided (on top of color sections but below text)
            if (imageUrl) {
                g.append("image")
                    .attr("class", "controller-background-image")
                    .attr("href", imageUrl)
                    .attr("width", d.width)
                    .attr("height", d.height)
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("preserveAspectRatio", "xMidYMid slice")
                    .attr("opacity", 0.8)
                    .style("pointer-events", "none");
            }
            
            // Add "DESTROYED" text if destroyed
            if (d.destroyed) {
                g.append("text")
                    .attr("class", "destroyed-label")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#ff0000")
                    .attr("font-weight", "bold")
                    .attr("font-size", "14px")
                    .text("üí• DESTROYED");
                
                // Add reset button
                const resetBtn = g.append("rect")
                    .attr("class", "reset-button")
                    .attr("x", d.width / 2 - 30)
                    .attr("y", d.height / 2 + 15)
                    .attr("width", 60)
                    .attr("height", 20)
                    .attr("rx", 4)
                    .attr("fill", "#5cb85c")
                    .attr("stroke", "#4cae4c")
                    .attr("stroke-width", 1)
                    .style("cursor", "pointer");
                
                resetBtn.append("title").text("Click to reset");
                
                g.append("text")
                    .attr("class", "reset-button-text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height / 2 + 27)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text("RESET")
                    .style("cursor", "pointer")
                    .style("pointer-events", "none");
                
                // Make reset button clickable
                resetBtn.on("click", (event) => {
                    event.stopPropagation();
                    d.destroyed = false;
                    d.batteryOvervoltage = false;
                    d.incompatibleVoltageShown = false;
                    d.reversedPolarityWarningShown = false;
                    render();
                    validateSystem();
                });
                
                return; // Don't render normal controller content if destroyed
            }
            
            // Calculate dynamic font sizes based on controller dimensions
            // Base font size scales with height, with min/max limits
            const baseFontSize = Math.max(10, Math.min(16, d.height * 0.12)); // Scale with height, clamp between 10-16px
            const labelFontSize = Math.max(11, Math.min(15, d.height * 0.13)); // Slightly larger for name
            const specsFontSize = Math.max(9, Math.min(13, d.height * 0.11)); // Slightly smaller for specs
            
            // Calculate text positions that scale with dimensions
            const centerY = d.height / 2;
            const textSpacing = Math.max(12, d.height * 0.15); // Spacing between text lines
            
            // Create a text group that renders on top of the background
            const textGroup = g.append("g").attr("class", "controller-text-group");
            
            // Labels - always use the controller's name
            const nameLabel = d.specs.name || (isHybrid ? 'HYBRID INV' : 'CONTROLLER');
            
            // Create a filter for drop shadow
            const defs = g.append("defs");
            const filter = defs.append("filter")
                .attr("id", `controller-text-shadow-${d.id}`)
                .attr("x", "-50%")
                .attr("y", "-50%")
                .attr("width", "200%")
                .attr("height", "200%");
            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 2)
                .attr("result", "blur");
            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 1)
                .attr("dy", 1)
                .attr("result", "offsetBlur");
            const feComponentTransfer = filter.append("feComponentTransfer")
                .attr("in", "offsetBlur");
            feComponentTransfer.append("feFuncA")
                .attr("type", "linear")
                .attr("slope", 0.8);
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");
            
            textGroup.append("text")
                .attr("class", "controller-label")
                .attr("x", d.width / 2)
                .attr("y", centerY - textSpacing * 0.8)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("font-size", `${labelFontSize}px`)
                .attr("font-weight", "bold")
                .attr("fill", "#fff")
                .attr("filter", `url(#controller-text-shadow-${d.id})`)
                .style("pointer-events", "none")
                .text(nameLabel);
            
            // Show real-time power in live view
            if (liveViewActive) {
                const arraySpecs = calculateConnectedArraySpecs(d);
                const dcInputWatts = arraySpecs.wmp || 0;
                const acOutputWatts = Math.min(dcInputWatts, d.specs.maxACOutputW || 0);
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 0.3)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#f0ad4e")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(`DC: ${dcInputWatts}W`);
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 1.1)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#f0ad4e")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(`AC: ${acOutputWatts}W`);
            } else {
                // Truncate long text to fit width
                const maxWmpText = (d.specs.maxWmp + "W max").length > 12 ? 
                    (d.specs.maxWmp / 1000).toFixed(1) + "kW max" : 
                    d.specs.maxWmp + "W max";
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 0.3)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#fff")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(maxWmpText);
                
                // Format voltage/current text to fit
                const voltageText = d.specs.maxVoc + "V / " + d.specs.maxIsc + "A";
                const maxTextLength = Math.floor(d.width / (specsFontSize * 0.6)); // Approximate chars that fit
                const displayText = voltageText.length > maxTextLength ? 
                    d.specs.maxVoc + "V/" + d.specs.maxIsc + "A" : 
                    voltageText;
                
                textGroup.append("text")
                    .attr("class", "controller-specs")
                    .attr("x", d.width / 2)
                    .attr("y", centerY + textSpacing * 1.1)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("font-size", `${specsFontSize}px`)
                    .attr("fill", "#fff")
                    .attr("stroke", "rgba(0,0,0,0.3)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(displayText);
            }
            
            // PV label inside controller (near top handles) - scale with dimensions
            const portLabelSize = Math.max(8, Math.min(12, d.height * 0.08));
            textGroup.append("text")
                .attr("class", "port-label-internal")
                .attr("x", d.width * 0.325)
                .attr("y", Math.max(10, d.height * 0.08))
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .attr("font-size", `${portLabelSize}px`)
                .attr("stroke", "rgba(0,0,0,0.5)")
                .attr("stroke-width", "0.5px")
                .style("pointer-events", "none")
                .text("PV");
            
            const isAllInOne = d.specs.type === 'all_in_one';
            
            // For all-in-one units, show internal battery instead of external BATT label
            if (isAllInOne && d.specs.internalBatteryKWh) {
                // Internal battery box (increased height for better visibility)
                const battBoxWidth = d.width * 0.7;
                const battBoxHeight = 36;  // Increased from 28 to 36
                const battBoxX = (d.width - battBoxWidth) / 2;
                const battBoxY = d.height - battBoxHeight - 8;
                
                g.append("rect")
                    .attr("class", "internal-battery")
                    .attr("x", battBoxX)
                    .attr("y", battBoxY)
                    .attr("width", battBoxWidth)
                    .attr("height", battBoxHeight)
                    .attr("rx", 4)
                    .attr("fill", "rgba(92, 184, 92, 0.3)")
                    .attr("stroke", "#5cb85c")
                    .attr("stroke-width", 1);
                
                // Battery icon (small terminals)
                g.append("rect")
                    .attr("x", battBoxX + battBoxWidth * 0.25 - 4)
                    .attr("y", battBoxY - 3)
                    .attr("width", 8)
                    .attr("height", 4)
                    .attr("fill", "#5cb85c");
                g.append("rect")
                    .attr("x", battBoxX + battBoxWidth * 0.75 - 4)
                    .attr("y", battBoxY - 3)
                    .attr("width", 8)
                    .attr("height", 4)
                    .attr("fill", "#333");
                
                // Battery capacity text - scale with dimensions
                const battLabelSize = Math.max(9, Math.min(12, d.height * 0.09));
                textGroup.append("text")
                    .attr("class", "internal-battery-label")
                    .attr("x", d.width / 2)
                    .attr("y", battBoxY + battBoxHeight / 2)
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-size", `${battLabelSize}px`)
                    .attr("font-weight", "bold")
                    .attr("stroke", "rgba(0,0,0,0.5)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text(`üîã ${d.specs.internalBatteryKWh} kWh`);
            } else {
                // BATT label inside controller (near bottom handles) - for non all-in-one
                textGroup.append("text")
                    .attr("class", "port-label-internal")
                    .attr("x", d.width * 0.675)
                    .attr("y", d.height - Math.max(10, d.height * 0.08))
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#fff")
                    .attr("font-weight", "bold")
                    .attr("font-size", `${portLabelSize}px`)
                    .attr("stroke", "rgba(0,0,0,0.5)")
                    .attr("stroke-width", "0.5px")
                    .style("pointer-events", "none")
                    .text("BATT");
            }
            
            // AC Output label removed for cleaner appearance
            // Smart battery port labels removed (EXT1, EXT2) for cleaner appearance
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderSmartBattery(g, d) {
            _renderRect(g, d, { rx: 6, fill: "#2a4a2a", stroke: "#5cb85c", sw: 1.5 });
            // Battery icon terminals
            g.append("rect").attr("x", d.width * 0.3 - 4).attr("y", 8).attr("width", 8).attr("height", 4).attr("fill", "#5cb85c");
            g.append("rect").attr("x", d.width * 0.7 - 4).attr("y", 8).attr("width", 8).attr("height", 4).attr("fill", "#333");
            _renderLabel(g, { x: d.width/2, y: 28, text: "SMART BATTERY", size: "10px", bold: true, fill: "#5cb85c" });
            _renderLabel(g, { x: d.width/2, y: d.height/2 + 8, text: `üîã ${d.specs.kWh} kWh`, size: "14px", bold: true });
            _renderLabel(g, { x: d.width/2, y: d.height - 12, text: `${d.specs.voltage}V`, size: "9px", fill: "#888", cls: "item-specs" });
            renderHandles(g, d);
        }
        
        function renderDoubleVoltageHub(g, d) {
            _renderRect(g, d, { rx: 6, fill: "#1a3a4a", stroke: "#00a8e8" });
            _renderLabel(g, { x: d.width/2, y: 18, text: "ECOFLOW", size: "9px", bold: true, fill: "#00a8e8" });
            _renderLabel(g, { x: d.width/2, y: 32, text: "VOLTAGE HUB", size: "10px", bold: true });
            _renderLabel(g, { x: d.width/2, y: d.height - 10, text: `${d.specs.outputVoltage} ‚Ä¢ ${d.specs.maxOutputW}W`, size: "9px", fill: "#888", cls: "item-specs" });
            // IO labels
            g.append("text").attr("x", 15).attr("y", d.height * 0.33 + 3).attr("font-size", "7px").attr("fill", "#666").text("IN1");
            g.append("text").attr("x", 15).attr("y", d.height * 0.67 + 3).attr("font-size", "7px").attr("fill", "#666").text("IN2");
            g.append("text").attr("x", d.width - 20).attr("y", d.height * 0.5 + 3).attr("font-size", "7px").attr("fill", "#666").text("AC");
            renderHandles(g, d);
        }
        
        function renderACBreaker(g, d) {
            // Determine breaker state
            const isTripped = LiveView.state.active && LiveView.state.breakerStates[d.id]?.wasTripped;
            const isClosed = d.isClosed;
            
            // Main rect with color based on state
            let fillColor = "#3a3020";
            let strokeColor = "#f0ad4e";
            if (isTripped) {
                fillColor = "#3a2020";
                strokeColor = "#d9534f";
            } else if (!isClosed) {
                fillColor = "#2a2a2a";
                strokeColor = "#888";
            }
            
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", 2);
            
            // Breaker switch clickable (only in live view mode)
            const switchGroup = g.append("g")
                .attr("class", "breaker-switch-group")
                .style("cursor", liveViewActive ? "pointer" : "default")
                .on("click", (event) => {
                    if (!LiveView.state.active) return;
                    event.stopPropagation();
                    d.isClosed = !d.isClosed;
                    // Update live view breaker state - always create/update to ensure wasTripped is cleared
                    LiveView.state.breakerStates[d.id] = {
                        isClosed: d.isClosed,
                        wasTripped: false // Always clear tripped flag when manually toggling
                    };
                    render();
                    
                    // Refresh inspector if a load is currently selected
                    if (selectedItem && selectedItem.type === 'acload') {
                        openInspector(selectedItem);
                    }
                });
            
            // Toggle indicator
            let toggleColor = "#f0ad4e";
            if (isTripped) {
                toggleColor = "#d9534f";
            } else if (!isClosed) {
                toggleColor = "#888";
            }
            
            switchGroup.append("rect")
                .attr("x", d.width * 0.2)
                .attr("y", d.height * 0.25)
                .attr("width", d.width * 0.6)
                .attr("height", d.height * 0.2)
                .attr("rx", 2)
                .attr("fill", toggleColor);
            
            // Rating label
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.7)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text(`${d.specs.rating}A`);
            
            // Voltage label or current amps (in live view)
            if (liveViewActive) {
                const circuitInfo = LiveView.PowerFlow.calculateACCircuit(d);
                const ampsText = circuitInfo.totalAmps > 0 ? 
                    `${circuitInfo.totalAmps.toFixed(1)}A / ${d.specs.rating}A` : 
                    `${d.specs.rating}A`;
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", circuitInfo.totalAmps > d.specs.rating ? "#d9534f" : 
                           circuitInfo.totalAmps > d.specs.rating * 0.8 ? "#f0ad4e" : "#888")
                    .text(ampsText);
                
                // Show TRIPPED text if tripped
                if (isTripped) {
                    g.append("text")
                        .attr("x", d.width / 2)
                        .attr("y", d.height * 0.5)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", "#d9534f")
                        .attr("font-weight", "bold")
                        .text("TRIPPED");
                }
            } else {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", "#888")
                    .text(`${d.specs.voltage}V`);
            }
            
            renderHandles(g, d);
        }
        
        // Helper function to check if a breaker/panel is connected to a power source
        function hasPowerSourceConnection(item) {
            if (!item) return false;
            const visited = new Set();
            
            const traceToPowerSource = (currentItem, handleId = null) => {
                if (visited.has(currentItem.id)) return false;
                visited.add(currentItem.id);
                
                // Check if this is a power source
                if (currentItem.type === 'doublevoltagehub') {
                    // Check if hub has both inputs connected and AC output exists
                    const input1Connected = currentItem.handles?.input1?.connectedTo?.length > 0;
                    const input2Connected = currentItem.handles?.input2?.connectedTo?.length > 0;
                    if (input1Connected && input2Connected && currentItem.handles?.acOutput) {
                        // If we're checking from the AC output side, this is a valid power source
                        if (handleId && currentItem.handles.acOutput.id === handleId) {
                            // Verify at least one input has power flow
                            let hasLiveInput = false;
                            for (const inputConnInfo of currentItem.handles.input1.connectedTo) {
                                const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                if (inputConn) {
                                    const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                    if (powerFlow && powerFlow.isLive) {
                                        hasLiveInput = true;
                                        break;
                                    }
                                }
                            }
                            if (!hasLiveInput) {
                                for (const inputConnInfo of currentItem.handles.input2.connectedTo) {
                                    const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                    if (inputConn) {
                                        const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                        if (powerFlow && powerFlow.isLive) {
                                            hasLiveInput = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            // If both inputs are connected, consider it a valid power source
                            // (the power flow calculation will set isLive based on actual power)
                            return hasLiveInput || (input1Connected && input2Connected);
                        }
                        // If checking from input side, verify inputs have power
                        let hasLiveInput = false;
                        for (const inputConnInfo of currentItem.handles.input1.connectedTo) {
                            const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                            if (inputConn) {
                                const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                if (powerFlow && powerFlow.isLive) {
                                    hasLiveInput = true;
                                    break;
                                }
                            }
                        }
                        if (!hasLiveInput) {
                            for (const inputConnInfo of currentItem.handles.input2.connectedTo) {
                                const inputConn = connections.find(c => c.id === inputConnInfo.connectionId);
                                if (inputConn) {
                                    const powerFlow = LiveView.state.powerFlow[inputConn.id];
                                    if (powerFlow && powerFlow.isLive) {
                                        hasLiveInput = true;
                                        break;
                                    }
                                }
                            }
                        }
                        return hasLiveInput;
                    }
                }
                
                if (currentItem.type === 'controller' && handleId) {
                    // Check if controller AC output has power
                    const handle = Object.values(currentItem.handles).find(h => h.id === handleId);
                    if (handle && handle.polarity === 'ac') {
                        const arraySpecs = calculateConnectedArraySpecs(currentItem);
                        const dcInputWatts = arraySpecs.wmp || 0;
                        const hasPower = dcInputWatts > 0 || currentItem.specs.internalBatteryKWh > 0;
                        return hasPower;
                    }
                }
                
                // Trace back through connections
                const itemConnections = connections.filter(c => 
                    (c.sourceItemId === currentItem.id && (!handleId || c.sourceHandleId === handleId)) ||
                    (c.targetItemId === currentItem.id && (!handleId || c.targetHandleId === handleId))
                );
                
                for (const conn of itemConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                        i.id !== currentItem.id
                    );
                    if (!otherItem) continue;
                    
                    const otherHandleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                    if (traceToPowerSource(otherItem, otherHandleId)) {
                        return true;
                    }
                }
                
                return false;
            };
            
            // For breaker panels, check the input connection
            if (item.type === 'breakerpanel') {
                // Find the input connection (usually from double voltage hub or controller)
                const inputConnections = connections.filter(c => 
                    c.targetItemId === item.id || c.sourceItemId === item.id
                );
                for (const conn of inputConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                        i.id !== item.id
                    );
                    if (!otherItem) continue;
                    
                    // First, check if this connection has power flow set (most reliable)
                    const powerFlow = LiveView.state.powerFlow[conn.id];
                    if (powerFlow && powerFlow.isLive) {
                        return true;
                    }
                    
                    // For double voltage hub, check if hub has both inputs connected
                    if (otherItem.type === 'doublevoltagehub') {
                        const input1Connected = otherItem.handles?.input1?.connectedTo?.length > 0;
                        const input2Connected = otherItem.handles?.input2?.connectedTo?.length > 0;
                        if (input1Connected && input2Connected && otherItem.handles?.acOutput) {
                            // Check if the connection is from the hub's AC output
                            const hubAcOutputHandle = otherItem.handles.acOutput;
                            const isFromAcOutput = (conn.sourceItemId === otherItem.id && conn.sourceHandleId === hubAcOutputHandle.id) ||
                                                   (conn.targetItemId === otherItem.id && conn.targetHandleId === hubAcOutputHandle.id);
                            if (isFromAcOutput) {
                                // If hub has both inputs connected, it's a valid power source
                                // (power flow calculation will set isLive based on actual power)
                                return true;
                            }
                        }
                    }
                    
                    // For controllers, check if AC output has power
                    if (otherItem.type === 'controller') {
                        const handleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                        if (traceToPowerSource(otherItem, handleId)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // For AC breakers, check the line side connection
            if (item.type === 'acbreaker' || item.type === 'breaker') {
                const lineHandle = item.handles?.linePositive || item.handles?.lineIn;
                if (lineHandle && lineHandle.connectedTo) {
                    for (const connInfo of lineHandle.connectedTo) {
                        const conn = connections.find(c => c.id === connInfo.connectionId);
                        if (conn) {
                            const otherItem = allItems.find(i => 
                                (i.id === conn.sourceItemId || i.id === conn.targetItemId) &&
                                i.id !== item.id
                            );
                            if (otherItem) {
                                const handleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                                if (traceToPowerSource(otherItem, handleId)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            return traceToPowerSource(item);
        }
        
        // Helper function to check if an outlet's circuit is live
        function checkOutletCircuitStatus(outlet) {
            if (!outlet || !allItems.find(i => i.id === outlet.id)) {
                return { isLive: false };
            }
            
            // Trace back through daisy-chained outlets to find the breaker
            const visitedOutlets = new Set();
            const traceToBreaker = (currentOutlet) => {
                if (visitedOutlets.has(currentOutlet.id)) return null;
                visitedOutlets.add(currentOutlet.id);
                
                // Check all connections from this outlet
                const outletConnections = connections.filter(c => 
                    c.sourceItemId === currentOutlet.id || c.targetItemId === currentOutlet.id
                );
                
                for (const outletConn of outletConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId) &&
                        i.id !== currentOutlet.id
                    );
                    if (!otherItem) continue;
                    
                    // Check if it's a regular AC breaker
                    if (otherItem.type === 'acbreaker') {
                        const breakerHandle = otherItem.handles?.loadOut;
                        const outletHandle = currentOutlet.handles?.input;
                        if (breakerHandle && outletHandle &&
                            (outletConn.sourceHandleId === breakerHandle.id || outletConn.targetHandleId === breakerHandle.id) &&
                            (outletConn.sourceHandleId === outletHandle.id || outletConn.targetHandleId === outletHandle.id)) {
                            if (!LiveView.BreakerManager.isBreakerClosed(otherItem)) {
                                return { isLive: false };
                            }
                            // Verify breaker is connected to a power source
                            if (!hasPowerSourceConnection(otherItem)) {
                                return { isLive: false };
                            }
                            // Check if controller AC output is enabled (in simulate mode)
                            if (currentMode === 'simulate' && simStats.controllerACOutputEnabled === false) {
                                return { isLive: false };
                            }
                            return { isLive: true };
                        }
                    }
                    
                    // Check if it's a breaker panel
                    if (otherItem.type === 'breakerpanel') {
                        if (otherItem.mainBreakerOn === false) {
                            return { isLive: false };
                        }
                        
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < 8) {
                                if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false };
                                }
                                // Verify panel is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false };
                                }
                                // Check if controller AC output is enabled (in simulate mode)
                                if (currentMode === 'simulate' && simStats.controllerACOutputEnabled === false) {
                                    return { isLive: false };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // Check if it's a spider box
                    if (otherItem.type === 'spiderbox') {
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < otherItem.specs.circuits.length) {
                                if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false };
                                }
                                // Verify spider box is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false };
                                }
                                // Check if controller AC output is enabled (in simulate mode)
                                if (currentMode === 'simulate' && simStats.controllerACOutputEnabled === false) {
                                    return { isLive: false };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // If it's another outlet, trace through daisy-chain
                    if (otherItem.type === 'acoutlet') {
                        const currentOutletInput = currentOutlet.handles?.input;
                        const previousOutletOutput = otherItem.handles?.output;
                        if (currentOutletInput && previousOutletOutput &&
                            (outletConn.sourceHandleId === previousOutletOutput.id || outletConn.targetHandleId === previousOutletOutput.id) &&
                            (outletConn.sourceHandleId === currentOutletInput.id || outletConn.targetHandleId === currentOutletInput.id)) {
                            const result = traceToBreaker(otherItem);
                            if (result) return result;
                        }
                    }
                }
                return null;
            };
            
            const result = traceToBreaker(outlet);
            return result || { isLive: false };
        }
        
        function renderACOutlet(g, d) {
            const is240V = d.specs.voltage === 240;
            
            // Check if outlet is live (in live view mode)
            let isLive = false;
            if (liveViewActive && LiveView.state.active) {
                const circuitStatus = checkOutletCircuitStatus(d);
                isLive = circuitStatus.isLive;
            }
            
            // Main rect - show visual feedback when live
            const fillColor = isLive ? "#3a3a2a" : "#2a2a2a";
            const strokeColor = isLive ? (is240V ? "#ff6666" : "#ffd700") : (is240V ? "#d9534f" : "#f0ad4e");
            const strokeWidth = isLive ? 3 : 2;
            
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);
            
            // Add glow effect only when live (no default glow)
            // Glow is added/removed in updateItemContent based on live status
            
            // Outlet face plate
            g.append("rect")
                .attr("x", d.width * 0.15)
                .attr("y", d.height * 0.15)
                .attr("width", d.width * 0.7)
                .attr("height", d.height * 0.5)
                .attr("rx", 3)
                .attr("fill", "#f5f5dc");
            
            if (is240V) {
                // 240V outlet - horizontal slots
                g.append("rect")
                    .attr("x", d.width * 0.25)
                    .attr("y", d.height * 0.28)
                    .attr("width", d.width * 0.2)
                    .attr("height", 4)
                    .attr("fill", "#333");
                g.append("rect")
                    .attr("x", d.width * 0.55)
                    .attr("y", d.height * 0.28)
                    .attr("width", d.width * 0.2)
                    .attr("height", 4)
                    .attr("fill", "#333");
                // Ground
                g.append("circle")
                    .attr("cx", d.width * 0.5)
                    .attr("cy", d.height * 0.48)
                    .attr("r", 4)
                    .attr("fill", "#333");
            } else {
                // 120V NEMA 5-15 outlet - vertical slots
                g.append("rect")
                    .attr("x", d.width * 0.3)
                    .attr("y", d.height * 0.22)
                    .attr("width", 4)
                    .attr("height", d.height * 0.18)
                    .attr("fill", "#333");
                g.append("rect")
                    .attr("x", d.width * 0.65)
                    .attr("y", d.height * 0.22)
                    .attr("width", 4)
                    .attr("height", d.height * 0.18)
                    .attr("fill", "#333");
                // Ground (round)
                g.append("circle")
                    .attr("cx", d.width * 0.5)
                    .attr("cy", d.height * 0.52)
                    .attr("r", 3)
                    .attr("fill", "#333");
            }
            
            // Voltage label - show live status in live view
            if (liveViewActive && LiveView.state.active) {
                g.append("text")
                    .attr("class", "outlet-status")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", isLive ? "#ffd700" : "#888")
                    .attr("font-weight", isLive ? "bold" : "normal")
                    .text(isLive ? `LIVE ${d.specs.voltage}V` : `${d.specs.voltage}V`);
            } else {
                g.append("text")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", "#888")
                    .text(`${d.specs.voltage}V`);
            }
            
            // Port labels for daisy-chaining
            g.append("text")
                .attr("x", 3)
                .attr("y", d.height / 2 + 3)
                .attr("font-size", "6px")
                .attr("fill", "#666")
                .text("IN");
            
            g.append("text")
                .attr("x", d.width - 14)
                .attr("y", d.height / 2 + 3)
                .attr("font-size", "6px")
                .attr("fill", "#666")
                .text("OUT");
            
            renderHandles(g, d);
        }
        
        function renderResourceContainer(g, d) {
            // Resource colors matching the resource type
            const resourceColors = {
                [RESOURCE_TYPES.WATER]: { fill: '#1a4a6e', stroke: '#4a90e2', accent: '#4a90e2' },
                [RESOURCE_TYPES.BIOMASS]: { fill: '#3d2817', stroke: '#8B4513', accent: '#8B4513' },
                [RESOURCE_TYPES.WOODGAS]: { fill: '#4a4030', stroke: '#FFDEAD', accent: '#FFDEAD' },
                [RESOURCE_TYPES.BIOCHAR]: { fill: '#202020', stroke: '#606060', accent: '#404040' },
                [RESOURCE_TYPES.HEAT]: { fill: '#4a2010', stroke: '#ff6b35', accent: '#ff6b35' },
                [RESOURCE_TYPES.PLASTIC]: { fill: '#2a3a4a', stroke: '#5a8aaa', accent: '#5a8aaa' },
                [RESOURCE_TYPES.PLASTIC_FLAKES]: { fill: '#2a4a3a', stroke: '#5aaa8a', accent: '#5aaa8a' },
                [RESOURCE_TYPES.GENERIC]: { fill: '#3a3a3a', stroke: '#888', accent: '#aaa' }
            };
            const colors = resourceColors[d.specs.resourceType] || { fill: '#2a3a2a', stroke: '#6fa06c', accent: '#6fa06c' };
            
            // Main container rect - matching other node styles
            g.append("rect")
                .attr("class", "item-rect resource-container-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .style("fill", colors.fill)
                .style("stroke", colors.stroke)
                .style("stroke-width", 2);
            
            // Capacity bar background (inside the container)
            const barMargin = 8;
            const barWidth = d.width - barMargin * 2;
            const barHeight = d.height - 55; // Leave room for title and value text
            const barY = 30;
            
            g.append("rect")
                .attr("class", "capacity-bar-bg resource-capacity-bg")
                .attr("x", barMargin)
                .attr("y", barY)
                .attr("width", barWidth)
                .attr("height", barHeight)
                .attr("rx", 4)
                .attr("ry", 4)
                .style("fill", "rgba(0,0,0,0.3)");
            
            // Capacity bar fill
            const fillRatio = d.specs.capacity > 0 ? Math.max(0, Math.min(1, (d.specs.value || 0) / d.specs.capacity)) : 0;
            const fillHeight = fillRatio * barHeight;
            
            g.append("rect")
                .attr("class", "capacity-bar-fill resource-capacity-fill")
                .attr("x", barMargin)
                .attr("y", barY + barHeight - fillHeight)
                .attr("width", barWidth)
                .attr("height", fillHeight)
                .attr("rx", 4)
                .attr("ry", 4)
                .style("fill", colors.accent)
                .style("opacity", 0.8)
                .style("transition", "height 0.3s ease-out, y 0.3s ease-out");
            
            // Title/Name
            g.append("text")
                .attr("class", "resource-title")
                .attr("x", d.width / 2)
                .attr("y", 18)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", colors.stroke)
                .text(d.specs.name || d.specs.resourceType);
            
            // Value display - centered in the bar area
            g.append("text")
                .attr("class", "resource-value")
                .attr("x", d.width / 2)
                .attr("y", barY + barHeight / 2 + 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "24px")
                .attr("font-weight", "bold")
                .attr("fill", "#fff")
                .text((d.specs.value || 0).toFixed(1));
            
            // Unit display
            g.append("text")
                .attr("class", "resource-unit")
                .attr("x", d.width / 2)
                .attr("y", barY + barHeight / 2 + 26)
                .attr("text-anchor", "middle")
                .attr("font-size", "11px")
                .attr("fill", "#aaa")
                .text(d.specs.unit || 'units');
            
            // Capacity display at bottom
            g.append("text")
                .attr("class", "resource-capacity")
                .attr("x", d.width / 2)
                .attr("y", d.height - 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#888")
                .text(`/ ${d.specs.capacity} ${d.specs.unit}`);
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderProcessor(g, d) {
            // Main processor rect (square/rounded, distinct from other nodes)
            const mainRect = g.append("rect")
                .attr("class", "item-rect processor-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 8)
                .attr("ry", 8)
                .style("fill", "#2a3a4a")
                .style("stroke", "#4a5a6a")
                .style("stroke-width", 2);
            
            // Title
            g.append("text")
                .attr("class", "processor-title")
                .attr("x", d.width / 2)
                .attr("y", 25)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#ffffff")
                .text(d.specs.label || d.specs.name || 'PROCESSOR');
            
            // Image or emoji
            if (d.specs.img) {
                const isEmoji = d.specs.img.length <= 4 && !/^https?:\/\//.test(d.specs.img);
                if (isEmoji) {
                    g.append("text")
                        .attr("class", "processor-emoji")
                        .attr("x", d.width / 2)
                        .attr("y", d.height / 2 + 10)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "40px")
                        .text(d.specs.img);
                } else {
                    g.append("image")
                        .attr("class", "processor-img")
                        .attr("x", 10)
                        .attr("y", 40)
                        .attr("width", d.width - 20)
                        .attr("height", d.height - 80)
                        .attr("xlink:href", d.specs.img);
                }
            }
            
            // Power consumption display (watts)
            g.append("text")
                .attr("class", "processor-wattage")
                .attr("x", d.width / 2)
                .attr("y", d.height - 60)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#ffdd57")
                .text("0 W");
            
            // Start/Stop button
            const actionButton = g.append("g")
                .attr("class", "processor-action-button")
                .style("cursor", "pointer")
                .on("mousedown", (e) => {
                    e.stopPropagation();
                    toggleProcessor(d);
                });
            
            actionButton.append("rect")
                .attr("x", d.width / 2 - 40)
                .attr("y", d.height - 40)
                .attr("width", 80)
                .attr("height", 30)
                .attr("rx", 4)
                .style("fill", "#4a5a6a")
                .style("stroke", "#6a7a8a")
                .style("stroke-width", 1);
            
            actionButton.append("text")
                .attr("x", d.width / 2)
                .attr("y", d.height - 22)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#ffffff")
                .text(d.isRunning ? "Stop" : "Start");
            
            // Port labels will be added in updateItemContent
            // Handles (including resource ports and cord)
            renderHandles(g, d);
        }
        
        function renderACLoad(g, d) {
            // Check if load is ON - check both simState and LiveView state
            let isOn = false;
            if (currentMode === 'simulate') {
                // In simulate mode, check simState first, then LiveView state
                isOn = (d.simState && d.simState.isRunning) || (LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true);
            } else {
                // In live mode, check LiveView state
                isOn = LiveView.state.active && LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true;
            }
            
            // Store current state for change detection
            g.attr('data-is-on', isOn ? 'true' : 'false');
            
            // Check if load is on a tripped circuit
            let isOnTrippedCircuit = false;
            if (LiveView.state.active && isOn) {
                // Find the breaker for this load's circuit
                const loadConn = connections.find(c => c.targetItemId === d.id);
                if (loadConn) {
                    const outlet = allItems.find(i => i.id === loadConn.sourceItemId);
                    if (outlet && outlet.type === 'acoutlet') {
                        // Trace back to find breaker
                        const outletConn = connections.find(c => 
                            (c.targetItemId === outlet.id && outlet.handles?.input) ||
                            (c.sourceItemId === outlet.id && outlet.handles?.input)
                        );
                        if (outletConn) {
                            const breaker = allItems.find(i => 
                                i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId
                            );
                            if (breaker && (breaker.type === 'acbreaker' || breaker.type === 'breaker')) {
                                isOnTrippedCircuit = !breaker.isClosed && LiveView.state.breakerStates[breaker.id]?.wasTripped;
                            }
                        }
                    }
                }
            }
            
            // Main rect - appliance body with improved colors
            // Yellow when ON, red when tripped, dark gray when OFF
            const fillColor = isOn ? (isOnTrippedCircuit ? "#4a2a2a" : "#4a4a2a") : "#2a2a2a";
            const strokeColor = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
            const strokeWidth = isOn ? 4 : 2;
            
            const mainRect = g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);
            
            // Make entire node clickable - in live mode: toggle + select, in build mode: just select
            // The item-group click handler will handle selection, we just need to add toggle for live mode
            if (currentMode === 'live' && LiveView.state.active) {
                g.style("cursor", "pointer");
                mainRect.style("cursor", "pointer");
            } else {
                mainRect.style("cursor", "default");
                g.style("cursor", "default");
            }
            
            // Add glow effect when ON (yellow glow) or tripped (red glow)
            if (isOn && liveViewActive) {
                const glowColor = isOnTrippedCircuit ? "#ff4444" : "#ffd700";
                g.append("rect")
                    .attr("width", d.width)
                    .attr("height", d.height)
                    .attr("rx", 10)
                    .attr("ry", 10)
                    .attr("fill", "none")
                    .attr("stroke", glowColor)
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6)
                    .style("filter", "blur(3px)");
            }
            
            // Icon - bigger and more visible
            g.append("text")
                .attr("class", "load-icon")
                .attr("x", d.width / 2)
                .attr("y", 28)
                .attr("text-anchor", "middle")
                .attr("font-size", "24px")
                .attr("opacity", isOn ? 1 : 0.5)
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                .text(d.specs.icon || "‚ö°");
            
            // Name - bigger font
            g.append("text")
                .attr("class", "load-name")
                .attr("x", d.width / 2)
                .attr("y", 48)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff6666" : "#ffd700") : "#aaa")
                .attr("font-weight", "bold")
                .text(d.specs.name.length > 14 ? d.specs.name.substring(0, 13) + "‚Ä¶" : d.specs.name);
            
            // Wattage or status - bigger and more prominent
            // Check if in simulate mode and show simulation power consumption
            if (currentMode === 'simulate' && isPlaying && d.simState) {
                const simWatts = d.simState.currentPowerWatts || 0;
                if (simWatts > 0) {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#ffd700")
                        .attr("font-weight", "bold")
                        .text(`${Math.round(simWatts)}W`);
                } else {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#888")
                        .attr("font-weight", "bold")
                        .text("OFF");
                }
            } else if (liveViewActive) {
                if (isOn) {
                    const loadWatts = getLoadWatts(d);
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", isOnTrippedCircuit ? "#ff4444" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(`${loadWatts}W`);
                } else {
                    g.append("text")
                        .attr("class", "load-watts")
                        .attr("x", d.width / 2)
                        .attr("y", d.height - 12)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("fill", "#888")
                        .attr("font-weight", "bold")
                        .text("OFF");
                }
            } else {
                g.append("text")
                    .attr("class", "load-watts")
                    .attr("x", d.width / 2)
                    .attr("y", d.height - 12)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "11px")
                    .attr("fill", "#ffd700")
                    .attr("font-weight", "bold")
                    .text(`${getLoadWatts(d)}W`);
            }
            
            // Cord line visual - position based on cord handle location
            const cordHandle = d.handles.cord;
            const isRecipeBased = d.specs.recipes && d.specs.recipes.length > 0;
            
            if (isRecipeBased && cordHandle.side === 'left') {
                // Cord on left side for recipe-based loads
                g.append("line")
                    .attr("x1", 0)
                    .attr("y1", cordHandle.y)
                    .attr("x2", 10)
                    .attr("y2", cordHandle.y)
                    .attr("stroke", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#222")
                    .attr("stroke-width", 4);
            } else {
                // Cord on top for simple loads
                g.append("line")
                    .attr("x1", d.width / 2)
                    .attr("y1", 0)
                    .attr("x2", d.width / 2)
                    .attr("y2", 10)
                    .attr("stroke", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#222")
                    .attr("stroke-width", 4);
            }
            
            // Port labels for resource ports and power port
            const recipes = d.specs.recipes || [];
            if (recipes.length > 0) {
                // Show port labels in build mode
                const orientation = d.portOrientation || 'vertical';
                const PORT_TEXT_OFFSETX = 15;
                const PORT_TEXT_OFFSETY = 20;
                
                Object.values(d.handles).forEach(handle => {
                    if (handle.resourceType) {
                        // Resource port label
                        let labelX, labelY, textAnchor;
                        
                        if (orientation === 'vertical') {
                            labelX = handle.x;
                            labelY = handle.side === 'top' ? -PORT_TEXT_OFFSETY : d.height + PORT_TEXT_OFFSETY;
                            textAnchor = 'middle';
                        } else {
                            labelX = handle.side === 'left' ? -PORT_TEXT_OFFSETX : d.width + PORT_TEXT_OFFSETX;
                            labelY = handle.y;
                            textAnchor = handle.side === 'left' ? 'end' : 'start';
                        }
                        
                        g.append("text")
                            .attr("class", `port-text-label ${handle.polarity}`)
                            .attr("x", labelX)
                            .attr("y", labelY)
                            .style("text-anchor", textAnchor)
                            .style("font-size", "9px")
                            .style("fill", getResourceTypeColor(handle.resourceType))
                            .style("font-weight", "bold")
                            .text(handle.name || handle.resourceType);
                    }
                });
                
                // Power port label - position based on cord handle location
                if (cordHandle.side === 'left') {
                    // Power label on left side for recipe-based loads
                    g.append("text")
                        .attr("class", "port-text-label power-input")
                        .attr("x", -18)
                        .attr("y", cordHandle.y + 4)
                        .style("text-anchor", "end")
                        .style("font-size", "9px")
                        .style("fill", "#f0ad4e")
                        .style("font-weight", "bold")
                        .text("‚ö°");
                } else {
                    // Power label on top for simple loads with recipes
                    g.append("text")
                        .attr("class", "port-text-label power-input")
                        .attr("x", d.width / 2)
                        .attr("y", -18)
                        .style("text-anchor", "middle")
                        .style("font-size", "9px")
                        .style("fill", "#f0ad4e")
                        .style("font-weight", "bold")
                        .text("POWER");
                }
            }
            
            // On/Off Toggle Switch - bigger and more prominent with red/yellow colors
            const switchGroup = g.append("g")
                .attr("class", "load-switch-group")
                .style("pointer-events", "none"); // Disable pointer events on switch since whole node is clickable
            
            // Switch background (track) - bigger and less cramped
            const switchWidth = 50;
            const switchHeight = 22;
            const switchX = (d.width - switchWidth) / 2; // Centered horizontally
            const switchY = d.height - switchHeight - 10; // Near bottom with more space (increased from 8 to 10 for better spacing)
            
            // Track colors: yellow when ON, red when tripped, gray when OFF
            const trackFill = isOn ? (isOnTrippedCircuit ? "#4a2020" : "#4a4a20") : "#3a3a3a";
            const trackStroke = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#666";
            
            switchGroup.append("rect")
                .attr("class", "load-switch-track")
                .attr("x", switchX)
                .attr("y", switchY)
                .attr("width", switchWidth)
                .attr("height", switchHeight)
                .attr("rx", 9)
                .attr("ry", 9)
                .attr("fill", trackFill)
                .attr("stroke", trackStroke)
                .attr("stroke-width", 2);
            
            // Switch toggle (slider) - bigger and more visible
            const toggleSize = 18;
            const toggleX = isOn ? (switchX + switchWidth - toggleSize - 2) : (switchX + 2);
            const toggleY = switchY + 2;
            
            // Toggle colors: yellow when ON, red when tripped, gray when OFF
            const toggleFill = isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888";
            const toggleStroke = isOn ? (isOnTrippedCircuit ? "#ff6666" : "#fff700") : "#aaa";
            
            switchGroup.append("rect")
                .attr("class", "load-switch-toggle")
                .attr("x", toggleX)
                .attr("y", toggleY)
                .attr("width", toggleSize)
                .attr("height", toggleSize)
                .attr("rx", 7)
                .attr("ry", 7)
                .attr("fill", toggleFill)
                .attr("stroke", toggleStroke)
                .attr("stroke-width", 1);
            
            // Switch label (ON/OFF text) - bigger and more visible
            switchGroup.append("text")
                .attr("class", "load-switch-label")
                .attr("x", switchX + switchWidth / 2)
                .attr("y", switchY - 4)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", isOn ? (isOnTrippedCircuit ? "#ff4444" : "#ffd700") : "#888")
                .attr("font-weight", "bold")
                .text(isOn ? (isOnTrippedCircuit ? "TRIPPED" : "ON") : "OFF");
            
            renderHandles(g, d);
        }
        
        // Helper function to get the correct watts value for a load based on its behavior type
        function getLoadWatts(load) {
            if (!load || !load.specs) return 0;
            const behavior = load.specs.behavior || { type: 'constant' };
            // For constant loads, use avgWatts; for others, use maxWatts
            if (behavior.type === 'constant') {
                return load.specs.avgWatts || load.specs.maxWatts || 0;
            } else {
                return load.specs.maxWatts || load.specs.avgWatts || 0;
            }
        }
        
        // Helper function to check if a load's circuit is live (used by toggleLoad)
        function checkLoadCircuitStatus(load) {
            // Safety check: make sure load still exists
            if (!load || !allItems.find(i => i.id === load.id)) {
                return { isLive: false, message: "Load not found" };
            }
            
            // Find the connection from load to outlet
            const loadConn = connections.find(c => {
                const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                const targetItem = allItems.find(i => i.id === c.targetItemId);
                return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                       (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
            });
            if (!loadConn) return { isLive: false, message: "Load not connected to outlet" };
            
            // Find the outlet
            let outlet = allItems.find(i => 
                (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                i.type === 'acoutlet'
            );
            if (!outlet) return { isLive: false, message: "Outlet not found" };
            
            // Trace back through daisy-chained outlets to find the breaker
            const visitedOutlets = new Set();
            const traceToBreaker = (currentOutlet) => {
                if (visitedOutlets.has(currentOutlet.id)) return null;
                visitedOutlets.add(currentOutlet.id);
                
                // Check all connections from this outlet
                const outletConnections = connections.filter(c => 
                    c.sourceItemId === currentOutlet.id || c.targetItemId === currentOutlet.id
                );
                
                for (const outletConn of outletConnections) {
                    const otherItem = allItems.find(i => 
                        (i.id === outletConn.sourceItemId || i.id === outletConn.targetItemId) &&
                        i.id !== currentOutlet.id
                    );
                    if (!otherItem) continue;
                    
                    // Check if it's a regular AC breaker
                    if (otherItem.type === 'acbreaker') {
                        const breakerHandle = otherItem.handles?.loadOut;
                        const outletHandle = currentOutlet.handles?.input;
                        if (breakerHandle && outletHandle &&
                            (outletConn.sourceHandleId === breakerHandle.id || outletConn.targetHandleId === breakerHandle.id) &&
                            (outletConn.sourceHandleId === outletHandle.id || outletConn.targetHandleId === outletHandle.id)) {
                            // Use unified breaker state checking
                            if (!LiveView.BreakerManager.isBreakerClosed(otherItem)) {
                                return { isLive: false, message: "This circuit has no power. Check your breakers." };
                            }
                            // Verify breaker is connected to a power source
                            if (!hasPowerSourceConnection(otherItem)) {
                                return { isLive: false, message: "This circuit has no power. Check your breakers." };
                            }
                            return { isLive: true };
                        }
                    }
                    
                    // Check if it's a breaker panel
                    if (otherItem.type === 'breakerpanel') {
                        if (otherItem.mainBreakerOn === false) {
                            return { isLive: false, message: "Main breaker is off" };
                        }
                        
                        // Find which circuit handle this outlet is connected to
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < 8) {
                                // Use unified breaker state checking
                                if (!LiveView.BreakerManager.isBreakerPanelCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                // Verify panel is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // Check if it's a spider box
                    if (otherItem.type === 'spiderbox') {
                        // Find which circuit handle this outlet is connected to
                        const circuitHandle = Object.values(otherItem.handles).find(h => {
                            if (!h.circuitName) return false;
                            if (!h.connectedTo) return false;
                            return h.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === currentOutlet.id || connObj.targetItemId === currentOutlet.id) &&
                                       (connObj.sourceHandleId === h.id || connObj.targetHandleId === h.id);
                            });
                        });
                        
                        if (circuitHandle && circuitHandle.circuitName) {
                            const circuitIndex = parseInt(circuitHandle.id.match(/circuit-(\d+)/)?.[1]) - 1;
                            if (circuitIndex >= 0 && circuitIndex < otherItem.specs.circuits.length) {
                                // Use unified breaker state checking
                                if (!LiveView.BreakerManager.isSpiderBoxCircuitClosed(otherItem, circuitIndex)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                // Verify spider box is connected to a power source
                                if (!hasPowerSourceConnection(otherItem)) {
                                    return { isLive: false, message: "This circuit has no power. Check your breakers." };
                                }
                                return { isLive: true };
                            }
                        }
                    }
                    
                    // If it's another outlet, check if we're tracing backwards through daisy-chain
                    // Current outlet's INPUT should be connected to previous outlet's OUTPUT
                    if (otherItem.type === 'acoutlet') {
                        const currentOutletInput = currentOutlet.handles?.input;
                        const previousOutletOutput = otherItem.handles?.output;
                        
                        // Check if this connection is: previousOutlet.output ‚Üí currentOutlet.input
                        if (currentOutletInput && previousOutletOutput &&
                            (outletConn.sourceHandleId === previousOutletOutput.id || outletConn.targetHandleId === previousOutletOutput.id) &&
                            (outletConn.sourceHandleId === currentOutletInput.id || outletConn.targetHandleId === currentOutletInput.id)) {
                            // This is a daisy-chain connection going backwards - trace through it
                            const result = traceToBreaker(otherItem);
                            if (result) return result;
                        }
                    }
                }
                
                return null;
            };
            
            const result = traceToBreaker(outlet);
            if (result) return result;
            
            return { isLive: false, message: "Circuit not found" };
        }
        
        // Check if turning on a load would trip a breaker
        function wouldLoadTripBreaker(load) {
            if (!LiveView.state.active) return false;
            const currentlyOn = LiveView.state.loadStates[load.id] === true;
            if (currentlyOn) return false; // Already on, can't trip by turning on
            
            // Find the breaker or circuit that protects this load
            const circuitStatus = checkLoadCircuitStatus(load);
            if (!circuitStatus.isLive) return false; // Circuit not live, can't trip
            
            // Temporarily turn on the load to check circuit amperage
            LiveView.state.loadStates[load.id] = true;
            
            let wouldTrip = false;
            let breakerInfo = null;
            
            // Check if load is connected to a breaker panel circuit
            const outlets = allItems.filter(i => i.type === 'acoutlet');
            const connectedOutlet = outlets.find(outlet => {
                if (!outlet.handles?.load) return false;
                return outlet.handles.load.connectedTo.some(conn => {
                    const connObj = connections.find(c => c.id === conn.connectionId);
                    if (!connObj) return false;
                    return (connObj.sourceItemId === load.id || connObj.targetItemId === load.id) &&
                           (connObj.sourceItemId === outlet.id || connObj.targetItemId === outlet.id);
                });
            });
            
            if (connectedOutlet) {
                // Find the breaker panel circuit this outlet is on
                const breakerPanels = allItems.filter(i => i.type === 'breakerpanel');
                for (const panel of breakerPanels) {
                    if (panel.mainBreakerOn === false) continue;
                    for (let i = 0; i < 8; i++) {
                        const handleKey = `circuit${i + 1}`;
                        const circuitHandle = panel.handles[handleKey];
                        if (!circuitHandle || !circuitHandle.circuitName) continue;
                        
                        // Check if outlet is on this circuit
                        const outletOnCircuit = circuitHandle.connectedTo && circuitHandle.connectedTo.some(conn => {
                            const connObj = connections.find(c => c.id === conn.connectionId);
                            if (!connObj) return false;
                            return (connObj.sourceItemId === connectedOutlet.id || connObj.targetItemId === connectedOutlet.id) &&
                                   (connObj.sourceHandleId === circuitHandle.id || connObj.targetHandleId === circuitHandle.id);
                        });
                        
                        if (outletOnCircuit) {
                            // Check if circuit breaker is closed (not tripped)
                            if (LiveView.BreakerManager.isBreakerPanelCircuitClosed(panel, i)) {
                                const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(panel, circuitHandle);
                                const breakerRating = circuitHandle.maxAmps || 0;
                                if (circuitInfo.totalAmps > breakerRating) {
                                    wouldTrip = true;
                                    breakerInfo = { type: 'panel', panel: panel, index: i, handle: circuitHandle, rating: breakerRating, amps: circuitInfo.totalAmps };
                                    break;
                                }
                            }
                        }
                    }
                    if (wouldTrip) break;
                }
                
                // Check spider boxes too
                if (!wouldTrip) {
                    const spiderBoxes = allItems.filter(i => i.type === 'spiderbox');
                    for (const spiderbox of spiderBoxes) {
                        if (!spiderbox.handles) continue;
                        for (let i = 0; i < spiderbox.specs.circuits.length; i++) {
                            const handleKey = `circuit${i + 1}`;
                            const circuitHandle = spiderbox.handles[handleKey];
                            if (!circuitHandle || !circuitHandle.circuitName) continue;
                            
                            // Check if outlet is on this circuit
                            const outletOnCircuit = circuitHandle.connectedTo && circuitHandle.connectedTo.some(conn => {
                                const connObj = connections.find(c => c.id === conn.connectionId);
                                if (!connObj) return false;
                                return (connObj.sourceItemId === connectedOutlet.id || connObj.targetItemId === connectedOutlet.id) &&
                                       (connObj.sourceHandleId === circuitHandle.id || connObj.targetHandleId === circuitHandle.id);
                            });
                            
                            if (outletOnCircuit) {
                                // Check if circuit breaker is closed (not tripped)
                                if (LiveView.BreakerManager.isSpiderBoxCircuitClosed(spiderbox, i)) {
                                    const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(spiderbox, circuitHandle);
                                    const breakerRating = circuitHandle.maxAmps || 0;
                                    if (circuitInfo.totalAmps > breakerRating) {
                                        wouldTrip = true;
                                        breakerInfo = { type: 'spiderbox', spiderbox: spiderbox, index: i, handle: circuitHandle, rating: breakerRating, amps: circuitInfo.totalAmps };
                                        break;
                                    }
                                }
                            }
                        }
                        if (wouldTrip) break;
                    }
                }
            }
            
            // Check standalone AC breakers
            if (!wouldTrip) {
                const acBreakers = allItems.filter(i => i.type === 'acbreaker');
                for (const breaker of acBreakers) {
                    if (!LiveView.BreakerManager.isBreakerClosed(breaker)) continue;
                    
                    // Check if load is downstream of this breaker
                    const circuitInfo = LiveView.PowerFlow.calculateACCircuit(breaker);
                    const loadOnCircuit = circuitInfo.loads.some(l => l.id === load.id);
                    
                    if (loadOnCircuit) {
                        const breakerRating = breaker.specs.rating || 0;
                        if (circuitInfo.totalAmps > breakerRating) {
                            wouldTrip = true;
                            breakerInfo = { type: 'breaker', breaker: breaker, rating: breakerRating, amps: circuitInfo.totalAmps };
                            break;
                        }
                    }
                }
            }
            
            // Restore original state
            LiveView.state.loadStates[load.id] = false;
            
            return wouldTrip ? breakerInfo : false;
        }
        
        // Toggle load on/off
        function toggleProcessor(processor) {
            // Toggle processor running state
            processor.isRunning = !processor.isRunning;
            if (!processor.isRunning) {
                // Reset batch state when stopping
                processor.batchTimeElapsed = 0;
                processor.isInBatch = false;
                processor.awaitingBatchInputs = false;
            }
            render();
        }
        
        function toggleLoad(load) {
            if (!LiveView.state.active) return;
            
            // Check if load's circuit is live
            const circuitStatus = checkLoadCircuitStatus(load);
            
            // If trying to turn ON but circuit is not live, show warning and don't toggle
            const currentlyOn = LiveView.state.loadStates[load.id] === true;
            if (!circuitStatus.isLive && !currentlyOn) {
                showHint("‚ö†Ô∏è Circuit Not Live", circuitStatus.message);
                return;
            }
            
            // If circuit is not live and load is on, it will be automatically turned off
            // by Display.update(), but we can still toggle it off manually
            if (!circuitStatus.isLive && currentlyOn) {
                // Circuit lost power - turn off the load
                LiveView.state.loadStates[load.id] = false;
                render();
                return;
            }
            
            // If trying to turn ON, check if it would trip a breaker
            if (!currentlyOn) {
                const breakerCheck = wouldLoadTripBreaker(load);
                if (breakerCheck) {
                    // Turn on the load briefly (200ms) to show visual feedback
                    LiveView.state.loadStates[load.id] = true;
                    // Recalculate power flow so wires glow during the brief on period
                    LiveView.PowerFlow.calculate();
                    render(); // Immediate visual feedback
                    
                    // After 200ms, trigger breaker check (load is still on, so breaker will trip)
                    setTimeout(() => {
                        // Trigger breaker check which will trip the breaker and turn off all loads
                        LiveView.BreakerManager.checkTripping();
                        // Power flow is already recalculated in checkTripping if breaker trips
                        render();
                        LiveView.Animation.scheduleUpdate();
                    }, 200);
                    return;
                }
            }
            
            // Circuit is live and won't trip - toggle normally
            LiveView.state.loadStates[load.id] = !LiveView.state.loadStates[load.id];
            LiveView.Animation.scheduleUpdate();
        }
        
        // Toggle load in simulate mode
        function toggleLoadInSimulate(load) {
            if (currentMode !== 'simulate') return;
            
            // Initialize LiveView state if needed
            if (!LiveView.state.loadStates) {
                LiveView.state.loadStates = {};
            }
            
            // Determine current state - check both simState and LiveView state
            const currentlyOn = (load.simState && load.simState.isRunning) || 
                               LiveView.state.loadStates[load.id] === true;
            const newState = !currentlyOn;
            
            // Toggle state changed
            
            // Update both states to keep them in sync
            LiveView.state.loadStates[load.id] = newState;
            
            // Initialize simState if needed (match structure from simulation code)
            if (!load.simState) {
                load.simState = {
                    isRunning: false,
                    isProcessing: false,
                    recipeTimeElapsed: 0,
                    currentPowerWatts: 0,
                    lastConsumptionKwh: 0
                };
            }
            load.simState.isRunning = newState;
            
            // If turning off, stop any active recipe processing
            if (!newState) {
                load.isProcessing = false;
                load.recipeTimeElapsed = 0;
            }
            
            // Recalculate power flow to update wire glow
            SimulateMode.calculatePowerFlow();
            
            // Re-render to show updated state
            render();
        }
        
        function renderSpiderBox(g, d) {
            // Main housing - yellow/black industrial look
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "#2a2a18")
                .attr("stroke", "#f0ad4e")
                .attr("stroke-width", 4);
            
            // Yellow warning stripes at top
            for (let i = 0; i < 5; i++) {
                g.append("rect")
                    .attr("x", 10 + i * 35)
                    .attr("y", 3)
                    .attr("width", 18)
                    .attr("height", 8)
                    .attr("fill", i % 2 === 0 ? "#f0ad4e" : "#222");
            }
            
            // Title bar
            g.append("rect")
                .attr("x", 5)
                .attr("y", 14)
                .attr("width", d.width - 10)
                .attr("height", 18)
                .attr("rx", 3)
                .attr("fill", "#f0ad4e");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 27)
                .attr("text-anchor", "middle")
                .attr("font-size", "11px")
                .attr("fill", "#000")
                .attr("font-weight", "bold")
                .text("‚ö° CEP SPIDER BOX");
            
            // Main breaker on left side (50A 240V) - FUNCTIONAL
            const mainOn = d.mainBreakerOn !== false;
            const mainBreakerGroup = g.append("g")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        // Turn off all loads connected to this spider box's circuits
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                // If this load is on a circuit from this spider box, turn it off
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    // Refresh sidepanel if this item is selected
                    if (selectedItem && selectedItem.id === d.id) {
                        openInspector(selectedItem);
                    }
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    } else {
                        render();
                    }
                });
            
            // Main breaker body (positioned where input section was)
            mainBreakerGroup.append("rect")
                .attr("x", 8)
                .attr("y", d.height / 2 - 18)
                .attr("width", 50)
                .attr("height", 36)
                .attr("rx", 4)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555")
                .attr("stroke-width", 2);
            
            // Main breaker toggle indicator
            mainBreakerGroup.append("rect")
                .attr("x", mainOn ? 11 : 19)
                .attr("y", d.height / 2 - 15)
                .attr("width", 10)
                .attr("height", 14)
                .attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            mainBreakerGroup.append("text")
                .attr("x", 33)
                .attr("y", d.height / 2 - 4)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", mainOn ? "#fff" : "#666")
                .attr("font-weight", "bold")
                .text("MAIN");
            mainBreakerGroup.append("text")
                .attr("x", 33)
                .attr("y", d.height / 2 + 8)
                .attr("text-anchor", "middle")
                .attr("font-size", "7px")
                .attr("fill", mainOn ? "#f88" : "#555")
                .text("50A");
            
            // Circuit breaker section - starts at top
            g.append("rect")
                .attr("x", 70)
                .attr("y", 40)
                .attr("width", d.width - 80)
                .attr("height", d.height - 50)
                .attr("rx", 5)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#333")
                .attr("stroke-width", 1);
            
            // Circuit breaker indicators with improved visual feedback
            d.specs.circuits.forEach((circuit, i) => {
                const yPos = 50 + (i * 18); // Start at top, aligned with handles
                const handle = d.handles[`circuit${i + 1}`];
                const circuitOn = handle.isClosed !== false;
                const isClosed = circuitOn && mainOn; // Respect main breaker
                const is240 = circuit.voltage === 240;
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, handle);
                    circuitAmps = circuitInfo.totalAmps;
                    circuitWatts = circuitInfo.totalWatts;
                }
                
                // Breaker toggle group
                const breakerGroup = g.append("g")
                    .attr("class", "spider-breaker")
                    .style("cursor", "pointer")
                    .on("click", (event) => {
                        event.stopPropagation();
                        const wasOn = handle.isClosed !== false;
                        handle.isClosed = !handle.isClosed;
                        const isNowOn = handle.isClosed !== false;
                        
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${d.id}-circuit-${i + 1}`;
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: handle.isClosed,
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                            
                            // If breaker was turned off, immediately turn off all loads on this circuit
                            if (wasOn && !isNowOn) {
                                // Turn off all loads connected to this circuit
                                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                    const load = allItems.find(i => i.id === loadId);
                                    if (load && load.type === 'acload') {
                                        const circuitStatus = checkLoadCircuitStatus(load);
                                        if (!circuitStatus.isLive) {
                                            LiveView.state.loadStates[loadId] = false;
                                        }
                                    }
                                });
                            }
                        }
                        // Refresh sidepanel if this item is selected
                        if (selectedItem && selectedItem.id === d.id) {
                            openInspector(selectedItem);
                        }
                        if (LiveView.state.active) {
                            LiveView.Animation.scheduleUpdate();
                        } else {
                            render();
                        }
                    });
                
                // Breaker body - improved colors: yellow when ON, red when OFF/TRIPPED
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 75)
                    .attr("y", yPos - 6)
                    .attr("width", d.width - 90)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("ry", 3)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = isClosed ? 78 : 90;
                const toggleSize = 10;
                const toggleY = yPos - 4;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "spider-toggle-track")
                    .attr("x", 75)
                    .attr("y", toggleY)
                    .attr("width", 20)
                    .attr("height", 12)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "spider-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 1)
                    .attr("width", toggleSize)
                    .attr("height", 10)
                    .attr("rx", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 1.5);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "spider-position-indicator")
                    .attr("x", 85)
                    .attr("y", toggleY + 8)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "7px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", 100)
                    .attr("y", yPos + 3)
                    .attr("text-anchor", "start")
                    .attr("font-size", "9px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view) - larger and more visible
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 25)
                        .attr("y", yPos + 4)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff6666" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width / 2)
                            .attr("y", yPos + 1)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "8px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 25)
                        .attr("y", yPos + 4)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", isClosed ? (is240 ? "#ff6666" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.voltage}V ${circuit.amps}A`);
                }
            });
            
            renderHandles(g, d);
        }
        
        function renderBreakerPanel(g, d) {
            // Main panel housing - gray metal enclosure
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 6)
                .attr("ry", 6)
                .attr("fill", "#3a3a3a")
                .attr("stroke", "#666")
                .attr("stroke-width", 3);
            
            // Panel door with embossed look
            g.append("rect")
                .attr("x", 8)
                .attr("y", 22)
                .attr("width", d.width - 16)
                .attr("height", d.height - 32)
                .attr("rx", 3)
                .attr("fill", "#1a1a1a")
                .attr("stroke", "#555")
                .attr("stroke-width", 1);
            
            // Title plate
            g.append("rect")
                .attr("x", d.width / 2 - 50)
                .attr("y", 4)
                .attr("width", 100)
                .attr("height", 14)
                .attr("rx", 2)
                .attr("fill", "#444");
            
            g.append("text")
                .attr("x", d.width / 2)
                .attr("y", 14)
                .attr("text-anchor", "middle")
                .attr("font-size", "9px")
                .attr("fill", "#ccc")
                .attr("font-weight", "bold")
                .text("‚ö° 100A MAIN PANEL");
            
            // Main breaker at top center (double-pole) - FUNCTIONAL
            const mainOn = d.mainBreakerOn !== false;
            const mainBreakerGroup = g.append("g")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.mainBreakerOn = !d.mainBreakerOn;
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (!d.mainBreakerOn && LiveView.state.active) {
                        // Turn off all loads connected to this panel's circuits
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                // If this load is on a circuit from this panel, turn it off
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    } else {
                        render();
                    }
                });
            
            mainBreakerGroup.append("rect")
                .attr("x", d.width / 2 - 25)
                .attr("y", 28)
                .attr("width", 50)
                .attr("height", 22)
                .attr("rx", 3)
                .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                .attr("stroke", mainOn ? "#d9534f" : "#555")
                .attr("stroke-width", 2);
            
            // Main breaker toggle indicator
            mainBreakerGroup.append("rect")
                .attr("x", mainOn ? d.width / 2 - 22 : d.width / 2 - 14)
                .attr("y", 31)
                .attr("width", 10)
                .attr("height", 16)
                .attr("rx", 2)
                .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
            
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 38)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("fill", mainOn ? "#fff" : "#666")
                .attr("font-weight", "bold")
                .text("MAIN");
            mainBreakerGroup.append("text")
                .attr("x", d.width / 2 + 8)
                .attr("y", 47)
                .attr("text-anchor", "middle")
                .attr("font-size", "7px")
                .attr("fill", mainOn ? "#f88" : "#555")
                .text("100A");
            
            // Center bus bar visual - dims when main is off
            g.append("rect")
                .attr("x", d.width / 2 - 3)
                .attr("y", 52)
                .attr("width", 6)
                .attr("height", d.height - 65)
                .attr("fill", mainOn ? "#b87333" : "#4a3a2a"); // Copper color or dimmed
            
            // Left side breakers (circuits 1-4)
            for (let i = 0; i < 4; i++) {
                const yPos = 65 + (i * 42); // Increased spacing for larger size
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn; // Respect main breaker
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${d.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    // Turn off all loads connected to this circuit
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            // Immediately recalculate power flow and re-render
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            // Refresh inspector if breaker panel or load is currently selected
                            if (selectedItem) {
                                if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel') {
                                    openInspector(selectedItem);
                                }
                            }
                        }
                    });
                
                // Breaker body - improved colors: yellow when ON, red when OFF/TRIPPED
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", 15)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? "#ffd700" : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? 18 : 32;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", 15)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", 16)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? "#ffd700" : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", 12)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", 26)
                    .attr("y", toggleY + 11)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", 42)
                    .attr("y", yPos + 12)
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : "#ffd700") : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view)
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "7px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : "#ffd700")
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", 45)
                            .attr("y", yPos + 9)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", 57)
                        .attr("y", yPos + 18)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", isClosed ? "#ffd700" : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
            }
            
            // Right side breakers (circuits 5-8)
            for (let i = 4; i < 8; i++) {
                const yPos = 65 + ((i - 4) * 42); // Increased spacing for larger size
                const circuit = d.specs.circuits[i];
                const breakerOn = d.breakerStates && d.breakerStates[i] !== false;
                const isClosed = breakerOn && mainOn; // Respect main breaker
                
                // Check if tripped in live view
                const breakerId = `${d.id}-circuit-${i + 1}`;
                const isTripped = LiveView.state.active && LiveView.state.breakerStates[breakerId]?.wasTripped;
                
                // Calculate circuit amperage in live view
                let circuitAmps = 0;
                let circuitWatts = 0;
                if (liveViewActive && isClosed) {
                    const circuitHandle = d.handles[`circuit${i + 1}`];
                    if (circuitHandle) {
                        const circuitInfo = LiveView.PowerFlow.calculateBreakerPanelCircuit(d, circuitHandle);
                        circuitAmps = circuitInfo.totalAmps;
                        circuitWatts = circuitInfo.totalWatts;
                    }
                }
                const is240 = circuit.voltage === 240;
                
                const breakerGroup = g.append("g")
                    .style("cursor", mainOn ? "pointer" : "not-allowed")
                    .style("opacity", mainOn ? 1 : 0.5)
                    .on("click", (event) => {
                        event.stopPropagation();
                        if (mainOn) {
                            const wasOn = d.breakerStates[i] !== false;
                            d.breakerStates[i] = !d.breakerStates[i];
                            const isNowOn = d.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${d.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: d.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    // Turn off all loads connected to this circuit
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                            }
                            // Immediately recalculate power flow and re-render
                            if (LiveView.state.active) {
                                LiveView.PowerFlow.calculate();
                                render();
                                LiveView.Animation.scheduleUpdate();
                            } else {
                                render();
                            }
                            
                            // Refresh inspector if breaker panel or load is currently selected
                            if (selectedItem) {
                                if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel') {
                                    openInspector(selectedItem);
                                }
                            }
                        }
                    });
                
                // Breaker body (240V breakers are taller - double pole) - improved colors
                let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) {
                    fillColor = "#4a2020";
                    strokeColor = "#ff4444";
                }
                
                breakerGroup.append("rect")
                    .attr("x", d.width - 90)
                    .attr("y", yPos)
                    .attr("width", 75)
                    .attr("height", is240 ? 38 : 28)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", fillColor)
                    .attr("stroke", strokeColor)
                    .attr("stroke-width", isTripped ? 3 : 2);
                
                // Toggle switch - much bigger and more visible with clear position indicator
                let toggleColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                if (isTripped) toggleColor = "#ff4444";
                
                const toggleX = breakerOn ? d.width - 87 : d.width - 73;
                const toggleSize = 12;
                const toggleY = yPos + 6;
                const toggleHeight = is240 ? 26 : 16;
                
                // Switch track background - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-track")
                    .attr("x", d.width - 90)
                    .attr("y", toggleY)
                    .attr("width", 22)
                    .attr("height", toggleHeight)
                    .attr("rx", 3)
                    .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                    .attr("stroke", isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#666")
                    .attr("stroke-width", 2);
                
                // Toggle switch slider - larger
                breakerGroup.append("rect")
                    .attr("class", "breaker-toggle-slider")
                    .attr("x", toggleX)
                    .attr("y", toggleY + 2)
                    .attr("width", toggleSize)
                    .attr("height", toggleHeight - 4)
                    .attr("rx", 2)
                    .attr("ry", 2)
                    .attr("fill", toggleColor)
                    .attr("stroke", isClosed ? "#fff700" : "#ff6666")
                    .attr("stroke-width", 2);
                
                // Position indicator text (ON/OFF) - more visible
                breakerGroup.append("text")
                    .attr("class", "breaker-position-indicator")
                    .attr("x", d.width - 79)
                    .attr("y", toggleY + (is240 ? 16 : 10))
                    .attr("text-anchor", "middle")
                    .attr("font-size", "8px")
                    .attr("fill", isClosed ? "#fff" : "#888")
                    .attr("font-weight", "bold")
                    .text(isClosed ? "ON" : "OFF");
                
                // Circuit name label - larger font
                breakerGroup.append("text")
                    .attr("x", d.width - 65)
                    .attr("y", yPos + (is240 ? 18 : 12))
                    .attr("text-anchor", "start")
                    .attr("font-size", "10px")
                    .attr("fill", isClosed ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#ffd700")) : "#888")
                    .attr("font-weight", "bold")
                    .text(circuit.name || `C${i + 1}`);
                
                // Rating label or current amps (in live view)
                if (liveViewActive && isClosed && circuitAmps > 0) {
                    const ampsText = `${circuitAmps.toFixed(1)}A / ${circuit.amps}A`;
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + (is240 ? 24 : 20))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", circuitAmps > circuit.amps ? "#ff4444" : 
                               circuitAmps > circuit.amps * 0.8 ? "#ffaa00" : (is240 ? "#ff6666" : "#ffd700"))
                        .attr("font-weight", "bold")
                        .text(ampsText);
                    
                    // Show TRIPPED text if tripped
                    if (isTripped) {
                        breakerGroup.append("text")
                            .attr("x", d.width - 45)
                            .attr("y", yPos + (is240 ? 14 : 9))
                            .attr("text-anchor", "middle")
                            .attr("font-size", "7px")
                            .attr("fill", "#ff4444")
                            .attr("font-weight", "bold")
                            .text("TRIPPED");
                    }
                } else {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + (is240 ? 28 : 22))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .attr("fill", isClosed ? (is240 ? "#ff6666" : "#ffd700") : "#888")
                        .attr("font-weight", "bold")
                        .text(`${circuit.amps}A`);
                }
                
                if (is240) {
                    breakerGroup.append("text")
                        .attr("x", d.width - 20)
                        .attr("y", yPos + 8)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "6px")
                        .attr("fill", "#888")
                        .text("240V");
                }
            }
            
            renderHandles(g, d);
        }
        
        function renderBreaker(g, d) {
            // Main rect
            g.append("rect")
                .attr("class", "item-rect")
                .attr("width", d.width)
                .attr("height", d.height)
                .attr("rx", 4)
                .attr("ry", 4);
            
            // Breaker switch clickable group
            const switchGroup = g.append("g")
                .attr("class", "breaker-switch-group")
                .style("cursor", "pointer")
                .on("click", (event) => {
                    event.stopPropagation();
                    d.isClosed = !d.isClosed;
                    render();
                    validateSystem();
                });
            
            // Breaker switch visual (toggle indicator)
            switchGroup.append("rect")
                .attr("class", "breaker-switch")
                .attr("x", d.width * 0.25)
                .attr("y", d.height * 0.3)
                .attr("width", d.width * 0.5)
                .attr("height", d.height * 0.15)
                .attr("rx", 2)
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
            
            // Switch lever
            switchGroup.append("rect")
                .attr("class", "breaker-lever")
                .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25)
                .attr("y", d.height * 0.28)
                .attr("width", d.width * 0.25)
                .attr("height", d.height * 0.19)
                .attr("rx", 2)
                .attr("fill", "#ddd")
                .attr("stroke", "#999")
                .attr("stroke-width", 1);
            
            // Label
            g.append("text")
                .attr("class", "breaker-label")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.65)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(d.specs.rating + "A");
            
            g.append("text")
                .attr("class", "breaker-status")
                .attr("x", d.width / 2)
                .attr("y", d.height * 0.82)
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "middle")
                .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
                .attr("font-size", "9px")
                .text(d.isClosed ? "CLOSED" : "OPEN");
            
            // Port labels
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", -18)
                .attr("text-anchor", "middle")
                .text("LINE");
            
            g.append("text")
                .attr("class", "port-label")
                .attr("x", d.width / 2)
                .attr("y", d.height + 22)
                .attr("text-anchor", "middle")
                .text("LOAD");
            
            // Handles
            renderHandles(g, d);
        }
        
        function renderCombiner(g, d) { _renderCombinerBase(g, d, false); }
        
        function renderSolarCombiner(g, d) { _renderCombinerBase(g, d, true); }
        
        function renderHandles(g, d) {
            Object.values(d.handles).forEach(handle => {
                // Determine handle color based on resource type
                let handleColor = '#70a0d0'; // Default blue for inputs
                let handleStroke = '#4a7aa0';
                let handleRadius = HANDLE_RADIUS;
                
                if (handle.resourceType) {
                    // Resource port - use resource type color
                    handleColor = getResourceTypeColor(handle.resourceType);
                    handleStroke = handleColor;
                    // Slightly larger for resource ports
                    handleRadius = 13;
                } else if (handle.polarity === 'load' || (handle.polarity === 'ac' && d.type === 'acload')) {
                    // Power input for loads - use yellow/orange
                    handleColor = '#f0ad4e';
                    handleStroke = '#ffd700';
                    handleRadius = 15;
                } else if (handle.polarity === 'positive' || handle.polarity === 'pv-positive') {
                    handleColor = '#d9534f';
                    handleStroke = '#a0403a';
                } else if (handle.polarity === 'negative' || handle.polarity === 'pv-negative') {
                    handleColor = '#333';
                    handleStroke = '#222';
                } else if (handle.polarity === 'ac') {
                    handleColor = '#f0ad4e';
                    handleStroke = '#ffd700';
                } else if (handle.polarity === 'output') {
                    handleColor = '#70c070';
                    handleStroke = '#5a9a5a';
                }
                
                // Draw handle circle
                const handleCircle = g.append("circle")
                    .attr("class", `handle ${handle.polarity} ${handle.resourceType ? 'resource-port' : ''}`)
                    .attr("cx", handle.x)
                    .attr("cy", handle.y)
                    .attr("r", handleRadius)
                    .attr("data-handle-id", handle.id)
                    .attr("fill", handleColor)
                    .attr("stroke", handleStroke)
                    .attr("stroke-width", 2)
                    .style("touch-action", "none") // Prevent default touch behaviors
                    .style("-webkit-touch-callout", "none") // Prevent iOS callout
                    .call(d3.drag()
                        .touchable(true) // Enable touch support in d3.drag
                        .on("start", (event) => {
                            // Prevent default touch behavior
                            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                                event.sourceEvent.preventDefault();
                            }
                            handleDragStart(event, d, handle);
                        })
                        .on("drag", (event) => {
                            // Prevent default touch behavior during drag
                            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                                event.sourceEvent.preventDefault();
                            }
                            handleDragMove(event);
                        })
                        .on("end", (event) => {
                            // Prevent default touch behavior
                            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                                event.sourceEvent.preventDefault();
                            }
                            handleDragEnd(event);
                        })
                    );
                
                // Add +/- symbol centered on handle (for DC polarities)
                const normalizedPolarity = handle.polarity === 'pv-positive' ? 'positive' : 
                                          handle.polarity === 'pv-negative' ? 'negative' : 
                                          handle.polarity;
                if (normalizedPolarity === 'positive' || normalizedPolarity === 'negative') {
                    const symbol = normalizedPolarity === 'positive' ? '+' : '‚àí';
                    g.append("text")
                        .attr("class", "handle-symbol")
                        .attr("x", handle.x)
                        .attr("y", handle.y)
                        .attr("dominant-baseline", "central")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#fff")
                        .attr("font-weight", "bold")
                        .attr("font-size", "12px")
                        .attr("pointer-events", "none")
                        .text(symbol);
                } else if (handle.polarity === 'ac') {
                    // AC symbol
                    g.append("text")
                        .attr("class", "handle-symbol")
                        .attr("x", handle.x)
                        .attr("y", handle.y)
                        .attr("dominant-baseline", "central")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#fff")
                        .attr("font-weight", "bold")
                        .attr("font-size", "9px")
                        .attr("pointer-events", "none")
                        .text("~");
                }
            });
        }
        
        function updateItemContent(g, d) {
            // Update labels based on current specs
            if (d.type === 'panel') {
                g.select(".wmp-label").text(d.specs.wmp + "W");
                g.select(".voc-label").text(d.specs.voc.toFixed(1) + "V");
            } else if (d.type === 'battery') {
                g.select(".voltage-label").text(d.specs.voltage.toFixed(1) + "V");
                g.select(".ah-label").text(d.specs.ah + "Ah");
                
                // Update battery display - show live view or simulation data
                const showCharge = liveViewActive || currentMode === 'simulate';
                if (showCharge) {
                    const controllers = allItems.filter(i => i.type === 'controller');
                    let batteryKwh = d.specs.kWh || 0;
                    let batteryPercent = 50;
                    let currentCharge = 0;
                    
                    controllers.forEach(controller => {
                        if (controller.handles?.batteryPositive) {
                            controller.handles.batteryPositive.connectedTo.forEach(conn => {
                                const batt = allItems.find(i => i.id === conn.itemId);
                                if (batt && batt.id === d.id) {
                                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                                    batteryKwh = batterySpecs.kWh || batteryKwh;
                                    
                                    // Get current charge from simulation stats if in simulate mode
                                    if (currentMode === 'simulate' && simStats.maxBatteryCapacity > 0) {
                                        currentCharge = simStats.batteryCharge;
                                        batteryPercent = (currentCharge / simStats.maxBatteryCapacity) * 100;
                                    }
                                }
                            });
                        }
                    });
                    
                    // Update capacity bar fill
                    const capacityBarFill = g.select(".capacity-bar-fill");
                    if (!capacityBarFill.empty()) {
                        const fillRatio = batteryKwh > 0 ? Math.max(0, Math.min(1, currentCharge / batteryKwh)) : 0;
                        const fillHeight = fillRatio * d.height;
                        
                        capacityBarFill
                            .attr("y", d.height - fillHeight)
                            .attr("height", fillHeight)
                            .classed("low", batteryPercent < 20)
                            .classed("medium", batteryPercent >= 20 && batteryPercent < 50)
                            .classed("high", batteryPercent >= 50);
                    }
                    
                    const color = batteryPercent >= 50 ? "#5cb85c" : batteryPercent >= 20 ? "#f0ad4e" : "#d9534f";
                    g.select(".battery-specs")
                        .text(`${currentCharge > 0 ? currentCharge.toFixed(1) : batteryKwh.toFixed(1)}kWh (${batteryPercent.toFixed(0)}%)`)
                        .attr("fill", color);
                } else {
                    g.select(".battery-specs").text(d.specs.kWh.toFixed(2) + " kWh");
                    
                    // Hide capacity bar in build mode
                    const capacityBarFill = g.select(".capacity-bar-fill");
                    if (!capacityBarFill.empty()) {
                        capacityBarFill.attr("height", 0);
                    }
                }
            } else if (d.type === 'resourcecontainer') {
                // Update resource container display
                const barMargin = 8;
                const barHeight = d.height - 55;
                const barY = 30;
                
                const fillRatio = d.specs.capacity > 0 ? Math.max(0, Math.min(1, (d.specs.value || 0) / d.specs.capacity)) : 0;
                const fillHeight = fillRatio * barHeight;
                
                // Update capacity bar fill
                const capacityBarFill = g.select(".resource-capacity-fill");
                if (!capacityBarFill.empty()) {
                    capacityBarFill
                        .attr("y", barY + barHeight - fillHeight)
                        .attr("height", fillHeight);
                }
                
                // Update value display
                g.select(".resource-value").text((d.specs.value || 0).toFixed(1));
                g.select(".resource-capacity").text(`/ ${d.specs.capacity} ${d.specs.unit}`);
            } else if (d.type === 'acload') {
                // All acload types (simple and recipe-based) - unified handling
                let isOn = false;
                if (currentMode === 'simulate') {
                    isOn = (d.simState && d.simState.isRunning) || (LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true);
                } else {
                    isOn = LiveView.state.active && LiveView.state.loadStates && LiveView.state.loadStates[d.id] === true;
                }
                
                const lastRenderedOnAttr = g.attr('data-is-on');
                const lastRenderedOn = lastRenderedOnAttr === 'true';
                
                // Re-render if state changed
                if (isOn !== lastRenderedOn) {
                    g.attr('data-is-on', isOn ? 'true' : 'false');
                    g.selectAll("*").remove();
                    renderACLoad(g, d);
                } else {
                    // Just update watts display during simulation
                    if (currentMode === 'simulate' && d.simState) {
                        const watts = g.select(".load-watts");
                        if (watts.node()) {
                            const simWatts = d.simState.currentPowerWatts || 0;
                            if (isOn && simWatts > 0) {
                                watts.text(`${Math.round(simWatts)}W`).attr("fill", "#ffd700");
                            } else {
                                watts.text("OFF").attr("fill", "#888");
                            }
                        }
                    }
                }
            } else if (d.type === 'controller') {
                // Check for new simplified structure (controller-base and controller-top-section)
                const hasBase = g.select("rect.controller-base").node() !== null;
                const hasTopSection = g.select("path.controller-top-section").node() !== null || g.select("rect.controller-top-section").node() !== null;
                const hasOldStyle = g.select("path.controller-top-section").node() !== null && !g.select("rect.controller-base").node(); // Old path-based style without base
                
                // Always re-render if structure is missing or old style is present, or if dimensions changed
                // This ensures styling and dimensions are always correct
                if (!hasBase || hasOldStyle) {
                    // Clear existing content and fully re-render
                    g.selectAll("*").remove();
                    renderController(g, d);
                    return; // Exit early since we re-rendered
                }
                
                // If structure exists, update colors if styling has changed
                const topColor = d.specs.topColor || '#c0c0c0';
                const bottomColor = d.specs.bottomColor || '#2a2a2a';
                const dividerHeight = d.specs.dividerHeight !== undefined ? d.specs.dividerHeight : 50;
                const dividerY = (d.height * dividerHeight) / 100;
                
                // Update base (bottom) color
                const baseRect = g.select("rect.controller-base");
                if (baseRect.node()) {
                    const currentBottomColor = baseRect.attr("fill");
                    if (currentBottomColor !== bottomColor && currentBottomColor !== "rgba(100, 0, 0, 0.5)") {
                        if (dividerY >= d.height) {
                            // Entire controller is top color
                            baseRect.attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor);
                        } else {
                            baseRect.attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : bottomColor);
                        }
                    }
                }
                
                // Update or create top section (now uses path for sharp divider edge)
                const topPath = g.select("path.controller-top-section");
                const topRect = g.select("rect.controller-top-section"); // Check for old rect version
                const radius = 8;
                if (dividerY > 0 && dividerY < d.height) {
                    // Need top section - use path for sharp divider edge
                    if (!topPath.node() && !topRect.node()) {
                        // Create it as a path
                        const pathData = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                        g.insert("path", "rect.item-rect")
                            .attr("class", "controller-top-section")
                            .attr("d", pathData)
                            .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                            .attr("stroke", "none")
                            .style("pointer-events", "none");
                    } else if (topPath.node()) {
                        // Update existing path
                        const currentTopColor = topPath.attr("fill");
                        if (currentTopColor !== topColor && currentTopColor !== "rgba(100, 0, 0, 0.5)") {
                            topPath.attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor);
                        }
                        // Update path with new divider position
                        const pathData = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                        topPath.attr("d", pathData);
                    } else if (topRect.node()) {
                        // Convert old rect to path
                        topRect.remove();
                        const pathData = `M ${radius} 0 L ${d.width - radius} 0 Q ${d.width} 0 ${d.width} ${radius} L ${d.width} ${dividerY} L 0 ${dividerY} L 0 ${radius} Q 0 0 ${radius} 0 Z`;
                        g.insert("path", "rect.item-rect")
                            .attr("class", "controller-top-section")
                            .attr("d", pathData)
                            .attr("fill", d.destroyed ? "rgba(100, 0, 0, 0.5)" : topColor)
                            .attr("stroke", "none")
                            .style("pointer-events", "none");
                    }
                } else if (topPath.node() || topRect.node()) {
                    // Don't need top section, remove it
                    if (topPath.node()) topPath.remove();
                    if (topRect.node()) topRect.remove();
                }
                
                // Update background image if URL changed
                const currentImage = g.select("image.controller-background-image");
                const imageUrl = d.specs.imageUrl;
                if (imageUrl && !currentImage.node()) {
                    // Image URL set but no image element - need to re-render to add it
                    g.selectAll("*").remove();
                    renderController(g, d);
                    return;
                } else if (!imageUrl && currentImage.node()) {
                    // Image URL removed but image element exists - remove it
                    currentImage.remove();
                } else if (imageUrl && currentImage.node()) {
                    // Update image URL if changed
                    const currentHref = currentImage.attr("href");
                    if (currentHref !== imageUrl) {
                        currentImage.attr("href", imageUrl);
                    }
                }
                
                // Update controller display - show live view data if active
                const specsTexts = g.selectAll(".controller-specs");
                if (specsTexts.size() >= 2) {
                    if (liveViewActive) {
                        const arraySpecs = calculateConnectedArraySpecs(d);
                        const dcInputWatts = arraySpecs.wmp || 0;
                        const acOutputWatts = Math.min(dcInputWatts, d.specs.maxACOutputW || 0);
                        
                        const specsData = [
                            `DC: ${dcInputWatts}W`,
                            `AC: ${acOutputWatts}W`
                        ];
                        specsTexts.data(specsData)
                            .text(t => t)
                            .attr("fill", "#f0ad4e");
                    } else {
                        // Format text to fit width
                        const specsFontSize = Math.max(9, Math.min(13, d.height * 0.11));
                        const maxWmpText = (d.specs.maxWmp + "W max").length > 12 ? 
                            (d.specs.maxWmp / 1000).toFixed(1) + "kW max" : 
                            d.specs.maxWmp + "W max";
                        const voltageText = d.specs.maxVoc + "V / " + d.specs.maxIsc + "A";
                        const maxTextLength = Math.floor(d.width / (specsFontSize * 0.6));
                        const displayText = voltageText.length > maxTextLength ? 
                            d.specs.maxVoc + "V/" + d.specs.maxIsc + "A" : 
                            voltageText;
                        
                        specsTexts.data([maxWmpText, displayText])
                            .text(t => t)
                            .attr("fill", "#fff");
                    }
                }
            } else if (d.type === 'breaker') {
                // Update breaker switch visual
                g.select(".breaker-switch")
                    .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f");
                // Update lever position
                g.select(".breaker-lever")
                    .attr("x", d.isClosed ? d.width * 0.5 : d.width * 0.25);
                // Update status text
                g.select(".breaker-status")
                    .attr("fill", d.isClosed ? "#5cb85c" : "#d9534f")
                    .text(d.isClosed ? "CLOSED" : "OPEN");
            } else if (d.type === 'acoutlet') {
                // Update outlet display
                const is240V = d.specs.voltage === 240;
                let isLive = false;
                if (liveViewActive && LiveView.state.active) {
                    const circuitStatus = checkOutletCircuitStatus(d);
                    isLive = circuitStatus.isLive;
                }
                
                // Update main rect
                const mainRect = g.select(".item-rect");
                if (mainRect.node()) {
                    const fillColor = isLive ? "#3a3a2a" : "#2a2a2a";
                    const strokeColor = isLive ? (is240V ? "#ff6666" : "#ffd700") : (is240V ? "#d9534f" : "#f0ad4e");
                    const strokeWidth = isLive ? 3 : 2;
                    
                    mainRect
                        .attr("fill", fillColor)
                        .attr("stroke", strokeColor)
                        .attr("stroke-width", strokeWidth);
                }
                
                // Update outlet status text
                const statusText = g.select(".outlet-status");
                if (statusText.node()) {
                    if (liveViewActive && LiveView.state.active) {
                        statusText
                            .text(isLive ? `LIVE ${d.specs.voltage}V` : `${d.specs.voltage}V`)
                            .attr("fill", isLive ? "#ffd700" : "#888")
                            .attr("font-weight", isLive ? "bold" : "normal");
                    } else {
                        statusText.text(`${d.specs.voltage}V`).attr("fill", "#888");
                    }
                } else {
                    // Status text might not exist yet, check if we need to create it
                    if (liveViewActive && LiveView.state.active) {
                        g.select("text").filter(function() {
                            return this.textContent && this.textContent.includes("V");
                        }).each(function() {
                            const text = d3.select(this);
                            if (isLive) {
                                text
                                    .attr("class", "outlet-status")
                                    .text(`LIVE ${d.specs.voltage}V`)
                                    .attr("fill", "#ffd700")
                                    .attr("font-weight", "bold");
                            } else {
                                text
                                    .attr("class", "outlet-status")
                                    .text(`${d.specs.voltage}V`)
                                    .attr("fill", "#888")
                                    .attr("font-weight", "normal");
                            }
                        });
                    }
                }
                
                // Update glow effect - only show when live, remove when not live
                // Find glow rect by checking for rects with blur filter
                const glowRect = g.selectAll("rect").filter(function() {
                    const filter = this.style.filter || "";
                    return filter.includes("blur") && this.getAttribute("fill") === "none";
                });
                
                if (isLive) {
                    // Add or update glow effect when live
                    if (glowRect.empty()) {
                        const glowColor = is240V ? "#ff6666" : "#ffd700";
                        g.append("rect")
                            .attr("class", "outlet-glow")
                            .attr("width", d.width)
                            .attr("height", d.height)
                            .attr("rx", 6)
                            .attr("ry", 6)
                            .attr("fill", "none")
                            .attr("stroke", glowColor)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6)
                            .style("filter", "blur(3px)");
                    } else {
                        const glowColor = is240V ? "#ff6666" : "#ffd700";
                        glowRect
                            .attr("stroke", glowColor)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6);
                    }
                } else {
                    // Remove glow effect when not live
                    glowRect.remove();
                }
            } else if (d.type === 'breakerpanel') {
                // Update breaker panel circuit switch visuals
                const mainOn = d.mainBreakerOn !== false;
                if (!d.breakerStates) d.breakerStates = Array(8).fill(true);
                
                // Update left side breakers (circuits 1-4)
                for (let i = 0; i < 4; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle || !circuitHandle.circuitName) continue;
                    
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    const breakerOn = d.breakerStates[i] !== false;
                    const isClosed = breakerOn && mainOn;
                    
                    const yPos = 65 + (i * 42);
                    const toggleY = yPos + 6;
                    const toggleX = breakerOn ? 18 : 32; // Use breakerOn, not isClosed, to match render logic
                    
                    // Find breaker group by y position (left side breakers are at x=15)
                    const allGroups = g.selectAll("g");
                    let breakerGroup = null;
                    allGroups.each(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectX = parseFloat(rect.attr("x")) || 0;
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            // Left side breakers are at x=15, and y should match
                            if (Math.abs(rectX - 15) < 1 && Math.abs(rectY - yPos) < 1) {
                                breakerGroup = group;
                            }
                        }
                    });
                    
                    if (breakerGroup && breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".breaker-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", isClosed ? (isTripped ? "#ff4444" : "#ffd700") : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".breaker-toggle-slider");
                        if (toggleSlider.node()) {
                            const toggleColor = breakerOn ? (isTripped ? "#ff4444" : "#ffd700") : "#ff4444";
                            const toggleStroke = breakerOn ? (isTripped ? "#ff6666" : "#fff700") : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = isClosed ? "#ffd700" : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".breaker-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(breakerOn ? "ON" : "OFF")
                                .attr("fill", breakerOn ? "#fff" : "#888");
                        }
                    }
                }
                
                // Update right side breakers (circuits 5-8)
                for (let i = 4; i < 8; i++) {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle || !circuitHandle.circuitName) continue;
                    
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    const breakerOn = d.breakerStates[i] !== false;
                    const isClosed = breakerOn && mainOn;
                    const circuit = d.specs.circuits[i];
                    const is240 = circuit && circuit.voltage === 240;
                    
                    const yPos = 65 + ((i - 4) * 42);
                    const toggleY = yPos + 6;
                    const toggleX = breakerOn ? d.width - 87 : d.width - 73; // Match render code exactly
                    
                    // Find breaker group by y position (right side breakers are at x=d.width-90)
                    const allGroups = g.selectAll("g");
                    let breakerGroup = null;
                    allGroups.each(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectX = parseFloat(rect.attr("x")) || 0;
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            // Right side breakers are at x=d.width-90, and y should match
                            if (Math.abs(rectX - (d.width - 90)) < 1 && Math.abs(rectY - yPos) < 1) {
                                breakerGroup = group;
                            }
                        }
                    });
                    
                    if (breakerGroup && breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".breaker-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", isClosed ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", isClosed ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".breaker-toggle-slider");
                        if (toggleSlider.node()) {
                            const toggleColor = breakerOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#ff4444";
                            const toggleStroke = breakerOn ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#fff700")) : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = isClosed ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = isClosed ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".breaker-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(breakerOn ? "ON" : "OFF")
                                .attr("fill", breakerOn ? "#fff" : "#888");
                        }
                    }
                }
            } else if (d.type === 'spiderbox') {
                // Update spider box main breaker and circuit switch visuals
                const mainOn = d.mainBreakerOn !== false;
                
                // Update main breaker visual (now on left side)
                const mainBreakerGroup = g.selectAll("g").filter(function() {
                    const rect = d3.select(this).select("rect").filter(function() {
                        const width = parseFloat(this.getAttribute("width")) || 0;
                        const height = parseFloat(this.getAttribute("height")) || 0;
                        // Main breaker is at x=8, y=d.height/2-18, width=50, height=36
                        return Math.abs(width - 50) < 1 && Math.abs(height - 36) < 1;
                    });
                    if (rect.node()) {
                        const x = parseFloat(rect.attr("x")) || 0;
                        const y = parseFloat(rect.attr("y")) || 0;
                        return Math.abs(x - 8) < 1 && Math.abs(y - (d.height / 2 - 18)) < 1;
                    }
                    return false;
                });
                
                if (mainBreakerGroup.node()) {
                    // Update main breaker body
                    const mainBreakerRect = mainBreakerGroup.select("rect").filter(function() {
                        const width = parseFloat(this.getAttribute("width")) || 0;
                        return Math.abs(width - 50) < 1;
                    });
                    if (mainBreakerRect.node()) {
                        mainBreakerRect
                            .attr("fill", mainOn ? "#8b0000" : "#2a2a2a")
                            .attr("stroke", mainOn ? "#d9534f" : "#555");
                    }
                    
                    // Update main breaker toggle indicator
                    const mainToggle = mainBreakerGroup.selectAll("rect").filter(function() {
                        const width = parseFloat(this.getAttribute("width")) || 0;
                        return Math.abs(width - 10) < 1 && this.getAttribute("fill") !== "none";
                    });
                    if (mainToggle.node()) {
                        const toggleX = mainOn ? 11 : 19;
                        mainToggle
                            .attr("x", toggleX)
                            .attr("fill", mainOn ? "#5cb85c" : "#d9534f");
                    }
                    
                    // Update main breaker text
                    mainBreakerGroup.selectAll("text").each(function() {
                        const text = d3.select(this);
                        const textContent = this.textContent || "";
                        if (textContent.includes("MAIN")) {
                            text.attr("fill", mainOn ? "#fff" : "#666");
                        } else if (textContent.includes("50A")) {
                            text.attr("fill", mainOn ? "#f88" : "#555");
                        }
                    });
                }
                
                // Update circuit breaker switches
                d.specs.circuits.forEach((circuit, i) => {
                    const handleKey = `circuit${i + 1}`;
                    const circuitHandle = d.handles[handleKey];
                    if (!circuitHandle) return;
                    
                    const circuitOn = circuitHandle.isClosed !== false;
                    const isClosed = circuitOn && mainOn; // Respect main breaker
                    const is240 = circuit.voltage === 240;
                    
                    // Check if tripped in live view
                    const breakerId = `${d.id}-circuit-${i + 1}`;
                    const breakerState = LiveView.state.active ? LiveView.state.breakerStates[breakerId] : null;
                    const isTripped = breakerState && breakerState.wasTripped;
                    
                    const yPos = 50 + (i * 18); // Match visual circuit positions
                    const toggleX = circuitOn ? 78 : 90;
                    
                    // Find breaker group by class
                    const breakerGroup = g.selectAll("g.spider-breaker").filter(function() {
                        const group = d3.select(this);
                        const rect = group.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (rect.node()) {
                            const rectY = parseFloat(rect.attr("y")) || 0;
                            return Math.abs(rectY - (yPos - 6)) < 1;
                        }
                        return false;
                    });
                    
                    if (breakerGroup.node()) {
                        // Update toggle track
                        const toggleTrack = breakerGroup.select(".spider-toggle-track");
                        if (toggleTrack.node()) {
                            toggleTrack
                                .attr("fill", circuitOn ? "#4a4a2a" : "#2a2a2a")
                                .attr("stroke", circuitOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#666");
                        }
                        
                        // Update toggle slider position and color
                        const toggleSlider = breakerGroup.select(".spider-toggle-slider");
                        if (toggleSlider.node()) {
                            let toggleColor = circuitOn ? (isTripped ? "#ff4444" : (is240 ? "#ff4444" : "#ffd700")) : "#ff4444";
                            const toggleStroke = circuitOn ? (isTripped ? "#ff6666" : (is240 ? "#ff6666" : "#fff700")) : "#ff6666";
                            
                            toggleSlider
                                .attr("x", toggleX)
                                .attr("fill", toggleColor)
                                .attr("stroke", toggleStroke);
                        }
                        
                        // Update breaker body colors
                        const breakerBody = breakerGroup.select("rect").filter(function() {
                            const cls = this.getAttribute("class") || "";
                            return !cls.includes("toggle");
                        });
                        if (breakerBody.node()) {
                            let fillColor = circuitOn ? "#4a4a2a" : "#2a2a2a";
                            let strokeColor = circuitOn ? (is240 ? "#ff4444" : "#ffd700") : "#ff4444";
                            if (isTripped) {
                                fillColor = "#4a2020";
                                strokeColor = "#ff4444";
                            }
                            breakerBody
                                .attr("fill", fillColor)
                                .attr("stroke", strokeColor)
                                .attr("stroke-width", isTripped ? 3 : 2);
                        }
                        
                        // Update position indicator text (ON/OFF)
                        const positionIndicator = breakerGroup.select(".spider-position-indicator");
                        if (positionIndicator.node()) {
                            positionIndicator
                                .text(circuitOn ? "ON" : "OFF")
                                .attr("fill", circuitOn ? "#fff" : "#888");
                        }
                    }
                });
            }
        }
        
        function renderWires() {
            const wireGroups = wiresGroup.selectAll(".wire-group")
                .data(connections, d => d.id);
            
            wireGroups.exit().remove();
            
            const newWireGroups = wireGroups.enter()
                .append("g")
                .attr("class", "wire-group");
            
            // Create wire path
            newWireGroups.append("path")
                .attr("class", d => `wire ${d.polarity}`)
                .style("stroke", d => getWireStyle(d).color) // Set initial color from getWireStyle
                .on("click", (event, d) => {
                    event.stopPropagation();
                    selectConnection(d);
                })
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    deleteConnection(d.id);
                    closeInspector();
                });
            
            const mergedGroups = wireGroups.merge(newWireGroups);
            
            // Update wire path
            mergedGroups.select(".wire")
                .attr("d", d => generateWirePath(d))
                .classed("selected", d => selectedConnection && selectedConnection.id === d.id)
                .classed("power-flowing", d => {
                    // Add power-flowing class for AC wire animation in simulate mode
                    if (currentMode === 'simulate') {
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Animate if circuit is live AND has power flowing
                        if (powerFlow && powerFlow.isLive && powerFlow.watts > 0) {
                            return d.polarity === 'ac' || d.polarity === 'load' || d.polarity === 'parallel';
                        }
                    }
                    return false;
                })
                .classed("resource-consuming", d => {
                    // Add resource-consuming class for input resource connections
                    if (currentMode === 'simulate') {
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        return resourceFlow && resourceFlow.isFlowing && resourceFlow.direction === 'consuming';
                    }
                    return false;
                })
                .classed("resource-producing", d => {
                    // Add resource-producing class for output resource connections
                    if (currentMode === 'simulate') {
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        return resourceFlow && resourceFlow.isFlowing && resourceFlow.direction === 'producing';
                    }
                    return false;
                })
                // Stroke width is now handled below with the filter attribute
                .style("stroke", d => {
                    // Check for resource flow in simulate mode
                    if (currentMode === 'simulate') {
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        if (resourceFlow && resourceFlow.isFlowing) {
                            // Brighten resource colors when flowing
                            const baseColor = getResourceTypeColor(resourceFlow.resourceType);
                            return baseColor; // Use resource type color
                        }
                    }
                    
                    // Check if in simulate mode with power flow (works even when paused)
                    if (currentMode === 'simulate' && SimulateMode.powerFlow[d.id]) {
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Use power flow data for simulate mode - glow if circuit is live (even if watts is 0)
                        if (powerFlow.isLive) {
                            if (d.polarity === 'ac' || d.polarity === 'load') {
                                const voltage = powerFlow.voltage || 120;
                                return voltage === 240 ? '#ff4444' : '#ffd700';
                            } else if (d.polarity === 'parallel') {
                                return '#66aaff';
                            }
                        }
                        return getWireStyle(d).color;
                    }
                    
                    if (!liveViewActive || !LiveView.state.active) {
                        // In build mode, use getWireStyle which handles load voltage colors
                        return getWireStyle(d).color;
                    }
                    
                    const powerFlow = LiveView.state.powerFlow[d.id];
                    
                    // Handle parallel connections (blue) - Delta Pro to double voltage hub
                    if (d.polarity === 'parallel') {
                        if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                            return '#00a8e8';
                        }
                        return '#00a8e8'; // Blue even when not live
                    }
                    
                    // Handle AC power connections
                    if (d.polarity === 'ac' || d.polarity === 'load') {
                        // Determine voltage from power flow or from load/outlet/breaker specs
                        let voltage = 120;
                        if (powerFlow && powerFlow.voltage) {
                            voltage = powerFlow.voltage;
                        } else {
                            // Check load item voltage
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                            if (loadItem && loadItem.specs?.voltage) {
                                voltage = loadItem.specs.voltage;
                            } else {
                                // Check outlet voltage
                                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                                if (outletItem && outletItem.specs?.voltage) {
                                    voltage = outletItem.specs.voltage;
                                } else {
                                    // For AC connections, check breaker panel circuit handle voltage
                                    const breakerItem = sourceItem?.type === 'breakerpanel' ? sourceItem : (targetItem?.type === 'breakerpanel' ? targetItem : null);
                                    if (breakerItem) {
                                        // Find the circuit handle
                                        const sourceHandle = sourceItem?.handles ? Object.values(sourceItem.handles).find(h => h.id === d.sourceHandleId) : null;
                                        const targetHandle = targetItem?.handles ? Object.values(targetItem.handles).find(h => h.id === d.targetHandleId) : null;
                                        const circuitHandle = sourceHandle || targetHandle;
                                        if (circuitHandle && circuitHandle.voltage) {
                                            voltage = circuitHandle.voltage;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Always use correct color based on voltage (red for 240V, yellow for 120V)
                        // Whether live or not, the color should match the voltage
                        return voltage === 240 ? '#cc0000' : '#ffd700';
                    }
                    
                    // Resource port connections
                    if (d.polarity === 'resource' && d.resourceType) {
                        return getResourceTypeColor(d.resourceType);
                    }
                    
                    // DC power - keep existing behavior
                    if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                        return getWireStyle(d).color;
                    }
                    return getWireStyle(d).color;
                })
                .attr("filter", d => {
                    // Check simulate mode first (works even when paused)
                    if (currentMode === 'simulate') {
                        // Check for resource flow glow
                        const resourceFlow = SimulateMode.resourceFlow && SimulateMode.resourceFlow[d.id];
                        if (resourceFlow && resourceFlow.isFlowing) {
                            // Use green glow for resource connections
                            return "url(#green-glow)";
                        }
                        
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Apply glow filter if circuit is live (even if watts is 0)
                        if (powerFlow && powerFlow.isLive) {
                            if (d.polarity === 'ac' || d.polarity === 'load') {
                                const voltage = powerFlow.voltage || 120;
                                return voltage === 240 ? "url(#red-glow)" : "url(#yellow-glow)";
                            } else if (d.polarity === 'parallel') {
                                return "url(#blue-glow)";
                            }
                        }
                        return null;
                    }
                    
                    if (!liveViewActive) return null;
                    if (!LiveView.state.active) return null;
                    const powerFlow = LiveView.state.powerFlow[d.id];
                    
                    // Only apply glow filter when circuit is actually live
                    if (!powerFlow || (!powerFlow.isLive && powerFlow.watts === 0)) {
                        return null; // No glow when not live
                    }
                    
                    // Apply glow filter based on connection type
                    if (d.polarity === 'parallel') {
                        // Parallel connections glow only when live
                        if (powerFlow.isLive || powerFlow.watts > 0) {
                            return "url(#blue-glow)";
                        }
                        return null;
                    } else if (d.polarity === 'ac' || d.polarity === 'load') {
                        // Determine voltage
                        let voltage = 120;
                        if (powerFlow && powerFlow.voltage) {
                            voltage = powerFlow.voltage;
                        } else if (d.polarity === 'load') {
                            // For load connections, check the load item voltage
                            const sourceItem = allItems.find(i => i.id === d.sourceItemId);
                            const targetItem = allItems.find(i => i.id === d.targetItemId);
                            const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                            if (loadItem && loadItem.specs?.voltage) {
                                voltage = loadItem.specs.voltage;
                            } else {
                                // Check outlet voltage
                                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                                if (outletItem && outletItem.specs?.voltage) {
                                    voltage = outletItem.specs.voltage;
                                }
                            }
                        }
                        
                        // Apply glow only when live
                        if (powerFlow.isLive || powerFlow.watts > 0) {
                            return voltage === 240 ? "url(#red-glow)" : "url(#yellow-glow)";
                        }
                    }
                    return null;
                })
                .attr("stroke-width", d => {
                    // Get base width from wire gauge
                    const baseWidth = getWireStrokeWidth(d);
                    
                    // In simulate mode, make live AC wires slightly thicker for visibility (works even when paused)
                    if (currentMode === 'simulate') {
                        const powerFlow = SimulateMode.powerFlow[d.id];
                        // Make wires thicker if circuit is live (even if watts is 0)
                        if (powerFlow && powerFlow.isLive) {
                            if (d.polarity === 'parallel' || d.polarity === 'ac' || d.polarity === 'load') {
                                return Math.max(baseWidth + 2, baseWidth * 1.3);
                            }
                        }
                    }
                    
                    // In live view, make live AC wires slightly thicker for visibility
                    if (liveViewActive && LiveView.state.active) {
                        const powerFlow = LiveView.state.powerFlow[d.id];
                        if (powerFlow && (powerFlow.isLive || powerFlow.watts > 0)) {
                            if (d.polarity === 'parallel' || d.polarity === 'ac' || d.polarity === 'load') {
                                // Add 2px to base width for live AC wires, but keep proportional
                                return Math.max(baseWidth + 2, baseWidth * 1.3);
                            }
                        }
                    }
                    
                    return baseWidth;
                })
                .attr("opacity", d => {
                    // Always full opacity - no dimming in live mode
                    // Wires without glow will look like build mode
                    return 1;
                });
        }
        
        // Get wire stroke width based on wire gauge
        function getWireStrokeWidth(conn) {
            if (!conn) {
                // Default to 10 AWG width if no connection data
                return WIRE_GAUGE_SPECS['10'].width;
            }
            
            // Use the connection's wire gauge if available
            if (conn.wireGauge && WIRE_GAUGE_SPECS[conn.wireGauge]) {
                return WIRE_GAUGE_SPECS[conn.wireGauge].width;
            }
            
            // If wire gauge not set, calculate it based on current
            const currentAmps = calculateWireCurrent(conn);
            const wireSpec = getWireGaugeForAmps(currentAmps);
            return wireSpec.width;
        }
        
        // Get resource type color
        function getResourceTypeColor(resourceType) {
            const resourceColors = {
                [RESOURCE_TYPES.POWER]: '#ffd700', // Yellow/gold
                [RESOURCE_TYPES.WATER]: '#4a90e2', // Blue
                [RESOURCE_TYPES.BIOMASS]: '#8B4513', // Brown
                [RESOURCE_TYPES.WOODGAS]: '#FFDEAD', // Beige
                [RESOURCE_TYPES.BIOCHAR]: '#404040', // Dark gray
                [RESOURCE_TYPES.PLASTIC]: '#888888', // Gray
                [RESOURCE_TYPES.PLASTIC_FLAKES]: '#aaaaaa', // Light gray
                [RESOURCE_TYPES.WIND_TURBINES]: '#cccccc', // Light gray
                [RESOURCE_TYPES.HEAT]: '#ff6b35' // Orange-red
            };
            return resourceColors[resourceType] || '#6fa06c'; // Default green
        }
        
        // Get wire style based on polarity
        function getWireStyle(conn) {
            const polarity = conn.polarity || 'mixed';
            
            // Check if this is a resource port connection
            if (polarity === 'resource' && conn.resourceType) {
                return {
                    color: getResourceTypeColor(conn.resourceType),
                    width: 3 // Default width for resource connections
                };
            }
            
            // Check if this is an AC appliance connection (load)
            if (polarity === 'load') {
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                const loadItem = sourceItem?.type === 'acload' ? sourceItem : (targetItem?.type === 'acload' ? targetItem : null);
                const outletItem = sourceItem?.type === 'acoutlet' ? sourceItem : (targetItem?.type === 'acoutlet' ? targetItem : null);
                
                // Determine voltage from load first, then outlet
                let voltage = null;
                if (loadItem && loadItem.specs?.voltage) {
                    voltage = loadItem.specs.voltage;
                } else if (outletItem && outletItem.specs?.voltage) {
                    voltage = outletItem.specs.voltage;
                }
                
                if (voltage) {
                    // Color based on voltage
                    if (voltage === 120) {
                        return {
                            color: '#ffd700'  // Yellow for 120V appliance cords
                        };
                    } else if (voltage === 240) {
                        return {
                            color: '#cc0000'  // Darker red for 240V appliance cords
                        };
                    }
                }
            }
            
            const colors = {
                'positive': '#d9534f',      // Red
                'negative': '#333',         // Dark gray/black
                'mixed': '#888',            // Gray
                'ac': '#f0ad4e',           // Orange
                'load': '#222',            // Very dark (fallback)
                'parallel': '#00a8e8',     // Blue
                'smart-battery': '#5cb85c' // Green
            };
            return {
                color: colors[polarity] || colors['mixed']
            };
        }
        
        // Get absolute position of a handle in world coordinates
        function getHandlePosition(item, handle) {
            return {
                x: item.x + handle.x,
                y: item.y + handle.y
            };
        }
        
        // Generate a smooth bezier curve between two handles
        function generateWirePath(conn) {
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            if (!sourceItem || !targetItem) return "";
            
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
            if (!sourceHandle || !targetHandle) return "";
            
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            return generateCurvePath(start.x, start.y, end.x, end.y, sourceHandle.side, targetHandle.side);
        }
        
        // Generate bezier curve path string
        function generateCurvePath(sx, sy, ex, ey, sourceSide, targetSide) {
            sourceSide = sourceSide || 'top';
            targetSide = targetSide || 'top';
            
            // Calculate distance for dynamic curve strength
            const dist = Math.sqrt((ex - sx) ** 2 + (ey - sy) ** 2);
            const curveStrength = Math.min(80, Math.max(30, dist * 0.4));
            
            let sc1x = sx, sc1y = sy, sc2x = ex, sc2y = ey;
            
            // Source control point - extends outward from the handle
            switch (sourceSide) {
                case 'top': sc1y = sy - curveStrength; break;
                case 'bottom': sc1y = sy + curveStrength; break;
                case 'left': sc1x = sx - curveStrength; break;
                case 'right': sc1x = sx + curveStrength; break;
            }
            
            // Target control point - extends outward from the handle
            switch (targetSide) {
                case 'top': sc2y = ey - curveStrength; break;
                case 'bottom': sc2y = ey + curveStrength; break;
                case 'left': sc2x = ex - curveStrength; break;
                case 'right': sc2x = ex + curveStrength; break;
            }
            
            return `M ${sx} ${sy} C ${sc1x} ${sc1y}, ${sc2x} ${sc2y}, ${ex} ${ey}`;
        }
        
        // ============================================
        // DRAG HANDLERS
        // ============================================
        
        
        function dragStarted(event, d) {
            // Get data from element if not provided
            if (!d) {
                d = d3.select(this).datum();
            }
            if (!d) return; // Safety check
            
            // Track drag start position for touch devices
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                const touch = event.sourceEvent.touches[0] || event.sourceEvent.changedTouches[0];
                if (touch) {
                    dragStartPos.x = touch.clientX;
                    dragStartPos.y = touch.clientY;
                }
                // Prevent default touch behavior
                event.sourceEvent.preventDefault();
            } else if (event.sourceEvent) {
                dragStartPos.x = event.sourceEvent.clientX;
                dragStartPos.y = event.sourceEvent.clientY;
            }
            
            isDragging = true;
            
            // Check if Shift is held - duplicate the series string
            const shiftKey = event.sourceEvent ? event.sourceEvent.shiftKey : false;
            
            if (shiftKey && d && (d.type === 'panel' || d.type === 'battery')) {
                // Prevent default drag behavior
                if (event.sourceEvent) event.sourceEvent.stopPropagation();
                duplicateSeriesString(d, event);
                // Don't proceed with normal drag
                d._duplicating = true;
                
                // Highlight all panels in the array with yellow outline
                if (d.type === 'panel') {
                    const parallelStrings = findParallelStrings(d);
                    parallelStrings.forEach(string => {
                        string.forEach(panel => {
                            const panelGroup = itemsGroup.select(`[data-id="${panel.id}"]`);
                            if (panelGroup.node()) {
                                panelGroup.select(".item-rect")
                                    .attr("stroke", "#ffdd57")
                                    .attr("stroke-width", 3)
                                    .classed("array-highlight", true);
                            }
                        });
                    });
                }
                
                return;
            }
            
            if (d) {
                d._duplicating = false;
                if (this) {
                    d3.select(this).raise();
                }
                dragOffset.x = event.x - d.x;
                dragOffset.y = event.y - d.y;
                
                // If dragging a panel and array is selected, store array offsets
                if (d.type === 'panel' && selectedArray && selectedArray.some(p => p.id === d.id)) {
                    d._arrayOffsets = selectedArray.map(p => ({
                        panel: p,
                        offsetX: p.x - d.x,
                        offsetY: p.y - d.y
                    }));
                }
            }
        }
        
        function dragged(event, d) {
            // Get data from element if not provided
            if (!d && this) {
                d = d3.select(this).datum();
            }
            if (!d) return;
            
            // Handle duplication preview
            if (d._duplicating && pendingDuplication) {
                updateDuplicationPreview(event.x, event.y);
                return;
            }
            
            const newX = event.x - dragOffset.x;
            const newY = event.y - dragOffset.y;
            const deltaX = newX - d.x;
            const deltaY = newY - d.y;
            
            d.x = newX;
            d.y = newY;
            if (this) {
                d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
            }
            
            // If dragging a panel in a selected array, move all panels in the array
            if (d.type === 'panel' && d._arrayOffsets) {
                d._arrayOffsets.forEach(({ panel, offsetX, offsetY }) => {
                    if (panel.id !== d.id) {
                        panel.x = d.x + offsetX;
                        panel.y = d.y + offsetY;
                        // Update the visual position
                        const panelGroup = itemsGroup.select(`[data-id="${panel.id}"]`);
                        if (panelGroup.node()) {
                            panelGroup.attr("transform", `translate(${panel.x}, ${panel.y})`);
                        }
                    }
                });
            }
            
            renderWires();
        }
        
        function dragEnded(event, d) {
            // Get data from element if not provided
            if (!d && this) {
                d = d3.select(this).datum();
            }
            if (!d) return; // Safety check
            
            isDragging = false;
            // Prevent default touch behavior
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                event.sourceEvent.preventDefault();
            }
            
            if (d._duplicating && pendingDuplication) {
                const itemType = pendingDuplication.itemType;
                completeDuplication(event.x, event.y);
                // Show simple hint - the full feedback will trigger when circuit is complete
                if (itemType === 'panel') {
                    showHint("üìã String Created!", 
                        `Connect both strings' + terminals to PV+ and - terminals to PV- to complete the parallel circuit.`);
                } else if (itemType === 'battery') {
                    showHint("üìã Battery String Created!", 
                        `Connect both strings' + terminals to BATT+ and - terminals to BATT- to complete the parallel circuit.`);
                }
            }
            
            // Remove array highlighting
            itemsGroup.selectAll(".array-highlight")
                .attr("stroke", null)
                .attr("stroke-width", null)
                .classed("array-highlight", false);
            
            // Clear preview
            clearDuplicationPreview();
            
            if (d) {
                d._duplicating = false;
            }
        }
        
        function showParallelStringFeedback() {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) {
                showHint("üìã String Duplicated!", 
                    `Created a parallel string. Connect both strings' + terminals to PV+ and - terminals to PV- for parallel operation.`);
                return;
            }
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            const maxWattsAtBattery = getMaxWattsForController(controller, batterySpecs.voltage || 12);
            
            // Check if current exceeds controller limit
            if (arraySpecs.imp > controller.specs.maxIsc && areHintsEnabled()) {
                // Yellow warning for current clipping
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #f0ad4e;">‚ö° Current Clipping</h3>
                            <p style="margin: 0 0 8px 0;">
                                Your array's maximum current (<strong>${arraySpecs.imp.toFixed(1)}A</strong>) exceeds the controller's input limit (<strong>${controller.specs.maxIsc}A</strong>).
                            </p>
                            <p style="margin: 0; color: #aaa; font-size: 12px;">
                                This won't damage your controller, but it causes "clipping" - reducing the array's maximum output to the controller's limit. You're leaving some power on the table!
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(240, 173, 78, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                            <div style="font-size: 18px; font-weight: bold; color: #f0ad4e;">${arraySpecs.wmp}W</div>
                            <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.imp.toFixed(1)}A Imp</div>
                            <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                                <div style="font-size: 10px; color: #aaa;">CTRL MAX</div>
                                <div style="font-size: 14px; color: #f0ad4e;">${controller.specs.maxIsc}A</div>
                            </div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
            } else if (areHintsEnabled()) {
                // Positive feedback - show how much more they can add
                const remainingCurrent = controller.specs.maxIsc - arraySpecs.imp;
                const potentialExtraWatts = Math.round(remainingCurrent * (arraySpecs.voc / arraySpecs.panelCount || 37.5));
                
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üìã Nice, ${arraySpecs.wmp}W!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Parallel string added! Connect both strings' + terminals to PV+ and - terminals to PV-.
                            </p>
                            <p style="margin: 0; color: #aaa; font-size: 12px;">
                                Your controller can handle up to <strong style="color: #5cb85c;">${maxWattsAtBattery}W</strong> at your current battery voltage. 
                                ${arraySpecs.wmp < maxWattsAtBattery ? `You have room for ~${Math.round(maxWattsAtBattery - arraySpecs.wmp)}W more!` : 'You\'re at the limit!'}
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                            <div style="font-size: 18px; font-weight: bold; color: #5cb85c;">${arraySpecs.wmp}W</div>
                            <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.config || '-'}</div>
                            <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                                <div style="font-size: 10px; color: #aaa;">MAX @ ${batterySpecs.voltage || 12}V</div>
                                <div style="font-size: 14px; color: #5cb85c;">${maxWattsAtBattery}W</div>
                            </div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
            }
        }
        
        // Store pending duplication info
        let pendingDuplication = null;
        let previewItems = [];
        
        function updateDuplicationPreview(mouseX, mouseY) {
            if (!pendingDuplication) return;
            
            const { stringItems, itemType, startX, startY } = pendingDuplication;
            
            // Calculate string bounds
            const minX = Math.min(...stringItems.map(p => p.x));
            const maxX = Math.max(...stringItems.map(p => p.x + p.width));
            const minY = Math.min(...stringItems.map(p => p.y));
            const maxY = Math.max(...stringItems.map(p => p.y + p.height));
            const stringHeight = maxY - minY;
            
            // Determine vertical offset based on drag direction
            const dragDeltaY = mouseY - startY;
            const offsetX = 0; // Same X position (vertical alignment)
            const offsetY = dragDeltaY > 0 ? stringHeight + 30 : -(stringHeight + 30); // Below if dragging down, above if dragging up
            
            // Clear previous preview
            clearDuplicationPreview();
            
            // Create preview items
            stringItems.forEach((oldItem, index) => {
                const previewX = oldItem.x + offsetX; // Same X position
                const previewY = oldItem.y + offsetY; // Offset vertically
                
                let previewItem;
                if (itemType === 'panel') {
                    previewItem = createPanel(previewX, previewY, oldItem.specs);
                } else if (itemType === 'battery') {
                    previewItem = createBattery(previewX, previewY, oldItem.specs);
                }
                
                if (previewItem) {
                    previewItem._isPreview = true;
                    previewItems.push(previewItem);
                    
                    // Render preview item
                    const previewG = previewGroup.append("g")
                        .attr("class", "item-group preview-item")
                        .attr("data-id", previewItem.id)
                        .attr("transform", `translate(${previewItem.x}, ${previewItem.y})`);
                    
                    if (itemType === 'panel') {
                        renderPanel(previewG, previewItem);
                    } else if (itemType === 'battery') {
                        renderBattery(previewG, previewItem);
                    }
                }
            });
        }
        
        function clearDuplicationPreview() {
            previewGroup.selectAll(".preview-item").remove();
            previewItems = [];
        }
        
        function duplicateSeriesString(startItem, event) {
            // Find all items of the same type in this series string
            const itemType = startItem.type;
            const stringItems = [];
            const visited = new Set();
            
            function traceString(item) {
                if (visited.has(item.id)) return;
                visited.add(item.id);
                stringItems.push(item);
                
                // Check both handles for connected items of the same type
                Object.values(item.handles).forEach(handle => {
                    handle.connectedTo.forEach(conn => {
                        const connectedItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedItem && connectedItem.type === itemType && !visited.has(connectedItem.id)) {
                            traceString(connectedItem);
                        }
                    });
                });
            }
            
            traceString(startItem);
            
            if (stringItems.length === 0) return;
            
            // Sort items by position to maintain order (by X for horizontal strings, then Y)
            stringItems.sort((a, b) => a.x - b.x || a.y - b.y);
            
            // Store for use in drag end
            pendingDuplication = {
                stringItems,
                itemType,
                startX: event.x,
                startY: event.y
            };
            
            // Show preview immediately
            updateDuplicationPreview(event.x, event.y);
        }
        
        function completeDuplication(endX, endY) {
            if (!pendingDuplication) return;
            
            const { stringItems, itemType, startX, startY } = pendingDuplication;
            pendingDuplication = null;
            
            // Clear preview
            clearDuplicationPreview();
            
            // Calculate string bounds
            const minX = Math.min(...stringItems.map(p => p.x));
            const maxX = Math.max(...stringItems.map(p => p.x + p.width));
            const minY = Math.min(...stringItems.map(p => p.y));
            const maxY = Math.max(...stringItems.map(p => p.y + p.height));
            const stringHeight = maxY - minY;
            
            // Determine vertical offset based on drag direction
            const dragDeltaY = endY - startY;
            const offsetX = 0; // Same X position (vertical alignment)
            const offsetY = dragDeltaY > 0 ? stringHeight + 30 : -(stringHeight + 30); // Below if dragging down, above if dragging up
            
            // Create new items
            const newItems = [];
            const itemIdMap = new Map();
            
            stringItems.forEach(oldItem => {
                let newItem;
                if (itemType === 'panel') {
                    newItem = createPanel(
                        oldItem.x + offsetX,
                        oldItem.y + offsetY,
                        oldItem.specs
                    );
                } else if (itemType === 'battery') {
                    newItem = createBattery(
                        oldItem.x + offsetX,
                        oldItem.y + offsetY,
                        oldItem.specs
                    );
                }
                if (newItem) {
                    newItems.push(newItem);
                    itemIdMap.set(oldItem.id, newItem);
                    allItems.push(newItem);
                }
            });
            
            // Recreate connections between new items (series connections)
            const createdConnections = new Set();
            
            stringItems.forEach(oldItem => {
                Object.values(oldItem.handles).forEach(handle => {
                    handle.connectedTo.forEach(conn => {
                        const connectedOldItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedOldItem && connectedOldItem.type === itemType && itemIdMap.has(connectedOldItem.id)) {
                            const newSourceItem = itemIdMap.get(oldItem.id);
                            const newTargetItem = itemIdMap.get(connectedOldItem.id);
                            
                            // Create a unique key for this connection pair
                            const connKey = [newSourceItem.id, newTargetItem.id].sort().join('-');
                            if (createdConnections.has(connKey)) return;
                            createdConnections.add(connKey);
                            
                            // Find matching handles by polarity
                            const sourceHandle = Object.values(newSourceItem.handles).find(h => h.polarity === handle.polarity);
                            const connectedOldHandle = Object.values(connectedOldItem.handles).find(h => h.id === conn.handleId);
                            const targetHandle = Object.values(newTargetItem.handles).find(h => h.polarity === connectedOldHandle.polarity);
                            
                            if (sourceHandle && targetHandle) {
                                createConnection(newSourceItem, sourceHandle, newTargetItem, targetHandle);
                            }
                        }
                    });
                });
            });
            
            // Auto-connect to controller if parent string is connected
            if (itemType === 'panel' && newItems.length > 0) {
                const firstOldItem = stringItems[0];
                const firstNewItem = newItems[0];
                
                // Check if parent string's positive is connected to a controller
                const oldPosHandle = firstOldItem.handles.positive;
                const oldPosConn = oldPosHandle.connectedTo.find(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    return item && item.type === 'controller';
                });
                
                if (oldPosConn) {
                    const controller = allItems.find(i => i.id === oldPosConn.itemId);
                    if (controller) {
                        // Find the PV positive handle that the parent is connected to
                        const controllerPosHandle = Object.values(controller.handles).find(h => 
                            h.id === oldPosConn.handleId && (h.polarity === 'pv-positive' || h.polarity === 'positive')
                        );
                        
                        if (controllerPosHandle) {
                            // Connect new string's positive to same controller PV input
                            createConnection(firstNewItem, firstNewItem.handles.positive, controller, controllerPosHandle);
                        }
                    }
                }
                
                // Check if parent string's negative is connected to a controller
                const lastOldItem = stringItems[stringItems.length - 1];
                const lastNewItem = newItems[newItems.length - 1];
                const oldNegHandle = lastOldItem.handles.negative;
                const oldNegConn = oldNegHandle.connectedTo.find(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    return item && item.type === 'controller';
                });
                
                if (oldNegConn) {
                    const controller = allItems.find(i => i.id === oldNegConn.itemId);
                    if (controller) {
                        // Find the PV negative handle that the parent is connected to
                        const controllerNegHandle = Object.values(controller.handles).find(h => 
                            h.id === oldNegConn.handleId && (h.polarity === 'pv-negative' || h.polarity === 'negative')
                        );
                        
                        if (controllerNegHandle) {
                            // Connect new string's negative to same controller PV input
                            createConnection(lastNewItem, lastNewItem.handles.negative, controller, controllerNegHandle);
                        }
                    }
                }
            }
            
            render();
        }
        
        function handleDragStart(event, item, handle) {
            event.sourceEvent.stopPropagation();
            
            // Store reference to the CURRENT item from allItems (not a stale copy)
            const currentItem = allItems.find(i => i.id === item.id);
            const currentHandle = currentItem ? Object.values(currentItem.handles).find(h => h.id === handle.id) : handle;
            
            draggingHandle = { 
                itemId: item.id,  // Store ID instead of object reference
                handleId: handle.id,
                item: currentItem || item,
                handle: currentHandle || handle
            };
            
            const pos = getHandlePosition(draggingHandle.item, draggingHandle.handle);
            
            tempWire = tempGroup.append("path")
                .attr("class", "wire temp")
                .attr("d", `M ${pos.x} ${pos.y} L ${pos.x} ${pos.y}`);
        }
        
        function handleDragMove(event) {
            if (!draggingHandle || !tempWire) return;
            
            // Prevent default touch behavior during drag
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                event.sourceEvent.preventDefault();
            }
            
            // Get fresh reference to item (in case it moved)
            const item = allItems.find(i => i.id === draggingHandle.itemId) || draggingHandle.item;
            const handle = Object.values(item.handles).find(h => h.id === draggingHandle.handleId) || draggingHandle.handle;
            
            // d3.pointer automatically handles both mouse and touch events
            const [mouseX, mouseY] = d3.pointer(event, zoomGroup.node());
            const start = getHandlePosition(item, handle);
            
            // Determine target side based on mouse position relative to start
            let targetSide = 'top';
            if (mouseY > start.y + 20) targetSide = 'top';      // Mouse is below, so target handle is on top
            else if (mouseY < start.y - 20) targetSide = 'bottom'; // Mouse is above, so target handle is on bottom
            else if (mouseX > start.x) targetSide = 'left';
            else targetSide = 'right';
            
            const path = generateCurvePath(start.x, start.y, mouseX, mouseY, handle.side, targetSide);
            tempWire.attr("d", path);
        }
        
        function handleDragEnd(event) {
            // Prevent default touch behavior
            if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('touch')) {
                event.sourceEvent.preventDefault();
            }
            
            if (tempWire) tempWire.remove();
            tempWire = null;
            
            if (!draggingHandle) return;
            
            // d3.pointer automatically handles both mouse and touch events
            const [x, y] = d3.pointer(event, zoomGroup.node());
            
            // Get fresh reference to source item
            const sourceItem = allItems.find(i => i.id === draggingHandle.itemId) || draggingHandle.item;
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === draggingHandle.handleId) || draggingHandle.handle;
            
            // Find target handle - closest one within range
            let targetItem = null;
            let targetHandle = null;
            let closestDist = HANDLE_RADIUS * 3;
            
            for (const item of allItems) {
                if (item.id === sourceItem.id) continue;
                
                for (const handle of Object.values(item.handles)) {
                    const pos = getHandlePosition(item, handle);
                    const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                    
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetItem = item;
                        targetHandle = handle;
                    }
                }
            }
            
            if (targetHandle) {
                createConnection(sourceItem, sourceHandle, targetItem, targetHandle);
            } else {
                // No target found - create a new component if dragging from appropriate handle
                
                // Smart battery port drag - create new smart battery expansion
                if (sourceHandle.polarity === 'smart-battery') {
                    // Check if we're dragging from a controller's smart battery port
                    if (sourceItem.type === 'controller' && sourceItem.specs.smartBatteryKWh) {
                        const newX = x - SMART_BATTERY_WIDTH / 2;
                        const newY = y - SMART_BATTERY_HEIGHT / 2;
                        const newSmartBattery = createSmartBattery(newX, newY, sourceItem.specs.smartBatteryKWh, sourceItem.id);
                        
                        allItems.push(newSmartBattery);
                        
                        // Connect to the port closer to the controller (smartPort2 is on the left)
                        createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort2);
                        
                        if (areHintsEnabled()) {
                            showHint("üîã Smart Battery Connected!", 
                                `Added ${sourceItem.specs.smartBatteryKWh} kWh expansion battery. Total capacity: ${(sourceItem.specs.internalBatteryKWh + sourceItem.specs.smartBatteryKWh).toFixed(1)} kWh`);
                        }
                    } else if (sourceItem.type === 'smartbattery') {
                        // Dragging from a smart battery - create another if port is free
                        const newX = x - SMART_BATTERY_WIDTH / 2;
                        const newY = y - SMART_BATTERY_HEIGHT / 2;
                        const newSmartBattery = createSmartBattery(newX, newY, sourceItem.specs.kWh, sourceItem.parentControllerId);
                        
                        allItems.push(newSmartBattery);
                        
                        // Connect smart port 1 (right) to new smart port 2 (left)
                        if (sourceHandle.id.includes('-smart-1')) {
                            createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort2);
                        } else {
                            createConnection(sourceItem, sourceHandle, newSmartBattery, newSmartBattery.handles.smartPort1);
                        }
                    }
                }
                // Panel or battery drag - create series component
                else if (sourceItem.type === 'panel' || sourceItem.type === 'battery') {
                    let newItem;
                    
                    if (sourceItem.type === 'panel') {
                        // Find the rightmost panel in the current series string to position new panel
                        const seriesString = findPanelsInSeriesString(sourceItem);
                        const rightmostPanel = seriesString.reduce((rightmost, panel) => 
                            (panel.x + panel.width) > (rightmost.x + rightmost.width) ? panel : rightmost, seriesString[0]);
                        
                        // Calculate spacing: panel width + gap (20px gap between panels)
                        const panelSpacing = rightmostPanel.width + 20;
                        
                        // Align new panel horizontally (same Y) and to the right of the rightmost panel
                        const newX = rightmostPanel.x + panelSpacing;
                        const newY = rightmostPanel.y; // Perfect horizontal alignment
                        
                        newItem = createPanel(newX, newY, sourceItem.specs);
                    } else if (sourceItem.type === 'battery') {
                        // Keep same Y as source battery for horizontal alignment
                        const newX = x - BATTERY_WIDTH / 2;
                        const newY = sourceItem.y;
                        newItem = createBattery(newX, newY, sourceItem.specs);
                    }
                    
                    if (newItem) {
                        allItems.push(newItem);
                        
                        // Connect in series: positive -> negative, negative -> positive
                        const isPositive = sourceHandle.polarity === 'positive' || sourceHandle.polarity === 'pv-positive';
                        const newHandle = isPositive ? newItem.handles.negative : newItem.handles.positive;
                        
                        createConnection(sourceItem, sourceHandle, newItem, newHandle);
                        
                        if (sourceItem.type === 'panel') {
                            showSeriesPanelHint();
                        } else if (sourceItem.type === 'battery') {
                            showSeriesBatteryHint();
                        }
                    }
                }
                // AC output drag - create circuit (breaker + outlet)
                else if (sourceHandle.polarity === 'ac' && sourceHandle.id.includes('-ac-out')) {
                    createACCircuit(sourceItem, sourceHandle, x, y);
                }
                // Panel/Spiderbox circuit output drag - create outlet directly
                else if (sourceHandle.polarity === 'ac' && (sourceItem.type === 'breakerpanel' || sourceItem.type === 'spiderbox')) {
                    createOutletFromCircuit(sourceItem, sourceHandle, x, y);
                }
                // Outlet output drag - create another outlet (daisy chain)
                else if (sourceHandle.polarity === 'ac' && sourceItem.type === 'acoutlet' && sourceHandle.id.includes('-out')) {
                    createOutletFromCircuit(sourceItem, sourceHandle, x, y);
                }
                // Outlet load port drag - create appliance/load
                else if (sourceHandle.polarity === 'load' && sourceItem.type === 'acoutlet') {
                    createLoadFromOutlet(sourceItem, sourceHandle, x, y);
                }
            }
            
            draggingHandle = null;
        }
        
        // Helper function to find all panels in the same series string
        function findPanelsInSeriesString(panel) {
            if (!panel || panel.type !== 'panel') return [panel];
            
            const seriesPanels = [panel];
            const visited = new Set([panel.id]);
            
            function traverseSeries(currentPanel, fromHandle) {
                // Get the opposite handle
                const oppositeHandle = fromHandle.polarity === 'positive' 
                    ? currentPanel.handles.negative 
                    : currentPanel.handles.positive;
                
                // Check connections from the opposite handle
                if (oppositeHandle && oppositeHandle.connectedTo) {
                    oppositeHandle.connectedTo.forEach(conn => {
                        const connectedItem = allItems.find(i => i.id === conn.itemId);
                        if (connectedItem && connectedItem.type === 'panel' && !visited.has(connectedItem.id)) {
                            const connectedHandle = Object.values(connectedItem.handles).find(h => h.id === conn.handleId);
                            // Series connection: opposite polarities
                            if (connectedHandle && connectedHandle.polarity !== oppositeHandle.polarity) {
                                visited.add(connectedItem.id);
                                seriesPanels.push(connectedItem);
                                traverseSeries(connectedItem, connectedHandle);
                            }
                        }
                    });
                }
            }
            
            // Traverse in both directions from this panel
            if (panel.handles.positive && panel.handles.positive.connectedTo) {
                panel.handles.positive.connectedTo.forEach(conn => {
                    const connectedItem = allItems.find(i => i.id === conn.itemId);
                    if (connectedItem && connectedItem.type === 'panel' && !visited.has(connectedItem.id)) {
                        const connectedHandle = Object.values(connectedItem.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle && connectedHandle.polarity === 'negative') {
                            visited.add(connectedItem.id);
                            seriesPanels.push(connectedItem);
                            traverseSeries(connectedItem, connectedHandle);
                        }
                    }
                });
            }
            
            if (panel.handles.negative && panel.handles.negative.connectedTo) {
                panel.handles.negative.connectedTo.forEach(conn => {
                    const connectedItem = allItems.find(i => i.id === conn.itemId);
                    if (connectedItem && connectedItem.type === 'panel' && !visited.has(connectedItem.id)) {
                        const connectedHandle = Object.values(connectedItem.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle && connectedHandle.polarity === 'positive') {
                            visited.add(connectedItem.id);
                            seriesPanels.push(connectedItem);
                            traverseSeries(connectedItem, connectedHandle);
                        }
                    }
                });
            }
            
            // Sort panels by X position (left to right)
            return seriesPanels.sort((a, b) => a.x - b.x);
        }
        
        // Helper function to find all parallel strings in an array
        function findParallelStrings(panel) {
            if (!panel || panel.type !== 'panel') return [];
            
            const strings = [];
            const processedPanels = new Set();
            
            // Find all panels that share the same positive connection point (parallel strings)
            const allPanels = allItems.filter(i => i.type === 'panel');
            
            // Group panels by their positive terminal connections
            const positiveGroups = new Map();
            
            allPanels.forEach(p => {
                if (processedPanels.has(p.id)) return;
                
                // Find the string this panel belongs to
                const string = findPanelsInSeriesString(p);
                if (string.length === 0) return;
                
                // Get the first panel's positive handle connections to find parallel strings
                const firstPanel = string[0];
                const posHandle = firstPanel.handles.positive;
                
                // Check if this string's positive is connected to the same external point
                let groupKey = null;
                if (posHandle.connectedTo.length > 0) {
                    // Use the first external connection as the group key
                    const externalConn = posHandle.connectedTo.find(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        return item && item.type !== 'panel';
                    });
                    if (externalConn) {
                        groupKey = externalConn.itemId + '-' + externalConn.handleId;
                    }
                }
                
                if (!groupKey) {
                    // If no external connection, use the panel IDs as key
                    groupKey = string.map(p => p.id).sort().join('-');
                }
                
                if (!positiveGroups.has(groupKey)) {
                    positiveGroups.set(groupKey, []);
                }
                positiveGroups.get(groupKey).push(string);
                
                string.forEach(p => processedPanels.add(p.id));
            });
            
            // Find the group that contains our panel
            for (const [key, stringArray] of positiveGroups.entries()) {
                if (stringArray.some(str => str.some(p => p.id === panel.id))) {
                    return stringArray;
                }
            }
            
            // Fallback: return just the panel's own string
            return [findPanelsInSeriesString(panel)];
        }
        
        // Create load/appliance from outlet load port
        function createLoadFromOutlet(sourceItem, sourceHandle, x, y) {
            const voltage = sourceHandle.voltage || sourceItem.specs.voltage || 120;
            
            // Find a default preset matching the voltage
            const defaultPreset = APPLIANCE_PRESETS.find(p => p.voltage === voltage) || APPLIANCE_PRESETS[0];
            const preset = { ...defaultPreset, voltage: voltage };
            
            // Create load at drag position
            const load = createACLoad(x - AC_LOAD_WIDTH / 2, y - AC_LOAD_HEIGHT / 2, preset);
            allItems.push(load);
            
            // Connect outlet load port to load cord
            createConnection(sourceItem, sourceHandle, load, load.handles.cord);
            
            if (areHintsEnabled()) {
                showHint("üîå Appliance Connected!", 
                    `Added ${voltage}V load. Select it to change the appliance type and wattage.`);
            }
        }
        
        // Create outlet from panel/spiderbox circuit output or daisy-chain from another outlet
        function createOutletFromCircuit(sourceItem, sourceHandle, x, y) {
            // Get voltage from the source handle
            const voltage = sourceHandle.voltage || 120;
            
            // Create outlet at drag position
            const outlet = createACOutlet(x - AC_OUTLET_WIDTH / 2, y - AC_OUTLET_HEIGHT / 2, voltage);
            allItems.push(outlet);
            
            // Connect source to outlet input
            createConnection(sourceItem, sourceHandle, outlet, outlet.handles.input);
            
            if (areHintsEnabled()) {
                const isDaisyChain = sourceItem.type === 'acoutlet';
                showHint(isDaisyChain ? "üîå Outlet Daisy-Chained!" : "üîå Outlet Connected!", 
                    `Added ${voltage}V outlet. Drag from its right port to add more outlets in series.`);
            }
        }
        
        // Create AC circuit from AC output drag
        function createACCircuit(sourceItem, sourceHandle, x, y) {
            // Determine voltage and wattage from source
            let voltage = 120;
            let maxWatts = 1800;
            
            if (sourceItem.type === 'controller') {
                maxWatts = sourceItem.specs.maxACOutputW || 1800;
            } else if (sourceItem.type === 'doublevoltagehub') {
                voltage = 240; // Hub outputs 240V
                maxWatts = sourceItem.specs.maxOutputW || 7200;
            }
            
            // Auto-size breaker
            const breakerSpecs = getAutoSizedACBreaker(maxWatts, voltage);
            
            // Create breaker at drag position
            const breaker = createACBreaker(x, y, breakerSpecs);
            allItems.push(breaker);
            
            // Create outlet to the right of breaker
            const outlet = createACOutlet(x + AC_BREAKER_WIDTH + 60, y + (AC_BREAKER_HEIGHT - AC_OUTLET_HEIGHT) / 2, voltage);
            allItems.push(outlet);
            
            // Connect source to breaker input
            createConnection(sourceItem, sourceHandle, breaker, breaker.handles.lineIn);
            
            // Connect breaker output to outlet
            createConnection(breaker, breaker.handles.loadOut, outlet, outlet.handles.input);
            
            if (areHintsEnabled()) {
                showHint("‚ö° AC Circuit Created!", 
                    `Added ${breakerSpecs.rating}A breaker and ${voltage}V outlet. Max load: ${breakerSpecs.maxWatts}W`);
            }
        }
        
        // ============================================
        // CONNECTION MANAGEMENT
        // ============================================
        
        // Get voltage for an AC connection by tracing back to source
        function getACVoltageForConnection(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if this is an AC connection
            if (sourceHandle.polarity !== 'ac' && targetHandle.polarity !== 'ac' && 
                sourceHandle.polarity !== 'load' && targetHandle.polarity !== 'load') {
                return null; // Not an AC connection
            }
            
            // Check if target is a load - use load's voltage requirement
            if (targetItem.type === 'acload' && targetItem.specs?.voltage) {
                return targetItem.specs.voltage;
            }
            
            // Check if source is a load - use load's voltage requirement
            if (sourceItem.type === 'acload' && sourceItem.specs?.voltage) {
                return sourceItem.specs.voltage;
            }
            
            // Check if connected to outlet - use outlet's voltage
            if (sourceItem.type === 'acoutlet' && sourceItem.specs?.voltage) {
                return sourceItem.specs.voltage;
            }
            if (targetItem.type === 'acoutlet' && targetItem.specs?.voltage) {
                return targetItem.specs.voltage;
            }
            
            // Check if connected to breaker panel circuit
            if (sourceItem.type === 'breakerpanel') {
                const circuitHandle = Object.values(sourceItem.handles).find(h => h.id === sourceHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    return circuitHandle.voltage;
                }
            }
            if (targetItem.type === 'breakerpanel') {
                const circuitHandle = Object.values(targetItem.handles).find(h => h.id === targetHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    return circuitHandle.voltage;
                }
            }
            
            // Check if connected to spiderbox circuit
            if (sourceItem.type === 'spiderbox') {
                const circuitHandle = Object.values(sourceItem.handles).find(h => h.id === sourceHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    return circuitHandle.voltage;
                }
            }
            if (targetItem.type === 'spiderbox') {
                const circuitHandle = Object.values(targetItem.handles).find(h => h.id === targetHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    return circuitHandle.voltage;
                }
            }
            
            // Check if connected to AC breaker
            if (sourceItem.type === 'acbreaker' && sourceItem.specs?.voltage) {
                return sourceItem.specs.voltage;
            }
            if (targetItem.type === 'acbreaker' && targetItem.specs?.voltage) {
                return targetItem.specs.voltage;
            }
            
            // Check if connected to double voltage hub AC output (240V)
            if (sourceItem.type === 'doublevoltagehub' && sourceHandle.id === sourceItem.handles?.acOutput?.id) {
                return 240; // Double voltage hub outputs 240V
            }
            if (targetItem.type === 'doublevoltagehub' && targetHandle.id === targetItem.handles?.acOutput?.id) {
                return 240;
            }
            
            // Trace back through connections to find voltage source
            const visited = new Set();
            const traceVoltage = (item, handle) => {
                const key = `${item.id}-${handle.id}`;
                if (visited.has(key)) return null;
                visited.add(key);
                
                // Check if this item provides voltage
                if (item.type === 'doublevoltagehub' && handle.id === item.handles?.acOutput?.id) {
                    return 240;
                }
                if (item.type === 'breakerpanel') {
                    const circuitHandle = Object.values(item.handles).find(h => h.id === handle.id);
                    if (circuitHandle && circuitHandle.voltage) {
                        return circuitHandle.voltage;
                    }
                }
                if (item.type === 'spiderbox') {
                    const circuitHandle = Object.values(item.handles).find(h => h.id === handle.id);
                    if (circuitHandle && circuitHandle.voltage) {
                        return circuitHandle.voltage;
                    }
                }
                if (item.type === 'acbreaker' && item.specs?.voltage) {
                    return item.specs.voltage;
                }
                
                // Trace back through incoming connections
                if (handle.connectedTo && handle.connectedTo.length > 0) {
                    for (const connInfo of handle.connectedTo) {
                        const conn = connections.find(c => c.id === connInfo.connectionId);
                        if (conn) {
                            const otherItem = allItems.find(i => 
                                (i.id === conn.sourceItemId || i.id === conn.targetItemId) && i.id !== item.id
                            );
                            if (otherItem) {
                                const otherHandleId = conn.sourceItemId === otherItem.id ? conn.sourceHandleId : conn.targetHandleId;
                                const otherHandle = Object.values(otherItem.handles).find(h => h.id === otherHandleId);
                                if (otherHandle) {
                                    const voltage = traceVoltage(otherItem, otherHandle);
                                    if (voltage) return voltage;
                                }
                            }
                        }
                    }
                }
                
                return null;
            };
            
            // Try tracing from source
            let voltage = traceVoltage(sourceItem, sourceHandle);
            if (voltage) return voltage;
            
            // Try tracing from target
            visited.clear();
            voltage = traceVoltage(targetItem, targetHandle);
            return voltage;
        }
        
        // Validate resource type compatibility for resource port connections
        function validateResourceTypeCompatibility(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if both handles have resourceType (resource port connection)
            if (!sourceHandle.resourceType || !targetHandle.resourceType) {
                return { valid: true }; // Not a resource port connection
            }
            
            // Generic containers can connect to any resource type
            const isSourceGeneric = sourceHandle.resourceType === RESOURCE_TYPES.GENERIC || 
                                    sourceItem.specs?.resourceType === RESOURCE_TYPES.GENERIC;
            const isTargetGeneric = targetHandle.resourceType === RESOURCE_TYPES.GENERIC || 
                                    targetItem.specs?.resourceType === RESOURCE_TYPES.GENERIC;
            
            if (isSourceGeneric || isTargetGeneric) {
                return { valid: true }; // Generic containers can connect to anything
            }
            
            // Resource types must match
            if (sourceHandle.resourceType !== targetHandle.resourceType) {
                return {
                    valid: false,
                    error: "‚ö†Ô∏è Resource Type Mismatch",
                    message: `Cannot connect ${sourceHandle.resourceType} to ${targetHandle.resourceType}. Resource types must match. Use a Generic container for universal connections.`
                };
            }
            
            // Check input/output compatibility
            if (sourceHandle.polarity === 'input' && targetHandle.polarity === 'input') {
                return {
                    valid: false,
                    error: "‚ö†Ô∏è Connection Error",
                    message: "Cannot connect two input ports together. Connect an output to an input."
                };
            }
            if (sourceHandle.polarity === 'output' && targetHandle.polarity === 'output') {
                return {
                    valid: false,
                    error: "‚ö†Ô∏è Connection Error",
                    message: "Cannot connect two output ports together. Connect an output to an input."
                };
            }
            
            return { valid: true };
        }
        
        // Validate voltage compatibility for AC connections
        function validateACVoltageCompatibility(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Only validate AC connections
            if (sourceHandle.polarity !== 'ac' && targetHandle.polarity !== 'ac' && 
                sourceHandle.polarity !== 'load' && targetHandle.polarity !== 'load') {
                return { valid: true }; // Not an AC connection, no validation needed
            }
            
            // Get source voltage
            const sourceVoltage = getACVoltageForConnection(sourceItem, sourceHandle, targetItem, targetHandle);
            
            // Get target voltage requirement
            let targetVoltage = null;
            if (targetItem.type === 'acload' && targetItem.specs?.voltage) {
                targetVoltage = targetItem.specs.voltage;
            } else if (targetItem.type === 'breakerpanel') {
                const circuitHandle = Object.values(targetItem.handles).find(h => h.id === targetHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    targetVoltage = circuitHandle.voltage;
                }
            } else if (targetItem.type === 'spiderbox') {
                const circuitHandle = Object.values(targetItem.handles).find(h => h.id === targetHandle.id);
                if (circuitHandle && circuitHandle.voltage) {
                    targetVoltage = circuitHandle.voltage;
                }
            }
            
            // Validation rules
            if (sourceVoltage && targetVoltage) {
                // Rule 1: 120V cannot feed 240V split-phase distro
                if (sourceVoltage === 120 && targetVoltage === 240) {
                    if (targetItem.type === 'breakerpanel' || targetItem.type === 'spiderbox') {
                        return {
                            valid: false,
                            error: "‚ö†Ô∏è Voltage Mismatch",
                            message: "120V cannot feed a 240V distribution panel. You need a 240V source (like a double voltage hub) to power a 240V panel."
                        };
                    }
                }
                
                // Rule 2: 240V appliances won't run on 120V (except resistive heaters at 1/4 power)
                if (sourceVoltage === 120 && targetVoltage === 240) {
                    if (targetItem.type === 'acload') {
                        const isResistiveHeater = targetItem.specs?.behavior?.type === 'thermostat' || 
                                                 targetItem.specs?.name?.toLowerCase().includes('heater');
                        if (isResistiveHeater) {
                            return {
                                valid: true,
                                warning: "‚ö†Ô∏è Voltage Warning",
                                message: "This 240V resistive heater will run at 1/4 power (25%) on 120V. For full power, connect to a 240V circuit."
                            };
                        } else {
                            return {
                                valid: false,
                                error: "‚ö†Ô∏è Voltage Mismatch",
                                message: "This 240V appliance cannot run on 120V. Connect it to a 240V circuit instead."
                            };
                        }
                    }
                }
                
                // Rule 3: 120V appliances explode on 240V
                if (sourceVoltage === 240 && targetVoltage === 120) {
                    if (targetItem.type === 'acload') {
                        return {
                            valid: false,
                            error: "üí• Voltage Danger!",
                            message: "WARNING: This 120V appliance will be destroyed if connected to 240V! The appliance will explode. Connect it to a 120V circuit instead."
                        };
                    }
                }
            }
            
            return { valid: true };
        }
        
        function createConnection(sourceItem, sourceHandle, targetItem, targetHandle) {
            // Check if connection already exists
            const exists = connections.some(c => 
                (c.sourceHandleId === sourceHandle.id && c.targetHandleId === targetHandle.id) ||
                (c.sourceHandleId === targetHandle.id && c.targetHandleId === sourceHandle.id)
            );
            if (exists) return;
            
            // Validate resource type compatibility (for resource port connections)
            const resourceValidation = validateResourceTypeCompatibility(sourceItem, sourceHandle, targetItem, targetHandle);
            if (!resourceValidation.valid) {
                showHint(resourceValidation.error, resourceValidation.message);
                return; // Don't create the connection
            }
            
            // Validate AC voltage compatibility
            const voltageValidation = validateACVoltageCompatibility(sourceItem, sourceHandle, targetItem, targetHandle);
            if (!voltageValidation.valid) {
                showHint(voltageValidation.error, voltageValidation.message);
                return; // Don't create the connection
            }
            if (voltageValidation.warning) {
                showHint(voltageValidation.warning, voltageValidation.message);
                // Continue with connection but show warning
            }
            
            // Determine wire polarity - normalize pv-positive/pv-negative to positive/negative
            const normalizePolarity = (p) => {
                if (p === 'pv-positive') return 'positive';
                if (p === 'pv-negative') return 'negative';
                return p;
            };
            
            const srcPol = normalizePolarity(sourceHandle.polarity);
            const tgtPol = normalizePolarity(targetHandle.polarity);
            
            let polarity = 'mixed';
            if (srcPol === tgtPol) {
                polarity = srcPol; // Use normalized polarity for wire color
            }
            // Parallel connections (hub to Delta Pro)
            if (sourceHandle.polarity === 'parallel' && targetHandle.polarity === 'parallel') {
                polarity = 'parallel';
            }
            // Load connections (outlet to appliance - black cord)
            if (sourceHandle.polarity === 'load' || targetHandle.polarity === 'load') {
                polarity = 'load';
            }
            
            // Resource port connections (processor/container resource ports)
            let resourceType = null;
            if (sourceHandle.resourceType && targetHandle.resourceType) {
                polarity = 'resource';
                resourceType = sourceHandle.resourceType; // Store resource type for connection rendering
            }
            
            // Create connection object first (temporarily for calculations)
            const tempConn = {
                id: `conn-${++connectionIdCounter}`,
                sourceItemId: sourceItem.id,
                sourceHandleId: sourceHandle.id,
                targetItemId: targetItem.id,
                targetHandleId: targetHandle.id,
                polarity,
                resourceType: resourceType
            };
            
            // Calculate initial wire properties
            const initialCurrent = calculateWireCurrent(tempConn);
            const wireSpec = getWireGaugeForAmps(initialCurrent);
            const estimatedLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
            const costPerFoot = WIRE_COST_PER_FOOT[wireSpec.gauge] || WIRE_COST_PER_FOOT['10'];
            const totalWireCost = estimatedLength * costPerFoot;
            
            // Add wire properties to connection
            const conn = {
                ...tempConn,
                // Wire properties
                wireGauge: wireSpec.gauge,
                wireAmps: initialCurrent,
                estimatedLength: estimatedLength,
                costPerFoot: costPerFoot,
                totalWireCost: totalWireCost
            };
            
            connections.push(conn);
            invalidateSpecsCache(); // Connections changed - clear cached specs
            sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
            targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
            
            // If in live view mode, recalculate power flow to update wire glow immediately
            if (liveViewActive && LiveView.state.active) {
                LiveView.PowerFlow.calculate();
            }
            
            render();
            checkTutorialProgress();
            validateSystem();
        }
        
        function deleteItem(itemId) {
            const item = allItems.find(i => i.id === itemId);
            if (!item) return;
            
            const wasPanel = item.type === 'panel';
            
            // Delete all connections involving this item
            const connToDelete = connections.filter(c => c.sourceItemId === itemId || c.targetItemId === itemId);
            connToDelete.forEach(c => deleteConnection(c.id));
            
            // Remove the item
            allItems = allItems.filter(i => i.id !== itemId);
            
            if (selectedItem && selectedItem.id === itemId) {
                selectedItem = null;
                closeInspector();
            }
            
            // Update array area if a panel was deleted
            if (wasPanel && typeof updatePanelArrayArea === 'function') {
                updatePanelArrayArea();
            }
            
            render();
            validateSystem();
        }
        
        function deleteConnection(connId) {
            const conn = connections.find(c => c.id === connId);
            if (!conn) return;
            
            // Remove from handles
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            
            if (sourceItem) {
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle) {
                    sourceHandle.connectedTo = sourceHandle.connectedTo.filter(c => c.connectionId !== connId);
                }
            }
            
            if (targetItem) {
                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                if (targetHandle) {
                    targetHandle.connectedTo = targetHandle.connectedTo.filter(c => c.connectionId !== connId);
                }
            }
            
            connections = connections.filter(c => c.id !== connId);
            invalidateSpecsCache(); // Connections changed - clear cached specs
            selectedConnection = null;
            
            // If in live view mode, update power flow and turn off disconnected loads
            if (LiveView.state.active) {
                // Clear power flow for deleted connection
                if (LiveView.state.powerFlow[connId]) {
                    delete LiveView.state.powerFlow[connId];
                }
                
                // Recalculate power flow immediately
                LiveView.PowerFlow.calculate();
                
                // Turn off any loads that are now disconnected from their circuits
                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                    if (LiveView.state.loadStates[loadId]) {
                        const load = allItems.find(i => i.id === loadId);
                        if (load && load.type === 'acload') {
                            const circuitStatus = checkLoadCircuitStatus(load);
                            if (!circuitStatus.isLive) {
                                LiveView.state.loadStates[loadId] = false;
                            }
                        }
                    }
                });
            }
            
            render();
            validateSystem();
        }
        
        // ============================================
        // SELECTION
        // ============================================
        
        function selectItem(item, selectArray = false) {
            selectedItem = item;
            selectedConnection = null;
            
            // If selecting a panel and Ctrl/Cmd is held, select entire array
            if (item.type === 'panel' && selectArray) {
                const parallelStrings = findParallelStrings(item);
                selectedArray = [];
                parallelStrings.forEach(string => {
                    selectedArray.push(...string);
                });
            } else {
                selectedArray = null;
            }
            
            openInspector(item);
            render();
        }
        
        function selectConnection(conn) {
            selectedConnection = conn;
            selectedItem = null;
            openWireInspector(conn);
            render();
        }
        
        function deselectAll() {
            selectedItem = null;
            selectedConnection = null;
            closeInspector();
            render();
        }
        
        // ============================================
        // INSPECTOR
        // ============================================
        
        function openInspector(item) {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.add('open');
            
            // Hide all inspectors first
            ['inspectorEmpty', 'panelInspector', 'batteryInspector', 'controllerInspector', 'wireInspector',
             'breakerInspector', 'combinerInspector', 'solarCombinerInspector', 'spiderboxInspector',
             'breakerpanelInspector', 'acloadInspector', 'resourceContainerInspector'].forEach(id => document.getElementById(id).classList.add('hidden'));
            
            if (item.type === 'panel') {
                document.getElementById('panelInspector').classList.remove('hidden');
                document.getElementById('panelName').value = item.specs.name || '';
                document.getElementById('panelWmp').value = item.specs.wmp;
                document.getElementById('panelVmp').value = item.specs.vmp;
                document.getElementById('panelVoc').value = item.specs.voc;
                document.getElementById('panelIsc').value = item.specs.isc;
                // Calculate IMP if missing, otherwise use stored value
                const imp = item.specs.imp || (item.specs.wmp && item.specs.vmp ? item.specs.wmp / item.specs.vmp : 0);
                document.getElementById('panelImp').value = imp.toFixed(2);
                document.getElementById('panelWidth').value = item.specs.width || 0;
                document.getElementById('panelHeight').value = item.specs.height || 0;
                document.getElementById('panelCost').value = item.specs.cost;
                
                // Calculate and display total array area
                updatePanelArrayArea();
            } else if (item.type === 'battery') {
                document.getElementById('batteryInspector').classList.remove('hidden');
                document.getElementById('batteryName').value = item.specs.name || '';
                document.getElementById('batteryVoltage').value = item.specs.voltage;
                document.getElementById('batteryAh').value = item.specs.ah;
                document.getElementById('batteryMaxDischarge').value = item.specs.maxDischarge;
                document.getElementById('batteryCost').value = item.specs.cost;
                document.getElementById('batteryWidth').value = item.specs.width || 200;
                document.getElementById('batteryHeight').value = item.specs.height || 300;
                
                // Load low-battery protection settings
                const lowBatterySettings = item.specs.lowBatteryProtection || {};
                document.getElementById('batteryEnableLowBatteryShutdown').checked = lowBatterySettings.enabled !== false; // Default to true
                document.getElementById('batteryShutdownThreshold').value = lowBatterySettings.shutdownThreshold || 10;
                document.getElementById('batteryReenableThreshold').value = lowBatterySettings.reenableThreshold || 15;
            } else if (item.type === 'controller') {
                document.getElementById('controllerInspector').classList.remove('hidden');
                document.getElementById('controllerName').value = item.specs.name || '';
                document.getElementById('controllerType').value = item.specs.type || 'charge_controller';
                document.getElementById('controllerMaxVoc').value = item.specs.maxVoc;
                document.getElementById('controllerMinVmp').value = item.specs.minVmp || 0;
                document.getElementById('controllerMppMin').value = item.specs.mppVoltageMin || 0;
                document.getElementById('controllerMppMax').value = item.specs.mppVoltageMax || item.specs.maxVoc;
                document.getElementById('controllerMaxIsc').value = item.specs.maxIsc;
                document.getElementById('controllerMaxWmp').value = item.specs.maxWmp;
                document.getElementById('controllerMpptCount').value = item.specs.mpptCount || 1;
                document.getElementById('controllerChargeCurrent').value = item.specs.ratedChargeCurrent;
                document.getElementById('controllerCost').value = item.specs.cost;
                
                // Show/hide AC output field based on type
                const isHybrid = item.specs.type === 'hybrid_inverter' || item.specs.type === 'all_in_one';
                document.getElementById('controllerACOutput').classList.toggle('hidden', !isHybrid);
                document.getElementById('controllerACOutputW').value = item.specs.maxACOutputW || 0;
                document.getElementById('controllerInverterLoad').value = item.specs.inverterLoad || 0;
                
                // Set voltage checkboxes
                const supportedVoltages = item.specs.supportedVoltages || [12, 24, 48];
                document.getElementById('controllerV12').checked = supportedVoltages.includes(12);
                document.getElementById('controllerV24').checked = supportedVoltages.includes(24);
                document.getElementById('controllerV36').checked = supportedVoltages.includes(36);
                document.getElementById('controllerV48').checked = supportedVoltages.includes(48);
                
                // Set dimension fields
                document.getElementById('controllerWidth').value = item.specs.width || 400;
                document.getElementById('controllerHeight').value = item.specs.height || 600;
                
                // Set styling fields
                document.getElementById('controllerTopColor').value = item.specs.topColor || '#c0c0c0';
                document.getElementById('controllerBottomColor').value = item.specs.bottomColor || '#2a2a2a';
                document.getElementById('controllerDividerHeight').value = item.specs.dividerHeight || 50;
                document.getElementById('controllerImageUrl').value = item.specs.imageUrl || '';
            } else if (item.type === 'breaker') {
                document.getElementById('breakerInspector').classList.remove('hidden');
                document.getElementById('breakerRating').value = item.specs.rating;
                document.getElementById('breakerMaxVoltage').value = item.specs.maxVoltage;
                document.getElementById('breakerCost').value = item.specs.cost;
                document.getElementById('breakerStatus').textContent = item.isClosed ? '‚úì CLOSED (Conducting)' : '‚úó OPEN (Tripped)';
                document.getElementById('breakerStatus').style.color = item.isClosed ? '#5cb85c' : '#d9534f';
            } else if (item.type === 'combiner') {
                document.getElementById('combinerInspector').classList.remove('hidden');
                document.getElementById('combinerInputCount').textContent = item.specs.inputs;
                document.getElementById('combinerMaxAmps').value = item.specs.maxAmpsPerInput;
                document.getElementById('combinerCost').value = item.specs.cost;
            } else if (item.type === 'solarcombiner') {
                document.getElementById('solarCombinerInspector').classList.remove('hidden');
                document.getElementById('solarCombinerInputCount').textContent = item.specs.inputs;
                document.getElementById('solarCombinerBreakerRating').value = item.specs.breakerRating;
                document.getElementById('solarCombinerMaxVoltage').value = item.specs.maxVoltage;
                document.getElementById('solarCombinerCost').value = item.specs.cost;
                
                // Populate individual breaker toggles
                const breakersDiv = document.getElementById('solarCombinerBreakers');
                breakersDiv.innerHTML = '';
                for (let i = 0; i < item.specs.inputs; i++) {
                    const isClosed = item.breakerStates[i];
                    const btn = document.createElement('button');
                    btn.textContent = `Input ${i + 1}: ${isClosed ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 5px;
                        background: ${isClosed ? '#5cb85c' : '#d9534f'}; color: white;
                        border: none; border-radius: 4px; cursor: pointer; font-size: 11px;
                    `;
                    btn.onclick = () => {
                        item.breakerStates[i] = !item.breakerStates[i];
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${item.id}-circuit-${i + 1}`;
                            // Always create/update to ensure wasTripped is cleared when manually toggling
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: item.breakerStates[i],
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                        }
                        openInspector(item); // Refresh
                        render();
                        
                        // Refresh inspector if a load is currently selected (to update circuit status)
                        if (selectedItem && selectedItem.type === 'acload') {
                            openInspector(selectedItem);
                        }
                    };
                    breakersDiv.appendChild(btn);
                }
            } else if (item.type === 'spiderbox') {
                document.getElementById('spiderboxInspector').classList.remove('hidden');
                document.getElementById('spiderboxMaxPower').textContent = item.specs.maxInputWatts.toLocaleString() + 'W';
                const costInput = document.getElementById('spiderboxCost');
                costInput.value = item.specs.cost;
                // Apply cost changes immediately
                costInput.oninput = () => {
                    item.specs.cost = parseFloat(costInput.value) || 0;
                };
                
                // Main breaker toggle
                const mainOn = item.mainBreakerOn !== false;
                const breakersDiv = document.getElementById('spiderboxBreakers');
                breakersDiv.innerHTML = '';
                
                // Add main breaker first
                const mainBtn = document.createElement('button');
                mainBtn.textContent = `‚ö° MAIN BREAKER (50A): ${mainOn ? 'ON' : 'OFF'}`;
                mainBtn.style.cssText = `
                    display: block; width: 100%; margin: 3px 0; padding: 8px;
                    background: ${mainOn ? '#8b0000' : '#333'}; 
                    color: ${mainOn ? '#fff' : '#888'};
                    border: 2px solid ${mainOn ? '#d9534f' : '#555'}; border-radius: 4px; 
                    cursor: pointer; font-size: 12px; font-weight: bold;
                `;
                mainBtn.onclick = () => {
                    const wasOn = item.mainBreakerOn !== false;
                    item.mainBreakerOn = !item.mainBreakerOn;
                    const isNowOn = item.mainBreakerOn !== false;
                    
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (wasOn && !isNowOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    // Update button text immediately
                    mainBtn.textContent = `‚ö° MAIN BREAKER (50A): ${isNowOn ? 'ON' : 'OFF'}`;
                    mainBtn.style.background = isNowOn ? '#8b0000' : '#333';
                    mainBtn.style.color = isNowOn ? '#fff' : '#888';
                    mainBtn.style.border = `2px solid ${isNowOn ? '#d9534f' : '#555'}`;
                    if (LiveView.state.active) {
                        LiveView.Animation.scheduleUpdate();
                    }
                    render();
                };
                breakersDiv.appendChild(mainBtn);
                
                // Populate circuit breaker toggles
                item.specs.circuits.forEach((circuit, i) => {
                    const handle = item.handles[`circuit${i + 1}`];
                    const isClosed = handle.isClosed !== false;
                    const btn = document.createElement('button');
                    btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${isClosed ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 6px;
                        background: ${isClosed ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444'}; 
                        color: ${isClosed ? '#000' : '#888'};
                        border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;
                    `;
                    btn.onclick = () => {
                        const wasOn = handle.isClosed !== false;
                        handle.isClosed = !handle.isClosed;
                        const isNowOn = handle.isClosed !== false;
                        
                        // Update live view breaker state if in live view mode
                        if (LiveView.state.active) {
                            const breakerId = `${item.id}-circuit-${i + 1}`;
                            LiveView.state.breakerStates[breakerId] = {
                                isClosed: handle.isClosed,
                                wasTripped: false // Always clear tripped flag when manually toggling
                            };
                            
                            // If breaker was turned off, immediately turn off all loads on this circuit
                            if (wasOn && !isNowOn) {
                                Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                    const load = allItems.find(l => l.id === loadId);
                                    if (load && load.type === 'acload') {
                                        const circuitStatus = checkLoadCircuitStatus(load);
                                        if (!circuitStatus.isLive) {
                                            LiveView.state.loadStates[loadId] = false;
                                        }
                                    }
                                });
                            }
                            LiveView.Animation.scheduleUpdate();
                        }
                        // Update button text and style immediately
                        btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${isNowOn ? 'ON' : 'OFF'}`;
                        btn.style.background = isNowOn ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444';
                        btn.style.color = isNowOn ? '#000' : '#888';
                        render();
                    };
                    breakersDiv.appendChild(btn);
                });
            } else if (item.type === 'breakerpanel') {
                document.getElementById('breakerpanelInspector').classList.remove('hidden');
                document.getElementById('panelMaxPower').textContent = item.specs.maxInputWatts.toLocaleString() + 'W';
                const costInput = document.getElementById('breakerpanelCost');
                costInput.value = item.specs.cost;
                // Apply cost changes immediately
                costInput.oninput = () => {
                    item.specs.cost = parseFloat(costInput.value) || 0;
                };
                
                // Main breaker toggle
                const mainOn = item.mainBreakerOn !== false;
                const breakersDiv = document.getElementById('breakerpanelBreakers');
                breakersDiv.innerHTML = '';
                
                // Add main breaker first
                const mainBtn = document.createElement('button');
                mainBtn.textContent = `‚ö° MAIN BREAKER (100A): ${mainOn ? 'ON' : 'OFF'}`;
                mainBtn.style.cssText = `
                    display: block; width: 100%; margin: 3px 0; padding: 8px;
                    background: ${mainOn ? '#8b0000' : '#333'}; 
                    color: ${mainOn ? '#fff' : '#888'};
                    border: 2px solid ${mainOn ? '#d9534f' : '#555'}; border-radius: 4px; 
                    cursor: pointer; font-size: 12px; font-weight: bold;
                `;
                mainBtn.onclick = () => {
                    const wasOn = item.mainBreakerOn !== false;
                    item.mainBreakerOn = !item.mainBreakerOn;
                    const isNowOn = item.mainBreakerOn !== false;
                    
                    // If main breaker is turned off, immediately turn off all loads on all circuits
                    if (wasOn && !isNowOn && LiveView.state.active) {
                        Object.keys(LiveView.state.loadStates).forEach(loadId => {
                            const load = allItems.find(i => i.id === loadId);
                            if (load && load.type === 'acload') {
                                const circuitStatus = checkLoadCircuitStatus(load);
                                if (!circuitStatus.isLive) {
                                    LiveView.state.loadStates[loadId] = false;
                                }
                            }
                        });
                    }
                    
                    if (LiveView.state.active) {
                        LiveView.PowerFlow.calculate();
                    }
                    
                    openInspector(item);
                    render();
                    
                    // Refresh inspector if a load is currently selected (to update circuit status)
                    if (selectedItem && selectedItem.type === 'acload') {
                        openInspector(selectedItem);
                    }
                };
                breakersDiv.appendChild(mainBtn);
                
                // Divider
                const divider = document.createElement('div');
                divider.style.cssText = 'height: 1px; background: #555; margin: 8px 0;';
                breakersDiv.appendChild(divider);
                
                // Populate circuit breaker toggles
                item.specs.circuits.forEach((circuit, i) => {
                    const isClosed = item.breakerStates[i] && mainOn;
                    const breakerOn = item.breakerStates[i];
                    const btn = document.createElement('button');
                    btn.textContent = `${circuit.name} (${circuit.voltage}V ${circuit.amps}A): ${breakerOn ? 'ON' : 'OFF'}`;
                    btn.style.cssText = `
                        display: block; width: 100%; margin: 3px 0; padding: 6px;
                        background: ${isClosed ? (circuit.voltage === 240 ? '#d9534f' : '#f0ad4e') : '#444'}; 
                        color: ${isClosed ? '#000' : '#888'};
                        border: none; border-radius: 4px; cursor: ${mainOn ? 'pointer' : 'not-allowed'}; 
                        font-size: 11px; font-weight: bold;
                        opacity: ${mainOn ? 1 : 0.5};
                    `;
                    btn.onclick = () => {
                        if (mainOn) {
                            const wasOn = item.breakerStates[i] !== false;
                            item.breakerStates[i] = !item.breakerStates[i];
                            const isNowOn = item.breakerStates[i] !== false;
                            
                            // Update live view breaker state if in live view mode
                            if (LiveView.state.active) {
                                const breakerId = `${item.id}-circuit-${i + 1}`;
                                // Always create/update to ensure wasTripped is cleared when manually toggling
                                LiveView.state.breakerStates[breakerId] = {
                                    isClosed: item.breakerStates[i],
                                    wasTripped: false // Always clear tripped flag when manually toggling
                                };
                                
                                // If breaker was turned off, immediately turn off all loads on this circuit
                                if (wasOn && !isNowOn) {
                                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                                        const load = allItems.find(i => i.id === loadId);
                                        if (load && load.type === 'acload') {
                                            const circuitStatus = checkLoadCircuitStatus(load);
                                            if (!circuitStatus.isLive) {
                                                LiveView.state.loadStates[loadId] = false;
                                            }
                                        }
                                    });
                                }
                                
                                // Immediately recalculate power flow and re-render
                                LiveView.PowerFlow.calculate();
                            }
                            
                            openInspector(item); // Refresh to show updated state
                            render();
                            
                            // Refresh inspector if a load is currently selected (to update circuit status)
                            if (selectedItem && selectedItem.type === 'acload') {
                                openInspector(selectedItem);
                            }
                        }
                    };
                    breakersDiv.appendChild(btn);
                });
            } else if (item.type === 'acload') {
                document.getElementById('acloadInspector').classList.remove('hidden');
                
                // Show/hide live view toggle section
                const toggleSection = document.getElementById('loadToggleSection');
                if (liveViewActive || currentMode === 'simulate') {
                    toggleSection.classList.remove('hidden');
                    // Check both simState and LiveView state for accurate display
                    let isOn = false;
                    if (currentMode === 'simulate') {
                        isOn = (item.simState && item.simState.isRunning) || (LiveView.state.loadStates && LiveView.state.loadStates[item.id] === true);
                    } else {
                        isOn = LiveView.state.loadStates && LiveView.state.loadStates[item.id] === true;
                    }
                    const toggleBtn = document.getElementById('loadToggleBtn');
                    const statusText = document.getElementById('loadStatusText');
                    
                    toggleBtn.textContent = isOn ? 'ON' : 'OFF';
                    toggleBtn.style.background = isOn ? '#5cb85c' : '#d9534f';
                    toggleBtn.style.color = '#fff';
                    
                    // Check circuit status
                    const circuitStatus = checkLoadCircuitStatus(item);
                    if (!circuitStatus.isLive && isOn) {
                        // Load is on but circuit is dead
                        statusText.textContent = circuitStatus.message;
                        statusText.style.color = '#d9534f';
                    } else if (isOn) {
                        const loadWatts = getLoadWatts(item);
                        statusText.textContent = `Drawing ${loadWatts}W`;
                        statusText.style.color = '#5cb85c';
                    } else {
                        if (!circuitStatus.isLive) {
                            statusText.textContent = circuitStatus.message;
                            statusText.style.color = '#d9534f';
                        } else {
                            statusText.textContent = 'Load is off';
                            statusText.style.color = '#888';
                        }
                    }
                    
                    // Update toggle button handler
                    toggleBtn.onclick = () => {
                        if (currentMode === 'simulate') {
                            toggleLoadInSimulate(item);
                        } else {
                            toggleLoad(item);
                        }
                        openInspector(item); // Refresh inspector to update button state
                    };
                } else {
                    toggleSection.classList.add('hidden');
                }
                
                // Populate preset dropdown
                const presetSelect = document.getElementById('loadPreset');
                presetSelect.innerHTML = APPLIANCE_PRESETS.map((p, i) => 
                    `<option value="${i}" ${p.name === item.specs.name ? 'selected' : ''}>${p.icon} ${p.name} (${p.voltage}V, ${p.avgWatts || 0}W)</option>`
                ).join('');
                
                document.getElementById('loadName').value = item.specs.name;
                document.getElementById('loadVoltage').value = item.specs.voltage;
                document.getElementById('loadMaxWatts').value = item.specs.maxWatts;
                document.getElementById('loadIcon').value = item.specs.icon || '‚ö°';
                
                // Behavior section
                const behavior = item.specs.behavior || { type: 'constant' };
                document.getElementById('loadBehaviorType').value = behavior.type;
                
                // Set average watts
                document.getElementById('loadAvgWatts').value = item.specs.avgWatts || 0;
                
                // Hide all behavior sections, show the active one
                document.querySelectorAll('.behavior-section').forEach(el => el.classList.add('hidden'));
                
                // Check if this is a recipe-based load (has recipes array or recipe behavior type)
                const isRecipeBased = (item.specs.recipes && item.specs.recipes.length > 0) || 
                                      behavior.type === 'recipe' || behavior.type === 'batch';
                
                if (isRecipeBased) {
                    document.getElementById('behaviorRecipe').classList.remove('hidden');
                    document.getElementById('loadBehaviorType').value = 'recipe';
                    populateRecipeList(item);
                } else {
                    // Default to simple behavior
                    document.getElementById('behaviorSimple').classList.remove('hidden');
                    document.getElementById('loadBehaviorType').value = 'simple';
                }
                
                // Hide recipe editor by default
                document.getElementById('recipeEditor').classList.add('hidden')
                
                // Populate automation list
                populateAutomationList(item);
            } else if (item.type === 'resourcecontainer') {
                document.getElementById('resourceContainerInspector').classList.remove('hidden');
                
                // Populate fields
                document.getElementById('containerName').value = item.specs.name || '';
                document.getElementById('containerResourceType').value = item.specs.resourceType || 'Generic';
                document.getElementById('containerCapacity').value = item.specs.capacity || 100;
                document.getElementById('containerValue').value = item.specs.value || 0;
                document.getElementById('containerUnit').value = item.specs.unit || 'units';
                
                // Update fill level display
                const capacity = item.specs.capacity || 100;
                const value = item.specs.value || 0;
                const percent = capacity > 0 ? Math.min(100, (value / capacity) * 100) : 0;
                document.getElementById('containerFillPercent').textContent = `${percent.toFixed(1)}%`;
                document.getElementById('containerFillBar').style.width = `${percent}%`;
            }
        }
        
        // Helper function to populate automation list in inspector
        function populateAutomationList(item) {
            const automationList = document.getElementById('automationList');
            const automations = item.automations || [];
            
            let html = '';
            
            automations.forEach((automation, i) => {
                let triggerDesc = '';
                if (automation.triggerType === 'timeOfDay') {
                    // For startRecipe, show just the start time; for on/off show the range
                    if (automation.action === 'startRecipe') {
                        triggerDesc = `at ${String(automation.startHour || 12).padStart(2, '0')}:00`;
                    } else {
                        triggerDesc = `Time: ${automation.startHour || 18}:00 - ${automation.endHour || 6}:00`;
                    }
                } else if (automation.triggerType === 'batteryLevel') {
                    triggerDesc = `Battery ${automation.condition || 'above'} ${automation.threshold || 0}% (${automation.targetNodeLabel || 'N/A'})`;
                } else if (automation.triggerType === 'solarInput') {
                    triggerDesc = `Solar ${automation.condition || 'aboveZero'} (${automation.targetNodeLabel || 'N/A'})`;
                } else if (automation.triggerType === 'containerValue') {
                    triggerDesc = `Container ${automation.condition || 'above'} ${automation.threshold || 0} (${automation.targetNodeLabel || 'N/A'})`;
                }
                
                // Determine action display text and color
                let actionText = 'Turn ON';
                let actionColor = '#5bc0de';
                if (automation.action === 'turnOff') {
                    actionText = 'Turn OFF';
                    actionColor = '#d9534f';
                } else if (automation.action === 'startRecipe') {
                    // Find recipe name if available
                    const recipes = item.specs.recipes || [];
                    const recipeIdx = automation.recipeIndex || 0;
                    const recipe = recipes[recipeIdx];
                    const recipeName = recipe ? recipe.name : `Recipe #${recipeIdx + 1}`;
                    actionText = `Start "${recipeName}"`;
                    actionColor = '#f0ad4e';
                }
                
                html += `
                    <div class="automation-item" style="padding: 6px; margin-bottom: 4px; background: #252525; border-radius: 3px; font-size: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="color: ${actionColor};">${actionText}</strong>
                                <span style="color: #888; margin-left: 8px;">when</span>
                                <span style="color: #aaa;">${triggerDesc}</span>
                            </div>
                            <div style="display: flex; gap: 4px;">
                                <button class="edit-automation-btn" data-index="${i}" style="background: #5bc0de; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">Edit</button>
                                <button class="remove-automation-btn" data-index="${i}" style="background: #d9534f; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">√ó</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            if (automations.length === 0) {
                html = '<p style="color: #666; font-size: 10px; text-align: center; padding: 10px;">No automation rules defined</p>';
            }
            
            automationList.innerHTML = html;
            
            // Attach remove handlers
            automationList.querySelectorAll('.remove-automation-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    if (item.automations) {
                        item.automations.splice(idx, 1);
                        populateAutomationList(item);
                        render();
                    }
                };
            });
            
            // Attach edit handlers
            automationList.querySelectorAll('.edit-automation-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    openAutomationEditor(item, idx);
                };
            });
        }
        
        // Open automation editor for editing or creating new automation
        function openAutomationEditor(item, index = null) {
            const editor = document.getElementById('automationEditor');
            editor.classList.remove('hidden');
            
            // Populate battery dropdown
            const batterySelect = document.getElementById('automationBatteryLabel');
            const batteries = allItems.filter(i => i.type === 'battery');
            batterySelect.innerHTML = '<option value="">Select Battery...</option>' +
                batteries.map(b => `<option value="${b.specs.name || b.label || b.id}">${b.specs.name || b.label || b.id}</option>`).join('');
            
            // Populate recipe dropdown if item has recipes
            const recipeSelect = document.getElementById('automationRecipeSelect');
            const recipes = item.specs.recipes || [];
            if (recipes.length > 0) {
                recipeSelect.innerHTML = recipes.map((r, idx) => {
                    const durationStr = r.durationHours ? `${(r.durationHours * 60).toFixed(0)} min` : 'N/A';
                    const energyStr = r.energyWh ? `${r.energyWh} Wh` : 'N/A';
                    return `<option value="${idx}">${r.name || `Recipe ${idx + 1}`} (${durationStr}, ${energyStr})</option>`;
                }).join('');
            } else {
                recipeSelect.innerHTML = '<option value="">-- No recipes available --</option>';
            }
            
            // If editing existing automation, populate fields
            if (index !== null && item.automations && item.automations[index]) {
                const automation = item.automations[index];
                document.getElementById('automationAction').value = automation.action || 'turnOn';
                document.getElementById('automationTriggerType').value = automation.triggerType || 'timeOfDay';
                
                // Populate fields based on trigger type
                if (automation.triggerType === 'timeOfDay') {
                    document.getElementById('automationStartHour').value = automation.startHour || 18;
                    document.getElementById('automationEndHour').value = automation.endHour || 6;
                } else if (automation.triggerType === 'batteryLevel') {
                    batterySelect.value = automation.targetNodeLabel || '';
                    document.getElementById('automationBatteryCondition').value = automation.condition || 'above';
                    document.getElementById('automationBatteryThreshold').value = automation.threshold || 80;
                } else if (automation.triggerType === 'solarInput') {
                    document.getElementById('automationSolarLabel').value = automation.targetNodeLabel || '';
                    document.getElementById('automationSolarCondition').value = automation.condition || 'aboveZero';
                } else if (automation.triggerType === 'containerValue') {
                    document.getElementById('automationContainerLabel').value = automation.targetNodeLabel || '';
                    document.getElementById('automationContainerCondition').value = automation.condition || 'above';
                    document.getElementById('automationContainerThreshold').value = automation.threshold || 10;
                }
                
                // If action is startRecipe, populate recipe index
                if (automation.action === 'startRecipe') {
                    recipeSelect.value = automation.recipeIndex !== undefined ? automation.recipeIndex : 0;
                    updateRecipeDetails(item, automation.recipeIndex || 0);
                }
            } else {
                // New automation - set defaults
                document.getElementById('automationAction').value = 'turnOn';
                document.getElementById('automationTriggerType').value = 'timeOfDay';
                document.getElementById('automationStartHour').value = 18;
                document.getElementById('automationEndHour').value = 6;
                batterySelect.value = '';
                document.getElementById('automationBatteryCondition').value = 'above';
                document.getElementById('automationBatteryThreshold').value = 80;
                document.getElementById('automationSolarLabel').value = '';
                document.getElementById('automationSolarCondition').value = 'aboveZero';
                document.getElementById('automationContainerLabel').value = '';
                document.getElementById('automationContainerCondition').value = 'above';
                document.getElementById('automationContainerThreshold').value = 10;
            }
            
            // Show/hide appropriate fields
            updateAutomationFields();
            
            // Store the item and index for save handler
            editor.dataset.itemId = item.id;
            editor.dataset.automationIndex = index !== null ? index : 'new';
        }
        
        // Update which parameter fields are visible based on trigger type and action
        function updateAutomationFields() {
            const triggerType = document.getElementById('automationTriggerType').value;
            const actionType = document.getElementById('automationAction').value;
            
            // Hide all trigger fields
            document.querySelectorAll('.automation-param-fields').forEach(f => f.classList.add('hidden'));
            
            // Hide all action fields
            document.querySelectorAll('.automation-action-fields').forEach(f => f.classList.add('hidden'));
            
            // Show appropriate trigger fields
            if (triggerType === 'timeOfDay') {
                document.getElementById('automationTimeFields').classList.remove('hidden');
            } else if (triggerType === 'batteryLevel') {
                document.getElementById('automationBatteryFields').classList.remove('hidden');
            } else if (triggerType === 'solarInput') {
                document.getElementById('automationSolarFields').classList.remove('hidden');
            } else if (triggerType === 'containerValue') {
                document.getElementById('automationContainerFields').classList.remove('hidden');
            }
            
            // Show recipe selection if action is startRecipe
            if (actionType === 'startRecipe') {
                document.getElementById('automationRecipeFields').classList.remove('hidden');
                
                // Update recipe details for currently selected recipe
                const editor = document.getElementById('automationEditor');
                const itemId = editor.dataset.itemId;
                const item = allItems.find(i => i.id === itemId);
                if (item) {
                    const recipeIdx = parseInt(document.getElementById('automationRecipeSelect').value) || 0;
                    updateRecipeDetails(item, recipeIdx);
                }
            }
        }
        
        // Update recipe details display when recipe selection changes
        function updateRecipeDetails(item, recipeIndex) {
            const detailsDiv = document.getElementById('automationRecipeDetails');
            const recipes = item ? item.specs.recipes : null;
            
            if (!recipes || recipes.length === 0 || recipeIndex < 0 || recipeIndex >= recipes.length) {
                detailsDiv.innerHTML = 'Select a recipe to see details';
                return;
            }
            
            const recipe = recipes[recipeIndex];
            const durationHours = recipe.durationHours || 0;
            const durationMin = durationHours * 60;
            const energyWh = recipe.energyWh || 0;
            const powerWatts = durationHours > 0 ? (energyWh / durationHours).toFixed(0) : 0;
            
            // Format inputs with hourly rates
            const inputsStr = (recipe.inputs || []).map(inp => {
                const total = inp.amount || 0;
                const hourlyRate = durationHours > 0 ? (total / durationHours).toFixed(2) : total;
                return `${total} ${inp.unit || ''} ${inp.resourceType || 'item'} (${hourlyRate}/hr)`;
            }).join(', ') || 'None';
            
            // Format outputs
            const outputsStr = (recipe.outputs || []).map(out => 
                `${out.amount} ${out.unit || ''} ${out.resourceType || 'item'}`
            ).join(', ') || 'None';
            
            detailsDiv.innerHTML = `
                <div style="margin-bottom: 4px;"><strong style="color: #f0ad4e;">${recipe.name || 'Unnamed Recipe'}</strong></div>
                <div>‚è±Ô∏è Duration: ${durationMin.toFixed(0)} min (${durationHours.toFixed(2)} hrs)</div>
                <div>‚ö° Energy: ${energyWh} Wh total @ ~${powerWatts}W avg</div>
                <div style="color: #5cb85c;">üì• Inputs: ${inputsStr}</div>
                <div style="color: #5bc0de;">üì§ Outputs: ${outputsStr}</div>
                <div style="color: #888; font-size: 9px; margin-top: 4px; font-style: italic;">
                    Resources consumed gradually each hour during processing
                </div>
            `;
        }
        
        // Helper function to populate recipe list in inspector
        function populateRecipeList(item) {
            const recipeList = document.getElementById('recipeList');
            const recipes = item.specs.recipes || [];
            
            let html = '';
            
            recipes.forEach((recipe, i) => {
                // Format inputs and outputs for display
                const inputsStr = (recipe.inputs || []).map(inp => 
                    `${inp.amount} ${inp.unit || ''} ${inp.resourceType || inp.name || 'item'}`
                ).join(', ') || 'None';
                
                const outputsStr = (recipe.outputs || []).map(out => 
                    `${out.amount} ${out.unit || ''} ${out.resourceType || out.name || 'item'}`
                ).join(', ') || 'None';
                
                html += `
                    <div class="recipe-item" style="padding: 8px; margin-bottom: 6px; background: #252525; border-radius: 4px; font-size: 11px; border-left: 3px solid #f0ad4e;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <strong style="color: #f0ad4e;">${recipe.name || 'Unnamed Recipe'}</strong>
                            <div style="display: flex; gap: 4px;">
                                <button class="edit-recipe-btn" data-index="${i}" style="background: #5bc0de; border: none; color: white; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">Edit</button>
                                <button class="remove-recipe-btn" data-index="${i}" style="background: #d9534f; border: none; color: white; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">√ó</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>‚ö° ${recipe.energyWh || 0} Wh</span>
                            <span>‚è±Ô∏è ${recipe.durationHours ? (recipe.durationHours * 60).toFixed(0) : recipe.durationMin || 0} min</span>
                        </div>
                        <div style="color: #5cb85c; font-size: 10px;">üì• ${inputsStr}</div>
                        <div style="color: #5bc0de; font-size: 10px;">üì§ ${outputsStr}</div>
                    </div>
                `;
            });
            
            if (recipes.length === 0) {
                html = '<p style="color: #666; font-size: 11px; text-align: center; padding: 15px;">No recipes defined.<br>Click "+ Add Recipe" to create one.</p>';
            }
            
            recipeList.innerHTML = html;
            
            // Attach edit handlers
            recipeList.querySelectorAll('.edit-recipe-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    openRecipeEditor(item, idx);
                };
            });
            
            // Attach remove handlers
            recipeList.querySelectorAll('.remove-recipe-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    if (item.specs.recipes) {
                        item.specs.recipes.splice(idx, 1);
                        regeneratePortsForLoad(item);
                    }
                    populateRecipeList(item);
                    render();
                };
            });
        }
        
        // Open the inline recipe editor
        function openRecipeEditor(item, recipeIndex = null) {
            const editor = document.getElementById('recipeEditor');
            editor.classList.remove('hidden');
            editor.dataset.itemId = item.id;
            editor.dataset.recipeIndex = recipeIndex !== null ? recipeIndex : 'new';
            
            // Get recipe data or defaults
            const recipe = recipeIndex !== null && item.specs.recipes?.[recipeIndex] 
                ? item.specs.recipes[recipeIndex] 
                : { name: '', durationMin: 60, energyWh: 100, inputs: [], outputs: [] };
            
            document.getElementById('recipeEditorName').value = recipe.name || '';
            document.getElementById('recipeEditorDuration').value = recipe.durationHours ? recipe.durationHours * 60 : (recipe.durationMin || 60);
            document.getElementById('recipeEditorEnergy').value = recipe.energyWh || 100;
            
            // Populate inputs
            populateRecipeIOList('recipeEditorInputs', recipe.inputs || [], 'input');
            
            // Populate outputs
            populateRecipeIOList('recipeEditorOutputs', recipe.outputs || [], 'output');
        }
        
        // Populate input/output list in recipe editor
        function populateRecipeIOList(containerId, items, type) {
            const container = document.getElementById(containerId);
            let html = '';
            
            items.forEach((item, i) => {
                html += createRecipeIORow(item, i, type);
            });
            
            if (items.length === 0) {
                html = `<p style="color: #555; font-size: 10px; text-align: center; margin: 5px 0;">No ${type}s</p>`;
            }
            
            container.innerHTML = html;
            
            // Attach remove handlers
            container.querySelectorAll('.remove-io-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    btn.closest('.io-row').remove();
                };
            });
        }
        
        // Create a single input/output row HTML
        function createRecipeIORow(item, index, type) {
            const resourceOptions = Object.values(RESOURCE_TYPES).map(rt => 
                `<option value="${rt}" ${item.resourceType === rt ? 'selected' : ''}>${rt}</option>`
            ).join('');
            
            return `
                <div class="io-row" style="display: flex; gap: 4px; margin-bottom: 4px; align-items: center;">
                    <select class="io-resource" style="flex: 1; padding: 2px; font-size: 10px;">
                        ${resourceOptions}
                    </select>
                    <input type="number" class="io-amount" value="${item.amount || 1}" min="0" step="0.1" style="width: 50px; padding: 2px; font-size: 10px;">
                    <button class="remove-io-btn" style="background: #d9534f; border: none; color: white; padding: 2px 5px; border-radius: 2px; cursor: pointer; font-size: 9px;">√ó</button>
                </div>
            `;
        }
        
        // Add a new input/output row
        function addRecipeIORow(containerId, type) {
            const container = document.getElementById(containerId);
            
            // Remove "no items" message if present
            const noItemsMsg = container.querySelector('p');
            if (noItemsMsg) noItemsMsg.remove();
            
            const defaultResource = type === 'input' ? RESOURCE_TYPES.BIOMASS : RESOURCE_TYPES.BIOCHAR;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = createRecipeIORow({ resourceType: defaultResource, amount: 1 }, 0, type);
            const newRow = tempDiv.firstElementChild;
            container.appendChild(newRow);
            
            // Attach remove handler
            newRow.querySelector('.remove-io-btn').onclick = (e) => {
                e.stopPropagation();
                newRow.remove();
            };
        }
        
        // Collect inputs/outputs from the editor
        function collectRecipeIO(containerId) {
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('.io-row');
            const items = [];
            
            rows.forEach(row => {
                const resourceType = row.querySelector('.io-resource').value;
                const amount = parseFloat(row.querySelector('.io-amount').value) || 0;
                const unit = getDefaultUnitForResource(resourceType);
                
                if (amount > 0) {
                    items.push({ resourceType, amount, unit });
                }
            });
            
            return items;
        }
        
        function openWireInspector(conn) {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.add('open');
            
            // Hide all inspectors
            document.getElementById('inspectorEmpty').classList.add('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
            document.getElementById('resourceContainerInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.remove('hidden');
            
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            const targetItem = allItems.find(i => i.id === conn.targetItemId);
            
            document.getElementById('wireInfo').textContent = 
                `${sourceItem?.type || 'Unknown'} ‚Üí ${targetItem?.type || 'Unknown'} (${conn.polarity})`;
            
            // Calculate expected current for this wire
            const expectedCurrent = calculateWireCurrent(conn);
            const recommendedBreaker = autosizeBreaker(expectedCurrent);
            document.getElementById('wireCurrentInfo').textContent = 
                expectedCurrent > 0 ? `Expected current: ~${expectedCurrent.toFixed(1)}A | Recommended breaker: ${recommendedBreaker}A` : '';
            
            // Initialize wire properties if they don't exist (for old connections)
            if (!conn.wireGauge) {
                updateWireGaugeForConnection(conn);
            }
            
            // Update wire gauge display
            const wireSpec = WIRE_GAUGE_SPECS[conn.wireGauge] || WIRE_GAUGE_SPECS['10'];
            document.getElementById('wireGaugeDisplay').value = wireSpec.name;
            document.getElementById('wireAmpsDisplay').value = `${conn.wireAmps?.toFixed(1) || '0.0'} A`;
            
            // Set length input
            const lengthInput = document.getElementById('wireLengthInput');
            lengthInput.value = conn.estimatedLength || 10;
            
            // Set cost per foot input
            const costPerFootInput = document.getElementById('wireCostPerFootInput');
            costPerFootInput.value = conn.costPerFoot || WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
            
            // Calculate and display total cost
            updateWireCostDisplay(conn);
            
            // Store current connection for event handlers
            if (!window.currentWireInspectorConn) {
                window.currentWireInspectorConn = null;
            }
            window.currentWireInspectorConn = conn;
            
            // Remove existing event listeners (if any) and add new ones
            const lengthInputNew = document.getElementById('wireLengthInput');
            const costPerFootInputNew = document.getElementById('wireCostPerFootInput');
            const recalcBtn = document.getElementById('recalculateWireLength');
            
            // Clone and replace to remove old listeners
            const newLengthInput = lengthInputNew.cloneNode(true);
            const newCostInput = costPerFootInputNew.cloneNode(true);
            const newRecalcBtn = recalcBtn.cloneNode(true);
            
            lengthInputNew.parentNode.replaceChild(newLengthInput, lengthInputNew);
            costPerFootInputNew.parentNode.replaceChild(newCostInput, costPerFootInputNew);
            recalcBtn.parentNode.replaceChild(newRecalcBtn, recalcBtn);
            
            // Set values again
            newLengthInput.value = conn.estimatedLength || 10;
            newCostInput.value = conn.costPerFoot || WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
            
            // Add event listeners
            newLengthInput.addEventListener('change', function() {
                const length = parseFloat(this.value) || 0;
                conn.estimatedLength = Math.max(0, length);
                updateWireCostDisplay(conn);
                render();
            });
            
            newCostInput.addEventListener('change', function() {
                const cost = parseFloat(this.value) || 0;
                conn.costPerFoot = Math.max(0, cost);
                updateWireCostDisplay(conn);
                render();
            });
            
            newRecalcBtn.addEventListener('click', function() {
                if (sourceItem && targetItem) {
                    const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                    const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                    if (sourceHandle && targetHandle) {
                        const newLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
                        conn.estimatedLength = newLength;
                        newLengthInput.value = newLength;
                        updateWireCostDisplay(conn);
                        render();
                    }
                }
            });
        }
        
        // Calculate wire resistance based on gauge and length
        function calculateWireResistance(conn) {
            if (!conn || !conn.wireGauge) {
                return 0;
            }
            
            const wireSpec = WIRE_GAUGE_SPECS[conn.wireGauge];
            if (!wireSpec || !wireSpec.resistancePer1000ft) {
                return 0;
            }
            
            // Resistance = (resistance per 1000ft) * (length in feet / 1000)
            const lengthFeet = conn.estimatedLength || 0;
            const resistance = (wireSpec.resistancePer1000ft * lengthFeet) / 1000;
            
            return resistance;
        }
        
        // Calculate power loss over wire: P_loss = I¬≤ √ó R
        function calculateWirePowerLoss(conn) {
            if (!conn) {
                return 0;
            }
            
            // Get current (use wireAmps if available, otherwise calculate)
            const currentAmps = conn.wireAmps || calculateWireCurrent(conn) || 0;
            
            // Get resistance
            const resistance = calculateWireResistance(conn);
            
            // Power loss = I¬≤ √ó R
            const powerLoss = Math.pow(currentAmps, 2) * resistance;
            
            return powerLoss;
        }
        
        // Update wire cost display in inspector
        function updateWireCostDisplay(conn) {
            if (!conn) return;
            const totalCost = (conn.estimatedLength || 0) * (conn.costPerFoot || 0);
            conn.totalWireCost = totalCost;
            document.getElementById('wireTotalCostDisplay').value = `$${totalCost.toFixed(2)}`;
            
            // Update power loss display
            const resistance = calculateWireResistance(conn);
            const powerLoss = calculateWirePowerLoss(conn);
            
            const resistanceDisplay = document.getElementById('wireResistanceDisplay');
            const powerLossDisplay = document.getElementById('wirePowerLossDisplay');
            
            if (resistanceDisplay) {
                resistanceDisplay.value = resistance > 0 ? `${resistance.toFixed(4)} Œ©` : '0.0000 Œ©';
            }
            
            if (powerLossDisplay) {
                powerLossDisplay.value = powerLoss > 0 ? `${powerLoss.toFixed(2)} W` : '0.00 W';
            }
        }
        
        function calculateWireCurrent(conn, visited = new Set()) {
            // Prevent infinite recursion
            const connKey = `${conn.sourceItemId}-${conn.sourceHandleId}`;
            if (visited.has(connKey)) return 0;
            visited.add(connKey);
            
            // Trace back to find the source panel(s) and calculate expected current
            const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
            if (!sourceItem) return 0;
            
            // Handle panel connections
            if (sourceItem.type === 'panel') {
                // Single panel - return its Imp
                return sourceItem.specs.imp || sourceItem.specs.isc * 0.9;
            }
            
            // Handle controller connections
            if (sourceItem.type === 'controller') {
                // For PV connections, calculate array current
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && (sourceHandle.polarity === 'pv-positive' || sourceHandle.polarity === 'pv-negative')) {
                    const arraySpecs = calculateConnectedArraySpecs(sourceItem);
                    return arraySpecs.imp || 0;
                }
                // For battery connections, use controller charge current
                if (sourceHandle && (sourceHandle.polarity === 'battery-positive' || sourceHandle.polarity === 'battery-negative')) {
                    return sourceItem.specs.ratedChargeCurrent || 0;
                }
                // For AC output
                if (sourceHandle && sourceHandle.polarity === 'ac') {
                    const maxACWatts = sourceItem.specs.maxACOutputW || 0;
                    const acVoltage = 120; // Default, could be determined from connection
                    return maxACWatts / acVoltage;
                }
            }
            
            // Handle battery connections
            if (sourceItem.type === 'battery') {
                // Battery discharge current - estimate based on max discharge
                const maxDischarge = sourceItem.specs.maxDischarge || sourceItem.specs.ah || 0;
                return maxDischarge; // Amps
            }
            
            // Handle combiner connections
            if (sourceItem.type === 'combiner' || sourceItem.type === 'solarcombiner') {
                // Sum currents from all connected inputs
                let totalCurrent = 0;
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && sourceHandle.id.includes('-out-')) {
                    // Output handle - sum all input currents
                    Object.values(sourceItem.handles).forEach(handle => {
                        if (handle.inputIndex !== undefined) {
                            handle.connectedTo.forEach(inputConn => {
                                const inputItem = allItems.find(i => i.id === inputConn.itemId);
                                if (inputItem) {
                                    // Recursively calculate current from input
                                    const tempConn = {
                                        sourceItemId: inputItem.id,
                                        sourceHandleId: inputConn.handleId
                                    };
                                    totalCurrent += calculateWireCurrent(tempConn, visited);
                                }
                            });
                        }
                    });
                }
                return totalCurrent;
            }
            
            // Handle breaker connections (if closed)
            if (sourceItem.type === 'breaker' && sourceItem.isClosed) {
                // Trace through breaker to source
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                if (sourceHandle && sourceHandle.id.includes('-load-')) {
                    // Load side - trace to line side
                    const lineHandle = sourceHandle.polarity === 'positive' ? 
                        sourceItem.handles.linePositive : sourceItem.handles.lineNegative;
                    if (lineHandle && lineHandle.connectedTo.length > 0) {
                        const lineConn = lineHandle.connectedTo[0];
                        const lineItem = allItems.find(i => i.id === lineConn.itemId);
                        if (lineItem) {
                            const tempConn = {
                                sourceItemId: lineItem.id,
                                sourceHandleId: lineConn.handleId
                            };
                            return calculateWireCurrent(tempConn, visited);
                        }
                    }
                }
            }
            
            // Handle outlet connections - don't trace through outlets to prevent loops
            if (sourceItem.type === 'acoutlet') {
                return 0; // Outlets don't generate current, they pass it through
            }
            
            // Default: try to trace through connection
            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
            if (sourceHandle && sourceHandle.connectedTo.length > 0) {
                // Try to get current from connected source
                const connectedItem = allItems.find(i => i.id === sourceHandle.connectedTo[0].itemId);
                if (connectedItem && connectedItem.type !== 'acoutlet') { // Skip outlets to prevent loops
                    const tempConn = {
                        sourceItemId: connectedItem.id,
                        sourceHandleId: sourceHandle.connectedTo[0].handleId
                    };
                    return calculateWireCurrent(tempConn, visited);
                }
            }
            
            return 0;
        }
        
        // Estimate wire length in feet based on component positions
        // Get scale factor (pixels per meter) from panels
        // Uses panel dimensions to determine scale: 1 meter (1000mm) = baseScale pixels
        function getScaleFactor() {
            const panels = allItems.filter(i => i.type === 'panel');
            if (panels.length === 0) {
                // Default scale: 1 meter = 120 pixels
                return 120;
            }
            
            // Use the average scale factor from all panels
            // Each panel has a scaleFactor: pixels per meter
            let totalScale = 0;
            let count = 0;
            panels.forEach(panel => {
                if (panel.specs && panel.specs.scaleFactor) {
                    totalScale += panel.specs.scaleFactor;
                    count++;
                }
            });
            
            if (count > 0) {
                return totalScale / count;
            }
            
            // Fallback: calculate from first panel's dimensions
            const firstPanel = panels[0];
            if (firstPanel.specs && firstPanel.specs.height) {
                const panelHeightMm = firstPanel.specs.height;
                const panelHeightPx = firstPanel.height;
                // Scale: panelHeightPx pixels represents panelHeightMm mm
                // So pixels per meter = panelHeightPx / (panelHeightMm / 1000)
                return panelHeightPx / (panelHeightMm / 1000);
            }
            
            // Ultimate fallback
            return 120; // 120 pixels per meter
        }
        
        function estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle) {
            if (!sourceItem || !targetItem || !sourceHandle || !targetHandle) {
                return 10; // Default fallback
            }
            
            // Get handle positions
            const start = getHandlePosition(sourceItem, sourceHandle);
            const end = getHandlePosition(targetItem, targetHandle);
            
            // Calculate Euclidean distance in pixels
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const straightDistancePx = Math.sqrt(dx * dx + dy * dy);
            
            // Get scale factor (pixels per meter) from panel dimensions
            const pixelsPerMeter = getScaleFactor();
            
            // Convert pixels to meters, then to feet
            const straightMeters = straightDistancePx / pixelsPerMeter;
            const metersToFeet = 3.28084; // 1 meter = 3.28084 feet
            const straightFeet = straightMeters * metersToFeet;
            
            // Add routing overhead (25% for wire routing, bends, etc.)
            const routingOverhead = 1.25;
            const estimatedFeet = straightFeet * routingOverhead;
            
            // Round to 1 decimal place, minimum 1 foot
            return Math.max(1, Math.round(estimatedFeet * 10) / 10);
        }
        
        // Update wire gauge for a connection based on current system specs
        function updateWireGaugeForConnection(conn) {
            if (!conn) return;
            
            // Calculate current operating amperage
            const currentAmps = calculateWireCurrent(conn);
            
            // Get appropriate wire gauge
            const wireSpec = getWireGaugeForAmps(currentAmps);
            
            // Update connection properties
            conn.wireAmps = currentAmps;
            conn.wireGauge = wireSpec.gauge;
            
            // Update cost if costPerFoot exists, otherwise use default
            if (!conn.costPerFoot) {
                conn.costPerFoot = WIRE_COST_PER_FOOT[wireSpec.gauge] || WIRE_COST_PER_FOOT['10'];
            }
            
            // Recalculate total wire cost
            if (conn.estimatedLength) {
                conn.totalWireCost = conn.estimatedLength * conn.costPerFoot;
            }
        }
        
        // Update all wire gauges when system specs change
        function updateAllWireGauges() {
            connections.forEach(conn => {
                updateWireGaugeForConnection(conn);
            });
        }
        
        function closeInspector() {
            const sidebar = document.getElementById('right-sidebar');
            sidebar.classList.remove('open');
            
            document.getElementById('inspectorEmpty').classList.remove('hidden');
            document.getElementById('panelInspector').classList.add('hidden');
            document.getElementById('batteryInspector').classList.add('hidden');
            document.getElementById('controllerInspector').classList.add('hidden');
            document.getElementById('wireInspector').classList.add('hidden');
            document.getElementById('breakerInspector').classList.add('hidden');
            document.getElementById('combinerInspector').classList.add('hidden');
            document.getElementById('solarCombinerInspector').classList.add('hidden');
            document.getElementById('spiderboxInspector').classList.add('hidden');
            document.getElementById('breakerpanelInspector').classList.add('hidden');
            document.getElementById('acloadInspector').classList.add('hidden');
            document.getElementById('resourceContainerInspector').classList.add('hidden');
        }
        
        // ============================================
        // VALIDATION & SCORING
        // ============================================
        
        let systemValidated = false;
        
        // ============================================
        // PHASE 6: FAULT DETECTION AND PROTECTION SYSTEM
        // ============================================
        
        // Fault detection system
        function detectFaults() {
            const faults = [];
            const warnings = [];
            
            // Check all controllers
            const controllers = allItems.filter(i => i.type === 'controller');
            controllers.forEach(controller => {
                // Skip if already destroyed
                if (controller.destroyed) return;
                
                const arraySpecs = calculateConnectedArraySpecs(controller);
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                
                // FAULT 1: Array VOC > controller limit (already handled, but ensure it's in fault list)
                if (arraySpecs.voc > controller.specs.maxVoc) {
                    if (!controller.destroyed) {
                        faults.push({
                            type: 'controller_voc_overload',
                            controller: controller,
                            actualVoltage: arraySpecs.voc,
                            maxVoltage: controller.specs.maxVoc
                        });
                    }
                }
                
                // FAULT 2: 48V battery to 12V controller (voltage mismatch)
                if (batterySpecs.voltage > 0) {
                    const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
                    const maxSupportedVoltage = Math.max(...supportedVoltages);
                    const nominalBatteryVoltage = Math.round(batterySpecs.voltage / 12) * 12;
                    
                    // Check if battery voltage significantly exceeds max supported (e.g., 48V on 12V-only controller)
                    if (batterySpecs.voltage > maxSupportedVoltage + 10 && !controller.destroyed) {
                        faults.push({
                            type: 'controller_battery_overvoltage',
                            controller: controller,
                            batteryVoltage: batterySpecs.voltage,
                            maxSupportedVoltage: maxSupportedVoltage
                        });
                    }
                    
                    // WARNING: Incompatible battery voltage (not fatal, but won't work)
                    if (!supportedVoltages.includes(nominalBatteryVoltage) && batterySpecs.voltage > 12 && batterySpecs.voltage <= maxSupportedVoltage + 10) {
                        warnings.push({
                            type: 'incompatible_battery_voltage',
                            controller: controller,
                            batteryVoltage: nominalBatteryVoltage,
                            supportedVoltages: supportedVoltages
                        });
                    }
                }
                
                // FAULT 3: Battery reverse polarity (check connections)
                const battPosConn = controller.handles?.batteryPositive?.connectedTo || [];
                const battNegConn = controller.handles?.batteryNegative?.connectedTo || [];
                
                if (battPosConn.length > 0 && battNegConn.length > 0) {
                    // Check if positive handle is connected to negative terminal and vice versa
                    for (const posConn of battPosConn) {
                        const posBattery = allItems.find(i => i.id === posConn.itemId && i.type === 'battery');
                        if (posBattery) {
                            const posHandle = Object.values(posBattery.handles).find(h => h.id === posConn.handleId);
                            if (posHandle && posHandle.polarity === 'negative') {
                                // Reverse polarity detected!
                                if (!controller.destroyed) {
                                    faults.push({
                                        type: 'battery_reverse_polarity',
                                        controller: controller,
                                        battery: posBattery
                                    });
                                }
                            }
                        }
                    }
                }
                
                // WARNING: Reversed solar panel polarity
                const pvPosConn = controller.handles?.pvPositive?.connectedTo || [];
                const pvNegConn = controller.handles?.pvNegative?.connectedTo || [];
                
                if (pvPosConn.length > 0 && pvNegConn.length > 0) {
                    // Check if PV+ is connected to panel negative and PV- to panel positive
                    for (const posConn of pvPosConn) {
                        const posPanel = allItems.find(i => i.id === posConn.itemId && i.type === 'panel');
                        if (posPanel) {
                            const posHandle = Object.values(posPanel.handles).find(h => h.id === posConn.handleId);
                            if (posHandle && posHandle.polarity === 'negative') {
                                warnings.push({
                                    type: 'reversed_panel_polarity',
                                    controller: controller,
                                    panel: posPanel
                                });
                            }
                        }
                    }
                }
                
                // WARNING: Array IMP too high (clipping)
                if (arraySpecs.imp > controller.specs.maxIsc) {
                    warnings.push({
                        type: 'array_imp_clipping',
                        controller: controller,
                        actualImp: arraySpecs.imp,
                        maxIsc: controller.specs.maxIsc
                    });
                }
            });
            
            // Check all AC loads
            const acLoads = allItems.filter(i => i.type === 'acload');
            acLoads.forEach(load => {
                if (load.destroyed) return;
                
                // FAULT 4: 120VAC load to 240V line
                if (load.specs.voltage === 120) {
                    // Find the circuit this load is on
                    const loadConn = connections.find(c => 
                        (c.sourceItemId === load.id && c.polarity === 'load') ||
                        (c.targetItemId === load.id && c.polarity === 'load')
                    );
                    
                    if (loadConn) {
                        // Trace back to find the voltage source
                        const sourceItem = allItems.find(i => 
                            i.id === (loadConn.sourceItemId === load.id ? loadConn.targetItemId : loadConn.sourceItemId)
                        );
                        
                        if (sourceItem) {
                            let circuitVoltage = null;
                            
                            // Check if connected to outlet
                            if (sourceItem.type === 'acoutlet' && sourceItem.specs.voltage) {
                                circuitVoltage = sourceItem.specs.voltage;
                            }
                            // Check if connected to breaker panel
                            else if (sourceItem.type === 'breakerpanel') {
                                const circuitHandle = Object.values(sourceItem.handles).find(h => 
                                    h.circuitName && loadConn.sourceHandleId === h.id || loadConn.targetHandleId === h.id
                                );
                                if (circuitHandle && circuitHandle.voltage) {
                                    circuitVoltage = circuitHandle.voltage;
                                }
                            }
                            // Check if connected to spiderbox
                            else if (sourceItem.type === 'spiderbox') {
                                const circuitHandle = Object.values(sourceItem.handles).find(h => 
                                    h.circuitName && loadConn.sourceHandleId === h.id || loadConn.targetHandleId === h.id
                                );
                                if (circuitHandle && circuitHandle.voltage) {
                                    circuitVoltage = circuitHandle.voltage;
                                }
                            }
                            // Check if connected to AC breaker
                            else if (sourceItem.type === 'acbreaker' && sourceItem.specs.voltage) {
                                circuitVoltage = sourceItem.specs.voltage;
                            }
                            // Check if connected to double voltage hub
                            else if (sourceItem.type === 'doublevoltagehub') {
                                const hubAcOutputHandle = sourceItem.handles?.acOutput;
                                if (hubAcOutputHandle && 
                                    (loadConn.sourceHandleId === hubAcOutputHandle.id || loadConn.targetHandleId === hubAcOutputHandle.id)) {
                                    circuitVoltage = 240; // Double voltage hub outputs 240V
                                }
                            }
                            
                            // If 120V load is on 240V circuit, it will explode
                            if (circuitVoltage === 240 && LiveView.state.active && LiveView.state.loadStates[load.id]) {
                                faults.push({
                                    type: 'load_240v_explosion',
                                    load: load,
                                    circuitVoltage: circuitVoltage
                                });
                            }
                        }
                    }
                }
            });
            
            // Check all wires for overcurrent (too-thin wire without breaker)
            connections.forEach(conn => {
                if (conn.destroyed || conn.burned) return;
                
                // Get wire current
                const currentAmps = calculateWireCurrent(conn);
                const wireSpec = conn.wireGauge ? WIRE_GAUGE_SPECS[conn.wireGauge] : getWireGaugeForAmps(currentAmps);
                
                // Check if wire is too thin for the current
                if (wireSpec && currentAmps > wireSpec.amps) {
                    // Check if there's a breaker protecting this wire
                    let hasBreaker = false;
                    
                    // Trace back to find breaker
                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                    
                    // Check if source or target is a breaker
                    if ((sourceItem && (sourceItem.type === 'acbreaker' || sourceItem.type === 'breaker')) ||
                        (targetItem && (targetItem.type === 'acbreaker' || targetItem.type === 'breaker'))) {
                        hasBreaker = true;
                    }
                    
                    // Check if wire is on a breaker panel circuit
                    if (!hasBreaker) {
                        if (sourceItem && sourceItem.type === 'breakerpanel') {
                            const circuitHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                            if (circuitHandle && circuitHandle.circuitName) {
                                // Check if circuit breaker is closed
                                const breakerId = `${sourceItem.id}-circuit-${circuitHandle.circuitName.replace('Circuit ', '')}`;
                                if (LiveView.state.breakerStates[breakerId]?.isClosed) {
                                    hasBreaker = true;
                                }
                            }
                        }
                    }
                    
                    // If no breaker and wire is overloaded, it will burn
                    if (!hasBreaker && currentAmps > wireSpec.amps * 1.2) { // 20% over rating to trigger
                        // Only check in live view when circuit is actually live
                        if (LiveView.state.active) {
                            const powerFlow = LiveView.state.powerFlow[conn.id];
                            if (powerFlow && powerFlow.isLive && powerFlow.watts > 0) {
                                faults.push({
                                    type: 'wire_overcurrent',
                                    connection: conn,
                                    currentAmps: currentAmps,
                                    wireRating: wireSpec.amps,
                                    wireGauge: wireSpec.gauge
                                });
                            }
                        }
                    }
                }
            });
            
            // Check for battery dead short (+ to - direct connection)
            batteries.forEach(battery => {
                if (battery.destroyed) return;
                
                const posHandle = battery.handles?.positive || battery.handles?.batteryPositive;
                const negHandle = battery.handles?.negative || battery.handles?.batteryNegative;
                
                if (posHandle && negHandle) {
                    // Check if positive and negative are directly connected (dead short)
                    const posConns = posHandle.connectedTo || [];
                    const negConns = negHandle.connectedTo || [];
                    
                    for (const posConn of posConns) {
                        for (const negConn of negConns) {
                            // If same connection ID, it's a direct short
                            if (posConn.connectionId === negConn.connectionId) {
                                // Check if battery has internal protection
                                const hasInternalProtection = battery.specs.hasInternalProtection !== false; // Default to true
                                
                                if (!hasInternalProtection) {
                                    faults.push({
                                        type: 'battery_dead_short',
                                        battery: battery,
                                        connection: connections.find(c => c.id === posConn.connectionId)
                                    });
                                } else {
                                    warnings.push({
                                        type: 'battery_dead_short_protected',
                                        battery: battery
                                    });
                                }
                            }
                        }
                    }
                }
            });
            
            return { faults, warnings };
        }
        
        // Process detected faults and warnings
        function processFaultsAndWarnings() {
            const { faults, warnings } = detectFaults();
            
            // Process faults (destructive)
            faults.forEach(fault => {
                switch (fault.type) {
                    case 'controller_voc_overload':
                        if (!fault.controller.destroyed) {
                            fault.controller.destroyed = true;
                            triggerOverloadEffect(fault.controller, fault.actualVoltage, fault.maxVoltage);
                        }
                        break;
                        
                    case 'controller_battery_overvoltage':
                        if (!fault.controller.destroyed) {
                            fault.controller.destroyed = true;
                            triggerBatteryOvervoltageExplosion(fault.controller, fault.batteryVoltage, fault.maxSupportedVoltage);
                        }
                        break;
                        
                    case 'battery_reverse_polarity':
                        if (!fault.controller.destroyed) {
                            fault.controller.destroyed = true;
                            triggerReversePolarityExplosion(fault.controller, fault.battery);
                        }
                        break;
                        
                    case 'load_240v_explosion':
                        if (!fault.load.destroyed) {
                            fault.load.destroyed = true;
                            triggerLoadExplosion(fault.load, fault.circuitVoltage);
                        }
                        break;
                        
                    case 'wire_overcurrent':
                        if (!fault.connection.burned) {
                            fault.connection.burned = true;
                            triggerWireBurn(fault.connection, fault.currentAmps, fault.wireRating);
                        }
                        break;
                        
                    case 'battery_dead_short':
                        if (!fault.battery.destroyed) {
                            fault.battery.destroyed = true;
                            triggerBatteryShort(fault.battery, fault.connection);
                        }
                        break;
                }
            });
            
            // Process warnings (non-destructive)
            warnings.forEach(warning => {
                switch (warning.type) {
                    case 'reversed_panel_polarity':
                        if (!warning.controller.reversedPolarityWarningShown) {
                            warning.controller.reversedPolarityWarningShown = true;
                            showHint("‚ö†Ô∏è Reversed Panel Polarity", 
                                "The solar panels are connected with reversed polarity. The array will not produce power. " +
                                "Check that PV+ is connected to panel positive terminals and PV- to negative terminals.");
                        }
                        break;
                        
                    case 'array_imp_clipping':
                        // Already handled in validateSystem, but ensure it's shown
                        break;
                        
                    case 'incompatible_battery_voltage':
                        // Already handled in validateSystem
                        break;
                        
                    case 'battery_dead_short_protected':
                        if (!warning.battery.shortCircuitWarningShown) {
                            warning.battery.shortCircuitWarningShown = true;
                            showHint("‚ö†Ô∏è Short Circuit Detected", 
                                "A dead short was detected on this battery, but internal protection prevented damage. " +
                                "Remove the short circuit connection immediately.");
                        }
                        break;
                }
            });
        }
        
        // Visual effect functions for different fault types
        function triggerBatteryOvervoltageExplosion(controller, actualVoltage, maxVoltage) {
            triggerOverloadEffect(controller, actualVoltage, maxVoltage);
            showHint("üí• Controller Destroyed!", 
                `Battery voltage (${actualVoltage.toFixed(1)}V) exceeds controller's maximum supported voltage (${maxVoltage}V). ` +
                `The controller has been destroyed. Remove batteries or use a controller that supports higher voltages.`);
        }
        
        function triggerReversePolarityExplosion(controller, battery) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Create explosion with blue/white sparks (battery-related)
            for (let i = 0; i < 25; i++) {
                const angle = (Math.PI * 2 * i) / 25;
                const distance = 40 + Math.random() * 60;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 4 + Math.random() * 5)
                    .attr("fill", Math.random() > 0.5 ? "#00a8ff" : "#ffffff")
                    .style("filter", "blur(2px)");
                
                spark.transition()
                    .duration(600 + Math.random() * 400)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash screen blue
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#0066ff")
                .style("opacity", 0.4)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake controller
            controllerGroup
                .transition().duration(50).attr("transform", `translate(${controller.x - 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            showHint("üí• Controller Destroyed!", 
                "Battery reverse polarity detected! The positive and negative terminals are swapped. " +
                "The controller has been destroyed. Disconnect the battery and reconnect with correct polarity.");
        }
        
        function triggerLoadExplosion(load, circuitVoltage) {
            const loadGroup = itemsGroup.select(`[data-id="${load.id}"]`);
            const cx = load.x + load.width / 2;
            const cy = load.y + load.height / 2;
            
            // Create explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const distance = 50 + Math.random() * 70;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 5)
                    .attr("fill", Math.random() > 0.5 ? "#ff4444" : "#ffaa00")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash screen red
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff0000")
                .style("opacity", 0.3)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake load
            loadGroup
                .transition().duration(50).attr("transform", `translate(${load.x - 5}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x + 5}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x - 3}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x + 3}, ${load.y})`)
                .transition().duration(50).attr("transform", `translate(${load.x}, ${load.y})`);
            
            // Turn off the load
            if (LiveView.state.active) {
                LiveView.state.loadStates[load.id] = false;
            }
            
            showHint("üí• Appliance Destroyed!", 
                `This 120V appliance was connected to a ${circuitVoltage}V circuit and has been destroyed. ` +
                `Always match appliance voltage to circuit voltage.`);
        }
        
        function triggerWireBurn(connection, currentAmps, wireRating) {
            // Find the wire element
            const wirePath = wiresGroup.select(`.wire-group[data-connection-id="${connection.id}"] path`);
            
            if (wirePath.empty()) return;
            
            // Change wire color to red/orange and add smoke effect
            wirePath
                .attr("stroke", "#ff4400")
                .attr("stroke-width", connection.wireGauge ? WIRE_GAUGE_SPECS[connection.wireGauge].width + 2 : 4)
                .style("filter", "url(#red-glow)");
            
            // Add smoke particles along the wire
            const sourceItem = allItems.find(i => i.id === connection.sourceItemId);
            const targetItem = allItems.find(i => i.id === connection.targetItemId);
            
            if (sourceItem && targetItem) {
                const startX = sourceItem.x + (connection.sourceHandleId ? 
                    Object.values(sourceItem.handles).find(h => h.id === connection.sourceHandleId)?.x || sourceItem.width / 2 : sourceItem.width / 2);
                const startY = sourceItem.y + (connection.sourceHandleId ? 
                    Object.values(sourceItem.handles).find(h => h.id === connection.sourceHandleId)?.y || sourceItem.height / 2 : sourceItem.height / 2);
                const endX = targetItem.x + (connection.targetHandleId ? 
                    Object.values(targetItem.handles).find(h => h.id === connection.targetHandleId)?.x || targetItem.width / 2 : targetItem.width / 2);
                const endY = targetItem.y + (connection.targetHandleId ? 
                    Object.values(targetItem.handles).find(h => h.id === connection.targetHandleId)?.y || targetItem.height / 2 : targetItem.height / 2);
                
                // Create smoke particles
                for (let i = 0; i < 15; i++) {
                    const t = Math.random();
                    const smokeX = startX + (endX - startX) * t;
                    const smokeY = startY + (endY - startY) * t;
                    
                    const smoke = zoomGroup.append("circle")
                        .attr("class", "smoke")
                        .attr("cx", smokeX)
                        .attr("cy", smokeY)
                        .attr("r", 2 + Math.random() * 3)
                        .attr("fill", "#666")
                        .style("opacity", 0.8)
                        .style("filter", "blur(3px)");
                    
                    smoke.transition()
                        .duration(1000 + Math.random() * 500)
                        .attr("cy", smokeY - 30 - Math.random() * 20)
                        .attr("r", 5 + Math.random() * 5)
                        .style("opacity", 0)
                        .remove();
                }
            }
            
            // After a delay, disconnect the wire
            setTimeout(() => {
                deleteConnection(connection.id);
                showHint("üî• Wire Burned!", 
                    `Wire (${connection.wireGauge || 'unknown'} AWG, rated ${wireRating}A) was carrying ${currentAmps.toFixed(1)}A and burned out. ` +
                    `Use thicker wire or add a breaker to protect the circuit.`);
            }, 500);
        }
        
        function triggerBatteryShort(battery, connection) {
            const batteryGroup = itemsGroup.select(`[data-id="${battery.id}"]`);
            const cx = battery.x + battery.width / 2;
            const cy = battery.y + battery.height / 2;
            
            // Create explosion with intense sparks
            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const distance = 60 + Math.random() * 80;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 5 + Math.random() * 6)
                    .attr("fill", Math.random() > 0.3 ? "#ff6600" : "#ffff00")
                    .style("filter", "blur(2px)");
                
                spark.transition()
                    .duration(700 + Math.random() * 500)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash screen orange
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff6600")
                .style("opacity", 0.4)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake battery
            batteryGroup
                .transition().duration(50).attr("transform", `translate(${battery.x - 5}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x + 5}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x - 3}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x + 3}, ${battery.y})`)
                .transition().duration(50).attr("transform", `translate(${battery.x}, ${battery.y})`);
            
            // Disconnect the short circuit
            if (connection) {
                deleteConnection(connection.id);
            }
            
            showHint("üí• Battery Destroyed!", 
                "A dead short circuit was detected (positive directly connected to negative). " +
                "The battery has been destroyed. Always use proper circuit protection.");
        }
        
        function validateSystem() {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Calculate array specs using connection tracing
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            
            // Update wire gauges based on current system specs
            updateAllWireGauges();
            
            // Check if system is operational
            const pvConnected = controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                               controller.handles?.pvNegative?.connectedTo?.length > 0;
            const battConnected = controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                                 controller.handles?.batteryNegative?.connectedTo?.length > 0;
            
            // Update controller visual state
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            if (pvConnected && battConnected && arraySpecs.wmp > 0 && batterySpecs.kWh > 0) {
                const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
                const maxSupportedVoltage = Math.max(...supportedVoltages);
                const nominalBatteryVoltage = Math.round(batterySpecs.voltage / 12) * 12;
                
                // Check for battery overvoltage (60V+)
                if (batterySpecs.voltage > maxSupportedVoltage + 10) {
                    controllerGroup.classed('operational', false).classed('error', true);
                    
                    if (!controller.batteryOvervoltage) {
                        controller.batteryOvervoltage = true;
                        triggerBatteryOvervoltageEffect(controller, batterySpecs.voltage, maxSupportedVoltage);
                    }
                }
                // Check for incompatible battery voltage (e.g., 36V on 12/24/48V controller)
                else if (!supportedVoltages.includes(nominalBatteryVoltage) && batterySpecs.voltage > 12) {
                    controller.batteryOvervoltage = false;
                    controllerGroup.classed('operational', false).classed('error', false);
                    
                    if (!controller.incompatibleVoltageShown) {
                        controller.incompatibleVoltageShown = true;
                        showHint("‚ö†Ô∏è Incompatible Battery Voltage", 
                            `This controller isn't compatible with ${nominalBatteryVoltage}V battery configurations. ` +
                            `Supported voltages: ${supportedVoltages.join('V, ')}V. Try adding or removing batteries to reach a compatible voltage.`);
                    }
                }
                // Check for solar voltage overload
                else if (arraySpecs.voc > controller.specs.maxVoc) {
                    controller.batteryOvervoltage = false;
                    controller.incompatibleVoltageShown = false;
                    controllerGroup.classed('operational', false).classed('error', true);
                    
                    // DESTRUCTION EFFECT - only trigger once
                    if (!controller.destroyed) {
                        controller.destroyed = true;
                        triggerOverloadEffect(controller, arraySpecs.voc, controller.specs.maxVoc);
                    }
                } else if (arraySpecs.imp > controller.specs.maxIsc) {
                    // Check for current overload (use Imp for actual operating current)
                    controller.destroyed = false;
                    controllerGroup.classed('operational', true).classed('error', false);
                    
                    if (!controller.currentClippingShown) {
                        controller.currentClippingShown = true;
                        
                        // Calculate clipped output: Array Vmp √ó Controller max Isc
                        const clippedOutputW = Math.round(arraySpecs.vmp * controller.specs.maxIsc);
                        const lostPowerW = arraySpecs.wmp - clippedOutputW;
                        const lostPercent = ((lostPowerW / arraySpecs.wmp) * 100).toFixed(0);
                        const controllerMaxW = controller.specs.maxWmp || (controller.specs.maxIsc * controller.specs.maxVoc);
                        
                        // Calculate how many more panels in series would help
                        const currentVmp = arraySpecs.vmp;
                        const targetVmp = (arraySpecs.wmp / controller.specs.maxIsc); // Vmp needed to get full power at max current
                        const panelVmp = arraySpecs.panelCount > 0 ? currentVmp / arraySpecs.seriesCount : 30;
                        const additionalPanelsNeeded = Math.ceil((targetVmp - currentVmp) / panelVmp);
                        
                        showCurrentClippingHint(arraySpecs, controller, clippedOutputW, lostPowerW, lostPercent, additionalPanelsNeeded);
                    }
                    systemValidated = true;
                } else {
                    // System is operational and within limits
                    controller.destroyed = false;
                    controller.batteryOvervoltage = false;
                    controller.incompatibleVoltageShown = false;
                    controller.currentClippingShown = false; // Reset clipping flag when current is within limits
                    controllerGroup.classed('operational', true).classed('error', false);
                    
                    // Calculate max watts based on battery voltage
                    const maxWattsAtBatteryVoltage = getMaxWattsForController(controller, batterySpecs.voltage);
                    const maxWattsAt48V = getMaxWattsForController(controller, 48);
                    const maxWattsAt24V = getMaxWattsForController(controller, 24);
                    
                    // Check for battery voltage upgrade (24V or 48V)
                    const lastBatteryVoltage = controller.lastBatteryVoltage || 12;
                    if (nominalBatteryVoltage > lastBatteryVoltage && nominalBatteryVoltage >= 24) {
                        controller.lastBatteryVoltage = nominalBatteryVoltage;
                        showSuccessAnimation();
                        showBatteryUpgradeHint(nominalBatteryVoltage, maxWattsAtBatteryVoltage);
                    } else {
                        controller.lastBatteryVoltage = nominalBatteryVoltage;
                    }
                    
                    // Check if array is near controller's voltage limit (optimal for current battery)
                    // Only show this hint when circuit is fully connected (both PV+ and PV- connected)
                    const voltageUtilization = arraySpecs.voc / controller.specs.maxVoc;
                    const isNearVoltageLimit = voltageUtilization > 0.85 && voltageUtilization <= 1.0;
                    const canBenefitFromHigherVoltage = batterySpecs.voltage < 48 && 
                        controller.specs.supportedVoltages && 
                        controller.specs.supportedVoltages.includes(48);
                    const circuitComplete = pvConnected && battConnected;
                    
                    // Check if a new parallel string was just connected (significant wattage increase)
                    const wattageIncrease = arraySpecs.wmp - lastConnectedArrayWmp;
                    const newStringConnected = circuitComplete && wattageIncrease >= 200 && lastConnectedArrayWmp > 0;
                    
                    if (newStringConnected) {
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showSuccessAnimation();
                        showParallelStringFeedback();
                    } else if (isNearVoltageLimit && canBenefitFromHigherVoltage && !optimalArrayHintShown && arraySpecs.panelCount >= 4 && circuitComplete) {
                        optimalArrayHintShown = true;
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showSuccessAnimation();
                        showOptimalArrayHint(arraySpecs, batterySpecs, maxWattsAtBatteryVoltage, maxWattsAt48V);
                    } else if (!systemValidated && circuitComplete) {
                        systemValidated = true;
                        lastConnectedArrayWmp = arraySpecs.wmp;
                        showAchievement("üéâ System Operational!", {
                            arrayWmp: arraySpecs.wmp,
                            arrayVoc: arraySpecs.voc,
                            arrayIsc: arraySpecs.isc,
                            batteryKwh: batterySpecs.kWh,
                            batteryVoltage: batterySpecs.voltage,
                            maxWattsAtVoltage: maxWattsAtBatteryVoltage,
                            cost: calculateTotalCost(),
                            optimization: calculateOptimizationScore(controller, arraySpecs)
                        });
                    } else if (circuitComplete) {
                        // Update last wattage even if no hint shown
                        lastConnectedArrayWmp = arraySpecs.wmp;
                    }
                }
            } else {
                controllerGroup.classed('operational', false).classed('error', false);
            }
        }
        
        function triggerOverloadEffect(controller, actualVoltage, maxVoltage) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            // Create explosion particles
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Add spark particles
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 30 + Math.random() * 50;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 4)
                    .attr("fill", Math.random() > 0.5 ? "#ff6600" : "#ffff00")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash the screen red
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#ff0000")
                .style("opacity", 0.5)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake the controller
            controllerGroup
                .transition().duration(50).attr("transform", `translate(${controller.x - 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            // Show dramatic warning with helpful tips
            setTimeout(() => {
                if (!areHintsEnabled()) return;
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #d9534f;">üí• CONTROLLER DESTROYED!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Array voltage (${actualVoltage.toFixed(1)}V) exceeded the controller's max (${maxVoltage}V) by ${((actualVoltage/maxVoltage - 1) * 100).toFixed(0)}%!
                            </p>
                            <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                                <strong>Solutions:</strong> Remove some panels, or wire panels in parallel strings instead of one long series string.
                            </p>
                            <p style="margin: 0; color: #888; font-size: 11px;">
                                <strong>Tips:</strong> Double-click wires to delete them. Select nodes and press Delete to remove.
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(217, 83, 79, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                            <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #d9534f;">${actualVoltage.toFixed(1)}V</div>
                            <div style="font-size: 10px; color: #d9534f; margin-top: 2px;">MAX: ${maxVoltage}V</div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
                
                // Start live voltage updates
                if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
            }, 400);
        }
        
        function triggerBatteryOvervoltageEffect(controller, actualVoltage, maxVoltage) {
            const controllerGroup = itemsGroup.select(`[data-id="${controller.id}"]`);
            
            // Create explosion particles
            const cx = controller.x + controller.width / 2;
            const cy = controller.y + controller.height / 2;
            
            // Add spark particles (blue/white for battery)
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 30 + Math.random() * 50;
                const spark = zoomGroup.append("circle")
                    .attr("class", "spark")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", 3 + Math.random() * 4)
                    .attr("fill", Math.random() > 0.5 ? "#00aaff" : "#ffffff")
                    .style("filter", "blur(1px)");
                
                spark.transition()
                    .duration(500 + Math.random() * 300)
                    .attr("cx", cx + Math.cos(angle) * distance)
                    .attr("cy", cy + Math.sin(angle) * distance)
                    .attr("r", 0)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Flash the screen blue
            const flash = d3.select("svg").append("rect")
                .attr("class", "overload-flash")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#0066ff")
                .style("opacity", 0.5)
                .style("pointer-events", "none");
            
            flash.transition()
                .duration(300)
                .style("opacity", 0)
                .remove();
            
            // Shake the controller
            controllerGroup
                .transition().duration(50).attr("transform", `translate(${controller.x - 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 5}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x - 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x + 3}, ${controller.y})`)
                .transition().duration(50).attr("transform", `translate(${controller.x}, ${controller.y})`);
            
            // Show warning
            setTimeout(() => {
                if (!areHintsEnabled()) return;
                const hintPopup = document.getElementById('hintPopup');
                hintPopup.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 20px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 8px 0; color: #0088ff;">‚ö° BATTERY OVERVOLTAGE!</h3>
                            <p style="margin: 0 0 8px 0;">
                                Whoa, too many volts! Your battery bank is at <strong style="color: #d9534f;">${actualVoltage.toFixed(1)}V</strong>.
                            </p>
                            <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                                <strong>${maxVoltage}V</strong> is the limit for this controller, and most common solar controllers don't work with battery voltages above 48V.
                            </p>
                            <p style="margin: 0; color: #888; font-size: 11px;">
                                Take it down a notch! Remove some batteries from the series string.
                            </p>
                            <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                        </div>
                        <div style="padding: 10px 15px; background: rgba(0, 136, 255, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BANK VOLTAGE</div>
                            <div id="liveBatteryVoltage" style="font-size: 22px; font-weight: bold; color: #d9534f;">${actualVoltage.toFixed(1)}V</div>
                            <div style="font-size: 10px; color: #0088ff; margin-top: 2px;">MAX: ${maxVoltage}V</div>
                        </div>
                    </div>
                `;
                hintPopup.classList.remove('hidden');
                
                // Start live battery voltage updates
                if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = setInterval(updateSeriesBatteryReadout, 200);
            }, 400);
        }
        
        function showBatteryUpgradeHint(voltage, maxWatts) {
            showSuccessAnimation();
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üîã Upgraded to ${voltage}V!</h3>
                        <p style="margin: 0 0 8px 0;">
                            Nice! You've upgraded to a <strong style="color: #28a745;">${voltage}V battery bank</strong>!
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            Now you can connect up to <strong style="color: #ffdd57;">${maxWatts}W</strong> of solar panels.
                        </p>
                        <p style="margin: 0; color: #888; font-size: 11px;">
                            ${voltage < 48 ? 'Try adding more panels in series-parallel strings, or upgrade to 48V for even more capacity!' : 'This is the maximum voltage for most controllers. Now maximize your solar array!'}
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(40, 167, 69, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BATTERY</div>
                        <div style="font-size: 22px; font-weight: bold; color: #28a745;">${voltage}V</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">MAX SOLAR</div>
                            <div style="font-size: 14px; color: #ffdd57;">${maxWatts}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // Calculate voltage for a partial/incomplete string of panels
        // This works even when the string isn't fully connected back to the controller
        function calculatePartialStringVoltage(startPanel, startHandle) {
            if (!startPanel || startPanel.type !== 'panel') {
                return { voltage: 0, panelCount: 0 };
            }
            
            const visited = new Set();
            const panels = [];
            
            // Trace series connections from this panel
            function traceSeries(currentPanel, currentHandle) {
                if (visited.has(currentPanel.id)) return;
                visited.add(currentPanel.id);
                panels.push(currentPanel);
                
                // Find the opposite terminal
                const otherHandle = currentHandle.polarity === 'positive' 
                    ? currentPanel.handles.negative 
                    : currentPanel.handles.positive;
                
                // Trace through series connections
                if (otherHandle && otherHandle.connectedTo) {
                    for (const conn of otherHandle.connectedTo) {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel' && !visited.has(item.id)) {
                            const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (connectedHandle && connectedHandle.polarity !== otherHandle.polarity) {
                                traceSeries(item, connectedHandle);
                            }
                        }
                    }
                }
            }
            
            traceSeries(startPanel, startHandle);
            
            // Calculate total Voc (series connection: voltages add)
            const totalVoc = panels.reduce((sum, p) => sum + (p.specs.voc || 0), 0);
            
            return {
                voltage: totalVoc,
                panelCount: panels.length
            };
        }
        
        function calculateConnectedArraySpecs(controller) {
            // Check cache first
            const cacheKey = controller.id;
            if (_specsCache.array.has(cacheKey)) return _specsCache.array.get(cacheKey);
            
            // Find all COMPLETE circuits connected to the controller
            // A complete circuit requires BOTH positive AND negative paths from panel to controller
            
            const completeStrings = [];
            
            // Helper: normalize polarity for comparison
            const normalizePolarity = (p) => {
                if (p === 'pv-positive') return 'positive';
                if (p === 'pv-negative') return 'negative';
                return p;
            };
            
            // Trace from controller to find all reachable panels, tracking the polarity path
            // targetPolarity: 'positive' or 'negative' - what panel terminal we're looking for at the END of a string
            function traceToPanels(startItem, startHandle, targetPolarity, visited = new Set(), depth = 0) {
                if (depth > 50) return [];
                const key = startItem.id + '-' + startHandle.id;
                if (visited.has(key)) return [];
                visited.add(key);
                
                const panels = [];
                
                if (startItem.type === 'panel') {
                    // We found a panel - add it
                    panels.push(startItem);
                    
                    // Also trace through series connections to find more panels
                    // If we entered via positive, check negative for series connection (and vice versa)
                    const entryPolarity = normalizePolarity(startHandle.polarity);
                    const otherHandle = entryPolarity === 'positive' ? 
                        startItem.handles.negative : startItem.handles.positive;
                    
                    // Trace through the other terminal to find series-connected panels
                    otherHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel') {
                            const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                            if (handle) {
                                // Series connection: opposite polarities connect
                                panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                            }
                        }
                    });
                    
                    return panels;
                }
                
                // For combiners, we enter via output and need to trace back through matching polarity inputs
                if (startItem.type === 'combiner' || startItem.type === 'solarcombiner') {
                    const isOutputHandle = startHandle.id.includes('-out-');
                    
                    if (isOutputHandle) {
                        // Determine which input polarity to follow based on output polarity
                        const outputPolarity = normalizePolarity(startHandle.polarity);
                        
                        Object.entries(startItem.handles).forEach(([name, h]) => {
                            if (h.inputIndex !== undefined) {
                                // Only follow inputs matching the polarity we're tracing
                                const inputPolarity = normalizePolarity(h.polarity);
                                if (inputPolarity !== outputPolarity) return;
                                
                                // For solar combiner, check breaker state
                                if (startItem.type === 'solarcombiner' && !startItem.breakerStates[h.inputIndex]) {
                                    return;
                                }
                                h.connectedTo.forEach(conn => {
                                    const item = allItems.find(i => i.id === conn.itemId);
                                    if (item) {
                                        const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                                        if (handle) {
                                            panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                                        }
                                    }
                                });
                            }
                        });
                    }
                    return panels;
                }
                
                // For breakers, trace through if closed
                if (startItem.type === 'breaker') {
                    if (!startItem.isClosed) return [];
                    
                    // Determine which side we entered from and trace to the other side
                    const handlePolarity = normalizePolarity(startHandle.polarity);
                    const isLoadSide = startHandle.id.includes('-load-');
                    const isLineSide = startHandle.id.includes('-line-');
                    
                    let targetHandle;
                    if (isLoadSide) {
                        // Entered via load, trace to line
                        targetHandle = handlePolarity === 'positive' ? 
                            startItem.handles.linePositive : startItem.handles.lineNegative;
                    } else if (isLineSide) {
                        // Entered via line, trace to load
                        targetHandle = handlePolarity === 'positive' ? 
                            startItem.handles.loadPositive : startItem.handles.loadNegative;
                    }
                    
                    if (targetHandle) {
                        targetHandle.connectedTo.forEach(conn => {
                            const item = allItems.find(i => i.id === conn.itemId);
                            if (item) {
                                const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                                if (handle) {
                                    panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                                }
                            }
                        });
                    }
                    return panels;
                }
                
                // For direct connections
                startHandle.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const handle = Object.values(item.handles).find(hh => hh.id === conn.handleId);
                        if (handle) {
                            panels.push(...traceToPanels(item, handle, targetPolarity, visited, depth + 1));
                        }
                    }
                });
                
                return panels;
            }
            
            // Find panels reachable from PV+ (looking for panel positive terminals)
            // Support multiple MPPTs by checking all PV positive handles
            const panelsFromPositive = new Set();
            const mpptCount = controller.specs.mpptCount || 1;
            
            // Check all PV positive handles (legacy pvPositive or numbered pvPositive1, pvPositive2, etc.)
            const pvPositiveHandles = [];
            if (controller.handles.pvPositive) {
                pvPositiveHandles.push(controller.handles.pvPositive);
            }
            for (let i = 1; i <= mpptCount; i++) {
                const handleKey = `pvPositive${i}`;
                if (controller.handles[handleKey]) {
                    pvPositiveHandles.push(controller.handles[handleKey]);
                }
            }
            
            pvPositiveHandles.forEach(pvPosHandle => {
                if (pvPosHandle && pvPosHandle.connectedTo) {
                    pvPosHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item) {
                            const handle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (handle) {
                                // Use a fresh visited set for each parallel connection
                                traceToPanels(item, handle, 'positive', new Set()).forEach(p => {
                                    panelsFromPositive.add(p.id);
                                });
                            }
                        }
                    });
                }
            });
            
            // Find panels reachable from PV- (looking for panel negative terminals)
            // Support multiple MPPTs by checking all PV negative handles
            const panelsFromNegative = new Set();
            
            // Check all PV negative handles (legacy pvNegative or numbered pvNegative1, pvNegative2, etc.)
            const pvNegativeHandles = [];
            if (controller.handles.pvNegative) {
                pvNegativeHandles.push(controller.handles.pvNegative);
            }
            for (let i = 1; i <= mpptCount; i++) {
                const handleKey = `pvNegative${i}`;
                if (controller.handles[handleKey]) {
                    pvNegativeHandles.push(controller.handles[handleKey]);
                }
            }
            
            pvNegativeHandles.forEach(pvNegHandle => {
                if (pvNegHandle && pvNegHandle.connectedTo) {
                    pvNegHandle.connectedTo.forEach(conn => {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item) {
                            const handle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (handle) {
                                // Use a fresh visited set for each parallel connection
                                traceToPanels(item, handle, 'negative', new Set()).forEach(p => {
                                    panelsFromNegative.add(p.id);
                                });
                            }
                        }
                    });
                }
            });
            
            // A panel is in a complete circuit only if reachable from BOTH positive AND negative paths
            const completePanelIds = new Set([...panelsFromPositive].filter(id => panelsFromNegative.has(id)));
            
            if (completePanelIds.size === 0) {
                return { wmp: 0, voc: 0, vmp: 0, isc: 0, imp: 0, panelCount: 0, seriesCount: 0, parallelCount: 0 };
            }
            
            // Now trace series strings, but only include panels that are in complete circuits
            const visitedPanels = new Set();
            
            function traceSeriesString(startPanel, startHandle) {
                const string = [];
                let currentPanel = startPanel;
                let currentHandle = startHandle;
                
                while (currentPanel && !visitedPanels.has(currentPanel.id)) {
                    // Only include panels that are in complete circuits
                    if (!completePanelIds.has(currentPanel.id)) break;
                    
                    visitedPanels.add(currentPanel.id);
                    string.push(currentPanel);
                    
                    const otherHandle = currentHandle.polarity === 'positive' 
                        ? currentPanel.handles.negative 
                        : currentPanel.handles.positive;
                    
                    let nextPanel = null;
                    let nextHandle = null;
                    
                    for (const conn of otherHandle.connectedTo) {
                        const item = allItems.find(i => i.id === conn.itemId);
                        if (item && item.type === 'panel' && !visitedPanels.has(item.id) && completePanelIds.has(item.id)) {
                            const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                            if (connectedHandle && connectedHandle.polarity !== otherHandle.polarity) {
                                nextPanel = item;
                                nextHandle = connectedHandle;
                                break;
                            }
                        }
                    }
                    
                    currentPanel = nextPanel;
                    currentHandle = nextHandle;
                }
                
                return string;
            }
            
            // Build strings from complete panels
            // First, find "string start" panels - panels whose positive terminal is NOT connected to another panel's negative
            // These are the first panels in each series string
            const stringStartPanels = [];
            for (const panelId of completePanelIds) {
                const panel = allItems.find(i => i.id === panelId);
                if (!panel) continue;
                
                // Check if positive terminal is connected to another panel's negative terminal
                const posConnections = panel.handles.positive.connectedTo;
                const isConnectedToPanelNegative = posConnections.some(conn => {
                    const connItem = allItems.find(i => i.id === conn.itemId);
                    if (connItem && connItem.type === 'panel') {
                        const connHandle = Object.values(connItem.handles).find(h => h.id === conn.handleId);
                        return connHandle && connHandle.polarity === 'negative';
                    }
                    return false;
                });
                
                // If positive is NOT connected to another panel's negative, this is a string start
                if (!isConnectedToPanelNegative) {
                    stringStartPanels.push(panel);
                }
            }
            
            // Now trace strings starting from the identified start panels
            for (const panel of stringStartPanels) {
                if (visitedPanels.has(panel.id)) continue;
                const string = traceSeriesString(panel, panel.handles.positive);
                if (string.length > 0) {
                    completeStrings.push(string);
                }
            }
            
            if (completeStrings.length === 0) {
                return { wmp: 0, voc: 0, vmp: 0, isc: 0, imp: 0, panelCount: 0, seriesCount: 0, parallelCount: 0 };
            }
            
            const parallelCount = completeStrings.length;
            const seriesCount = Math.max(...completeStrings.map(s => s.length));
            const totalPanels = completeStrings.reduce((sum, s) => sum + s.length, 0);
            
            // For each string, calculate its voltage (sum of panel voltages in series)
            const stringVocs = completeStrings.map(s => s.reduce((sum, p) => sum + p.specs.voc, 0));
            const stringVmps = completeStrings.map(s => s.reduce((sum, p) => sum + p.specs.vmp, 0));
            
            // Array Voc is the max string Voc (parallel strings don't add voltage)
            const voc = Math.max(...stringVocs);
            const vmp = Math.max(...stringVmps);
            
            // Array current is sum of string currents (parallel strings add current)
            // Each string's current is limited by the lowest panel current in that string
            // Use IMP for array calculations (not ISC)
            const stringIscs = completeStrings.map(s => Math.min(...s.map(p => p.specs.isc || 0)));
            // Calculate IMP for each panel if missing, then get minimum per string
            const stringImps = completeStrings.map(s => {
                const panelImps = s.map(p => {
                    if (p.specs.imp) return p.specs.imp;
                    // Calculate from WMP/VMP if available
                    if (p.specs.wmp && p.specs.vmp) return p.specs.wmp / p.specs.vmp;
                    // Fallback to ISC * 0.9 if IMP not available
                    if (p.specs.isc) return p.specs.isc * 0.9;
                    return 0;
                });
                return Math.min(...panelImps);
            });
            
            const isc = stringIscs.reduce((sum, i) => sum + i, 0);
            const imp = stringImps.reduce((sum, i) => sum + i, 0);
            
            // Total wattage is sum of all panel wattages
            const wmp = completeStrings.reduce((sum, s) => sum + s.reduce((sum2, p) => sum2 + p.specs.wmp, 0), 0);
            
            const result = { 
                wmp, voc, vmp, isc, imp, 
                panelCount: totalPanels, 
                seriesCount, 
                parallelCount,
                config: `${parallelCount}P${seriesCount}S`
            };
            _specsCache.array.set(controller.id, result);
            return result;
        }
        
        function calculateConnectedBatterySpecs(controller) {
            // Check cache first
            const cacheKey = controller.id;
            if (_specsCache.battery.has(cacheKey)) return _specsCache.battery.get(cacheKey);
            
            // For all-in-one controllers, return the internal battery specs plus any connected smart batteries
            if (controller.specs.type === 'all_in_one' && controller.specs.internalBatteryKWh) {
                const internalVoltage = controller.specs.supportedVoltages?.[0] || 48;
                let totalKwh = controller.specs.internalBatteryKWh;
                let smartBatteryCount = 0;
                
                // Count connected smart batteries
                const visitedSmartBatteries = new Set();
                function traceSmartBatteries(item) {
                    Object.values(item.handles).forEach(handle => {
                        if (handle.polarity === 'smart-battery') {
                            handle.connectedTo.forEach(conn => {
                                const connectedItem = allItems.find(i => i.id === conn.itemId);
                                if (connectedItem && connectedItem.type === 'smartbattery' && !visitedSmartBatteries.has(connectedItem.id)) {
                                    visitedSmartBatteries.add(connectedItem.id);
                                    totalKwh += connectedItem.specs.kWh;
                                    smartBatteryCount++;
                                    // Recursively trace from this smart battery
                                    traceSmartBatteries(connectedItem);
                                }
                            });
                        }
                    });
                }
                traceSmartBatteries(controller);
                
                const totalAh = (totalKwh * 1000) / internalVoltage;
                const configText = smartBatteryCount > 0 
                    ? `Internal + ${smartBatteryCount} ext`
                    : 'Internal';
                const result = {
                    voltage: internalVoltage,
                    ah: totalAh,
                    kWh: totalKwh,
                    maxDischarge: totalAh * 0.9, // Assume 90% usable
                    batteryCount: 1 + smartBatteryCount,
                    seriesCount: 1,
                    parallelCount: 1 + smartBatteryCount,
                    config: configText,
                    isInternal: true
                };
                _specsCache.battery.set(cacheKey, result);
                return result;
            }
            
            // Trace batteries connected to controller's battery handles
            // Now traces through breakers and combiners
            const connectedBatteries = new Set();
            const visitedNodes = new Set();
            
            function traceTowardsBatteries(item, handle, depth = 0) {
                if (depth > 20) return; // Prevent infinite loops
                const nodeKey = item.id + '-' + handle.id;
                if (visitedNodes.has(nodeKey)) return;
                visitedNodes.add(nodeKey);
                
                if (item.type === 'battery') {
                    connectedBatteries.add(item.id);
                    // Trace through this battery's other handle for series connections
                    Object.values(item.handles).forEach(h => {
                        if (h.id !== handle.id) {
                            h.connectedTo.forEach(conn => {
                                const nextItem = allItems.find(i => i.id === conn.itemId);
                                if (nextItem) {
                                    const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                    if (nextHandle) {
                                        traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                    }
                                }
                            });
                        }
                    });
                    return;
                }
                
                // If it's a breaker, trace through if closed
                if (item.type === 'breaker') {
                    if (!item.isClosed) return; // Breaker is open
                    
                    // Determine which side we came from and trace the other side
                    const isLineSide = handle.id.includes('-line-');
                    const otherHandles = isLineSide 
                        ? [item.handles.loadPositive, item.handles.loadNegative]
                        : [item.handles.linePositive, item.handles.lineNegative];
                    
                    otherHandles.forEach(h => {
                        h.connectedTo.forEach(conn => {
                            const nextItem = allItems.find(i => i.id === conn.itemId);
                            if (nextItem) {
                                const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                if (nextHandle) {
                                    traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                }
                            }
                        });
                    });
                    return;
                }
                
                // If it's a combiner, trace all connected handles
                if (item.type === 'combiner') {
                    Object.values(item.handles).forEach(h => {
                        h.connectedTo.forEach(conn => {
                            const nextItem = allItems.find(i => i.id === conn.itemId);
                            if (nextItem) {
                                const nextHandle = Object.values(nextItem.handles).find(hh => hh.id === conn.handleId);
                                if (nextHandle) {
                                    traceTowardsBatteries(nextItem, nextHandle, depth + 1);
                                }
                            }
                        });
                    });
                    return;
                }
            }
            
            // Start tracing from controller's battery handles (if they exist)
            const battHandles = [controller.handles.batteryPositive, controller.handles.batteryNegative].filter(h => h);
            battHandles.forEach(battHandle => {
                battHandle.connectedTo.forEach(conn => {
                    const item = allItems.find(i => i.id === conn.itemId);
                    if (item) {
                        const connectedHandle = Object.values(item.handles).find(h => h.id === conn.handleId);
                        if (connectedHandle) {
                            traceTowardsBatteries(item, connectedHandle);
                        }
                    }
                });
            });
            
            const batteries = Array.from(connectedBatteries).map(id => allItems.find(i => i.id === id));
            
            if (batteries.length === 0) {
                const result = { voltage: 0, ah: 0, kWh: 0, maxDischarge: 0, batteryCount: 0 };
                _specsCache.battery.set(cacheKey, result);
                return result;
            }
            
            // Find series strings by tracing battery-to-battery connections
            const visitedBatteries = new Set();
            const strings = [];
            
            function traceSeriesString(startBattery) {
                const string = [];
                const toVisit = [startBattery];
                
                while (toVisit.length > 0) {
                    const battery = toVisit.pop();
                    if (visitedBatteries.has(battery.id)) continue;
                    visitedBatteries.add(battery.id);
                    string.push(battery);
                    
                    // Check both handles for connections to other batteries
                    Object.values(battery.handles).forEach(handle => {
                        handle.connectedTo.forEach(conn => {
                            const connectedItem = allItems.find(i => i.id === conn.itemId);
                            if (connectedItem && connectedItem.type === 'battery' && !visitedBatteries.has(connectedItem.id)) {
                                toVisit.push(connectedItem);
                            }
                        });
                    });
                }
                
                return string;
            }
            
            // Build all series strings
            batteries.forEach(battery => {
                if (!visitedBatteries.has(battery.id)) {
                    const string = traceSeriesString(battery);
                    if (string.length > 0) {
                        strings.push(string);
                    }
                }
            });
            
            if (strings.length === 0) {
                const result = { voltage: 0, ah: 0, kWh: 0, maxDischarge: 0, batteryCount: 0 };
                _specsCache.battery.set(cacheKey, result);
                return result;
            }
            
            // Calculate specs for series-parallel configuration
            // Each string: voltages add (series), capacity is min Ah in string
            // Parallel strings: voltage stays same (should be equal), Ah adds up
            
            const stringVoltages = strings.map(s => s.reduce((sum, b) => sum + b.specs.voltage, 0));
            const stringAhs = strings.map(s => Math.min(...s.map(b => b.specs.ah)));
            const stringMaxDischarges = strings.map(s => Math.min(...s.map(b => b.specs.maxDischarge)));
            
            // For parallel strings, voltage should be the same (use max to catch mismatches)
            const voltage = Math.max(...stringVoltages);
            // Ah adds up in parallel
            const ah = stringAhs.reduce((sum, a) => sum + a, 0);
            const kWh = (voltage * ah) / 1000;
            const maxDischarge = stringMaxDischarges.reduce((sum, d) => sum + d, 0);
            
            const result = { 
                voltage, 
                ah, 
                kWh, 
                maxDischarge, 
                batteryCount: batteries.length,
                seriesCount: Math.max(...strings.map(s => s.length)),
                parallelCount: strings.length,
                config: `${strings.length}P${Math.max(...strings.map(s => s.length))}S`
            };
            _specsCache.battery.set(cacheKey, result);
            return result;
        }
        
        function calculateOptimizationScore(controller, arraySpecs) {
            if (!controller || arraySpecs.wmp === 0) return 0;
            return Math.min(100, (arraySpecs.wmp / controller.specs.maxWmp) * 100);
        }
        
        function calculateTotalCost() {
            // Sum component costs
            let componentCost = allItems.reduce((sum, item) => sum + (item.specs.cost || 0), 0);
            
            // Sum wire costs from all connections
            let wireCost = connections.reduce((sum, conn) => sum + (conn.totalWireCost || 0), 0);
            
            return componentCost + wireCost;
        }
        
        // Generate Amazon search link for a component
        function generateAmazonLink(component) {
            if (!component || !component.specs) return null;
            
            const name = component.specs.name || '';
            const type = component.type || '';
            let searchTerms = name;
            
            // Add key specs to search terms based on component type
            if (type === 'panel') {
                const wmp = component.specs.wmp || '';
                const vmp = component.specs.vmp || '';
                searchTerms = `${name} ${wmp}W ${vmp}V solar panel`.trim();
            } else if (type === 'battery') {
                const voltage = component.specs.voltage || '';
                const ah = component.specs.ah || '';
                searchTerms = `${name} ${voltage}V ${ah}Ah LiFePO4 battery`.trim();
            } else if (type === 'controller') {
                const maxVoc = component.specs.maxVoc || '';
                const maxWmp = component.specs.maxWmp || '';
                searchTerms = `${name} ${maxVoc}V ${maxWmp}W MPPT charge controller`.trim();
            } else if (type === 'breaker' || type === 'acbreaker') {
                const rating = component.specs.rating || '';
                const voltage = component.specs.voltage || component.specs.maxVoltage || '';
                searchTerms = `${name} ${rating}A ${voltage}V DC breaker`.trim();
            } else {
                searchTerms = name;
            }
            
            // Encode search terms for URL
            const encodedTerms = encodeURIComponent(searchTerms);
            return `https://www.amazon.com/s?k=${encodedTerms}`;
        }
        
        // Generate bill of materials
        function generateBillOfMaterials() {
            const bom = {
                categories: {
                    panels: [],
                    batteries: [],
                    controllers: [],
                    breakers: [],
                    combiners: [],
                    wires: [],
                    other: []
                },
                totalCost: 0
            };
            
            // Helper to create item key for grouping
            function getItemKey(item) {
                if (item.type === 'panel') {
                    return `panel-${item.specs.wmp}-${item.specs.vmp}-${item.specs.cost}`;
                } else if (item.type === 'battery') {
                    return `battery-${item.specs.voltage}-${item.specs.ah}-${item.specs.cost}`;
                } else if (item.type === 'controller') {
                    return `controller-${item.specs.name}-${item.specs.cost}`;
                } else if (item.type === 'breaker') {
                    return `breaker-${item.specs.rating}-${item.specs.maxVoltage}-${item.specs.cost}`;
                } else if (item.type === 'acbreaker') {
                    return `acbreaker-${item.specs.rating}-${item.specs.voltage}-${item.specs.cost}`;
                } else if (item.type === 'combiner' || item.type === 'solarcombiner') {
                    return `${item.type}-${item.specs.inputs || item.specs.breakerRating}-${item.specs.cost}`;
                }
                return `${item.type}-${item.specs.name || 'unknown'}-${item.specs.cost}`;
            }
            
            // Group components by type and specs
            const componentGroups = {};
            
            allItems.forEach(item => {
                if (!item.specs || item.specs.cost === undefined) return;
                
                const key = getItemKey(item);
                if (!componentGroups[key]) {
                    componentGroups[key] = {
                        name: item.specs.name || `${item.type} ${item.id}`,
                        type: item.type,
                        specs: { ...item.specs },
                        quantity: 0,
                        unitCost: item.specs.cost || 0,
                        totalCost: 0,
                        referenceLink: item.specs.referenceLink || null
                    };
                }
                componentGroups[key].quantity++;
                componentGroups[key].totalCost += item.specs.cost || 0;
            });
            
            // Categorize components and generate links
            Object.values(componentGroups).forEach(group => {
                // Get reference link: use preset link, or generate Amazon link, or null
                let referenceLink = group.referenceLink;
                if (!referenceLink) {
                    // Find a sample item of this type to generate link
                    const sampleItem = allItems.find(item => {
                        const key = getItemKey(item);
                        return key === Object.keys(componentGroups).find(k => componentGroups[k] === group);
                    });
                    if (sampleItem) {
                        referenceLink = generateAmazonLink(sampleItem);
                    }
                }
                
                const item = {
                    name: group.name,
                    quantity: group.quantity,
                    unitCost: group.unitCost,
                    totalCost: group.totalCost,
                    referenceLink: referenceLink,
                    specs: group.specs
                };
                
                if (group.type === 'panel') {
                    bom.categories.panels.push(item);
                } else if (group.type === 'battery' || group.type === 'smartbattery') {
                    bom.categories.batteries.push(item);
                } else if (group.type === 'controller') {
                    bom.categories.controllers.push(item);
                } else if (group.type === 'breaker' || group.type === 'acbreaker') {
                    bom.categories.breakers.push(item);
                } else if (group.type === 'combiner' || group.type === 'solarcombiner') {
                    bom.categories.combiners.push(item);
                } else {
                    bom.categories.other.push(item);
                }
                
                bom.totalCost += group.totalCost;
            });
            
            // Group wires by AWG size
            const wireGroups = {};
            connections.forEach(conn => {
                if (!conn.wireGauge || !conn.totalWireCost) return;
                
                const gauge = conn.wireGauge;
                if (!wireGroups[gauge]) {
                    wireGroups[gauge] = {
                        gauge: gauge,
                        name: WIRE_GAUGE_SPECS[gauge]?.name || `${gauge} AWG`,
                        totalLength: 0,
                        costPerFoot: conn.costPerFoot || WIRE_COST_PER_FOOT[gauge] || 0,
                        totalCost: 0,
                        quantity: 0 // Count of wire runs
                    };
                }
                wireGroups[gauge].totalLength += conn.estimatedLength || 0;
                wireGroups[gauge].totalCost += conn.totalWireCost || 0;
                wireGroups[gauge].quantity++;
            });
            
            // Add wire groups to BOM
            Object.values(wireGroups).forEach(wireGroup => {
                bom.categories.wires.push({
                    name: `${wireGroup.name} Wire`,
                    quantity: wireGroup.quantity,
                    unitCost: wireGroup.costPerFoot,
                    totalLength: wireGroup.totalLength.toFixed(1),
                    totalCost: wireGroup.totalCost,
                    referenceLink: null,
                    specs: {
                        gauge: wireGroup.gauge,
                        length: wireGroup.totalLength
                    }
                });
                bom.totalCost += wireGroup.totalCost;
            });
            
            return bom;
        }
        
        // Display bill of materials
        function showBillOfMaterials() {
            const bom = generateBillOfMaterials();
            const bomContent = document.getElementById('bomContent');
            
            let html = '<div style="margin-bottom: 20px;">';
            
            // Helper to render a category
            function renderCategory(categoryName, items, displayName) {
                if (items.length === 0) return '';
                
                let categoryHtml = `
                    <h3 style="color: #5bc0de; margin-top: 20px; margin-bottom: 10px; border-bottom: 2px solid #5bc0de; padding-bottom: 5px;">${displayName}</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">
                        <thead>
                            <tr style="background: #2a2a2a;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #444;">Item</th>
                                <th style="padding: 8px; text-align: center; border: 1px solid #444;">Qty</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #444;">Unit Cost</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #444;">Total Cost</th>
                                <th style="padding: 8px; text-align: center; border: 1px solid #444;">Link</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                let categoryTotal = 0;
                items.forEach((item, index) => {
                    categoryTotal += item.totalCost;
                    const rowColor = index % 2 === 0 ? '#1a1a1a' : '#252525';
                    const linkDisplay = item.referenceLink ? 
                        `<a href="${item.referenceLink}" target="_blank" style="color: #5bc0de; text-decoration: none;">üîó View</a>` : 
                        '<span style="color: #888;">‚Äî</span>';
                    
                    // For wires, show length instead of quantity
                    const qtyDisplay = item.totalLength ? `${item.quantity} runs (${item.totalLength} ft)` : item.quantity;
                    
                    categoryHtml += `
                        <tr style="background: ${rowColor};">
                            <td style="padding: 8px; border: 1px solid #444;">${item.name}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #444;">${qtyDisplay}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #444;">$${item.unitCost.toFixed(2)}</td>
                            <td style="padding: 8px; text-align: right; border: 1px solid #444; font-weight: bold;">$${item.totalCost.toFixed(2)}</td>
                            <td style="padding: 8px; text-align: center; border: 1px solid #444;">${linkDisplay}</td>
                        </tr>
                    `;
                });
                
                categoryHtml += `
                        </tbody>
                        <tfoot>
                            <tr style="background: #2a2a2a; font-weight: bold;">
                                <td colspan="3" style="padding: 8px; text-align: right; border: 1px solid #444;">${displayName} Subtotal:</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #444; color: #f0ad4e;">$${categoryTotal.toFixed(2)}</td>
                                <td style="padding: 8px; border: 1px solid #444;"></td>
                            </tr>
                        </tfoot>
                    </table>
                `;
                
                return categoryHtml;
            }
            
            // Render each category
            html += renderCategory('panels', bom.categories.panels, 'Solar Panels');
            html += renderCategory('batteries', bom.categories.batteries, 'Batteries');
            html += renderCategory('controllers', bom.categories.controllers, 'Controllers/Inverters');
            html += renderCategory('breakers', bom.categories.breakers, 'Breakers');
            html += renderCategory('combiners', bom.categories.combiners, 'Combiners');
            html += renderCategory('wires', bom.categories.wires, 'Wires');
            html += renderCategory('other', bom.categories.other, 'Other Components');
            
            // Grand total
            html += `
                <div style="margin-top: 30px; padding: 15px; background: #2a2a2a; border: 2px solid #5bc0de; border-radius: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 18px; font-weight: bold;">Grand Total:</span>
                        <span style="font-size: 24px; font-weight: bold; color: #5cb85c;">$${bom.totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                    </div>
                </div>
            `;
            
            html += '</div>';
            bomContent.innerHTML = html;
            
            // Show overlay
            document.getElementById('bomOverlay').style.display = 'flex';
        }
        
        function hideBillOfMaterials() {
            document.getElementById('bomOverlay').style.display = 'none';
        }
        
        // Export bill of materials
        function exportBillOfMaterials() {
            const bom = generateBillOfMaterials();
            const format = 'csv'; // Could be made selectable
            
            let content = '';
            let filename = '';
            
            if (format === 'csv') {
                // CSV format
                content = 'Category,Item,Quantity,Unit Cost,Total Cost,Link\n';
                
                function addCategory(categoryName, items) {
                    items.forEach(item => {
                        const qty = item.totalLength ? `${item.quantity} (${item.totalLength}ft)` : item.quantity;
                        const link = item.referenceLink || '';
                        content += `${categoryName},"${item.name}",${qty},$${item.unitCost.toFixed(2)},$${item.totalCost.toFixed(2)},"${link}"\n`;
                    });
                }
                
                addCategory('Solar Panels', bom.categories.panels);
                addCategory('Batteries', bom.categories.batteries);
                addCategory('Controllers', bom.categories.controllers);
                addCategory('Breakers', bom.categories.breakers);
                addCategory('Combiners', bom.categories.combiners);
                addCategory('Wires', bom.categories.wires);
                addCategory('Other', bom.categories.other);
                
                content += `\nGrand Total,,,,"$${bom.totalCost.toFixed(2)}",\n`;
                
                filename = `solar_system_bom_${new Date().toISOString().slice(0,10)}.csv`;
            } else if (format === 'json') {
                // JSON format
                content = JSON.stringify(bom, null, 2);
                filename = `solar_system_bom_${new Date().toISOString().slice(0,10)}.json`;
            }
            
            // Create download
            const blob = new Blob([content], { type: format === 'csv' ? 'text/csv' : 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Calculate combined AC output from hubs (Delta Pro parallel system)
        function calculateHubCombinedOutput() {
            const hubs = allItems.filter(i => i.type === 'doublevoltagehub');
            let totalHubOutput = 0;
            
            hubs.forEach(hub => {
                let connectedUnits = 0;
                let unitOutputSum = 0;
                
                // Check input1
                if (hub.handles.input1.connectedTo.length > 0) {
                    const connectedItem = allItems.find(i => i.id === hub.handles.input1.connectedTo[0].itemId);
                    if (connectedItem && connectedItem.type === 'controller' && connectedItem.specs.parallelCapable) {
                        connectedUnits++;
                        unitOutputSum += connectedItem.specs.maxACOutputW || 0;
                    }
                }
                
                // Check input2
                if (hub.handles.input2.connectedTo.length > 0) {
                    const connectedItem = allItems.find(i => i.id === hub.handles.input2.connectedTo[0].itemId);
                    if (connectedItem && connectedItem.type === 'controller' && connectedItem.specs.parallelCapable) {
                        connectedUnits++;
                        unitOutputSum += connectedItem.specs.maxACOutputW || 0;
                    }
                }
                
                // Hub output is sum of connected units (up to hub max)
                if (connectedUnits > 0) {
                    totalHubOutput += Math.min(unitOutputSum, hub.specs.maxOutputW);
                }
            });
            
            return totalHubOutput;
        }
        
        function updateScores() {
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            const controllers = allItems.filter(i => i.type === 'controller');
            const controller = controllers[0]; // Primary controller for validation display
            
            // Use connection-aware calculations if controller exists
            let arrayWmp, arrayVoc, arrayImp, arrayConfig, batteryKwh, batteryVoltage, batteryConfig, nominalBatteryVoltage;
            
            if (controllers.length > 0) {
                // Aggregate solar from ALL controllers (for hub-connected systems)
                let totalWmp = 0;
                let maxVoc = 0;
                let totalImp = 0;
                let totalBatteryKwh = 0;
                let configs = [];
                
                controllers.forEach(ctrl => {
                    const arraySpecs = calculateConnectedArraySpecs(ctrl);
                    const batterySpecs = calculateConnectedBatterySpecs(ctrl);
                    totalWmp += arraySpecs.wmp;
                    maxVoc = Math.max(maxVoc, arraySpecs.voc); // Use max Voc for safety checks
                    totalImp += arraySpecs.imp || 0;
                    totalBatteryKwh += batterySpecs.kWh;
                    if (arraySpecs.config && arraySpecs.config !== '-') {
                        configs.push(arraySpecs.config);
                    }
                });
                
                arrayWmp = totalWmp;
                arrayVoc = maxVoc;
                arrayImp = totalImp;
                arrayConfig = configs.length > 0 ? configs.join(' + ') : '-';
                batteryKwh = totalBatteryKwh;
                
                // For battery voltage, use first controller's connected battery
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                batteryVoltage = batterySpecs.voltage;
                batteryConfig = batterySpecs.config || '-';
                // Calculate nominal voltage (round to nearest 12V increment)
                nominalBatteryVoltage = batteryVoltage > 0 ? Math.round(batteryVoltage / 12) * 12 : 0;
            } else {
                arrayWmp = panels.reduce((sum, p) => sum + p.specs.wmp, 0);
                arrayVoc = panels.reduce((sum, p) => sum + p.specs.voc, 0);
                arrayImp = panels.length > 0 ? panels[0].specs.imp || 0 : 0;
                arrayConfig = panels.length > 0 ? `1P${panels.length}S` : '-';
                batteryKwh = batteries.reduce((sum, b) => sum + b.specs.kWh, 0);
                batteryVoltage = batteries.reduce((sum, b) => sum + b.specs.voltage, 0);
                batteryConfig = batteries.length > 0 ? `1P${batteries.length}S` : '-';
                nominalBatteryVoltage = batteryVoltage > 0 ? Math.round(batteryVoltage / 12) * 12 : 0;
            }
            
            const totalCost = calculateTotalCost();
            
            // Update score displays
            document.getElementById('scoreArrayWmp').textContent = arrayWmp + ' W';
            
            const vocEl = document.getElementById('scoreArrayVoc');
            vocEl.textContent = arrayVoc.toFixed(1) + ' V';
            vocEl.classList.remove('good', 'warning', 'error');
            if (controller) {
                if (arrayVoc > controller.specs.maxVoc) {
                    vocEl.classList.add('error');
                } else if (arrayVoc > controller.specs.maxVoc * 0.9) {
                    vocEl.classList.add('warning');
                } else {
                    vocEl.classList.add('good');
                }
            }
            
            // Array Imp
            const impEl = document.getElementById('scoreArrayImp');
            impEl.textContent = arrayImp.toFixed(1) + ' A';
            impEl.classList.remove('good', 'warning', 'error');
            if (controller) {
                if (arrayImp > controller.specs.maxIsc) {
                    impEl.classList.add('error');
                } else if (arrayImp > controller.specs.maxIsc * 0.9) {
                    impEl.classList.add('warning');
                } else {
                    impEl.classList.add('good');
                }
            }
            
            // Array Config (e.g., 2P4S)
            document.getElementById('scoreArrayConfig').textContent = arrayConfig;
            
            document.getElementById('scoreBatteryKwh').textContent = batteryKwh.toFixed(2) + ' kWh';
            document.getElementById('scoreBatteryConfig').textContent = batteryConfig;
            document.getElementById('scoreBatteryVoltage').textContent = nominalBatteryVoltage > 0 ? nominalBatteryVoltage + 'V' : '-';
            document.getElementById('scoreTotalCost').textContent = '$' + totalCost.toLocaleString();
            
            // Optimization score
            if (controller) {
                const optScore = calculateOptimizationScore(controller, { wmp: arrayWmp });
                document.getElementById('scoreOptimization').textContent = optScore.toFixed(0) + '%';
                
                const optEl = document.getElementById('scoreOptimization');
                optEl.classList.remove('good', 'warning', 'error');
                if (optScore >= 80) optEl.classList.add('good');
                else if (optScore >= 50) optEl.classList.add('warning');
                else optEl.classList.add('error');
            } else {
                document.getElementById('scoreOptimization').textContent = '-';
            }
            
            // K_micro score removed for now
        }
        
        // ============================================
        // HINTS & ACHIEVEMENTS
        // ============================================
        
        function areHintsEnabled() {
            return document.getElementById('showHintsToggle')?.checked !== false;
        }
        
        function showHint(title, text) {
            // Check if hints are enabled
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            // Restore standard hint structure if it was replaced
            hintPopup.innerHTML = `
                <h3 id="hintTitle"></h3>
                <p id="hintText"></p>
                <div class="hint-buttons">
                    <button id="hintNext">Next</button>
                    <button id="hintDismiss">Got it!</button>
                    <button id="hintHide">Hide Hints</button>
                </div>
            `;
            document.getElementById('hintTitle').textContent = title;
            document.getElementById('hintText').textContent = text;
            hintPopup.classList.remove('hidden');
            // Ensure it's visible and interactive
            hintPopup.style.display = 'block';
            hintPopup.style.visibility = 'visible';
            hintPopup.style.pointerEvents = 'auto';
            hintPopup.style.opacity = '1';
            // Event listener is handled via event delegation on the hintPopup container
        }
        
        function hideHint() {
            const hintPopup = document.getElementById('hintPopup');
            if (hintPopup) {
                hintPopup.classList.add('hidden');
                // Force remove from interaction flow
                hintPopup.style.display = 'none';
                hintPopup.style.visibility = 'hidden';
                hintPopup.style.pointerEvents = 'none';
                hintPopup.style.opacity = '0';
            }
            if (seriesVoltageInterval) {
                clearInterval(seriesVoltageInterval);
                seriesVoltageInterval = null;
            }
        }
        
        function showCurrentClippingHint(arraySpecs, controller, clippedOutputW, lostPowerW, lostPercent, additionalPanelsNeeded) {
            if (!areHintsEnabled()) return;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #f0ad4e;">‚ö° Current Clipping Active</h3>
                        <p style="margin: 0 0 8px 0;">
                            Your array current (<strong>${arraySpecs.imp.toFixed(1)}A</strong>) exceeds the controller's max input (<strong>${controller.specs.maxIsc}A</strong>).
                        </p>
                        <p style="margin: 0 0 8px 0; color: #f0ad4e;">
                            <strong>Clipped output: ${clippedOutputW}W</strong> (losing ${lostPowerW}W / ${lostPercent}%)
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            <strong>How clipping works:</strong> Array Vmp (${arraySpecs.vmp.toFixed(1)}V) √ó Controller max Isc (${controller.specs.maxIsc}A) = ${clippedOutputW}W max
                        </p>
                        <p style="margin: 0; color: #5cb85c; font-size: 12px;">
                            <strong>Solution:</strong> Add more panels in series to increase voltage and decrease current. 
                            ${additionalPanelsNeeded > 0 ? `Adding ~${additionalPanelsNeeded} more panel${additionalPanelsNeeded > 1 ? 's' : ''} per string would help utilize more of your array's potential.` : ''}
                        </p>
                        <div class="hint-buttons" style="margin-top: 15px;">
                            <button id="hintNext">Next</button>
                            <button id="hintDismiss">Got it!</button>
                            <button id="hintHide">Hide Hints</button>
                        </div>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(240, 173, 78, 0.2); border-radius: 8px; text-align: center; min-width: 120px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY RATED</div>
                        <div style="font-size: 16px; font-weight: bold; color: #888; text-decoration: line-through;">${arraySpecs.wmp}W</div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 8px;">WITH CLIPPING</div>
                        <div style="font-size: 20px; font-weight: bold; color: #f0ad4e;">${clippedOutputW}W</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">CTRL MAX</div>
                            <div style="font-size: 14px; color: #5cb85c;">${controller.specs.maxWmp || 'N/A'}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // ============================================
        // TUTORIAL SYSTEM
        // ============================================
        
        function checkTutorialProgress() {
            // Skip tutorial progress tracking if hints are disabled
            if (!areHintsEnabled()) return;
            if (tutorialCompleted) return;
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const batteryConnected = controller.handles?.batteryPositive?.connectedTo?.length > 0 && 
                                    controller.handles?.batteryNegative?.connectedTo?.length > 0;
            const solarConnected = controller.handles?.pvPositive?.connectedTo?.length > 0 && 
                                  controller.handles?.pvNegative?.connectedTo?.length > 0;
            
            // Check if user connected solar first (out of order)
            if (tutorialStep === 0 && solarConnected && !batteryConnected && !connectedSolarFirst) {
                connectedSolarFirst = true;
                hideHint();
                showSuccessAnimation();
                setTimeout(() => {
                    showHint("‚òÄÔ∏è Nice! You've got solar power!", 
                        "But your controller isn't connected to a battery yet. This usually works, but it's best to connect the battery first so the power has somewhere to go. Connect the battery now!");
                }, 300);
                return;
            }
            
            const currentStepData = TUTORIAL_STEPS[tutorialStep];
            if (!currentStepData) {
                tutorialCompleted = true;
                return;
            }
            
            // Check if current step is complete
            if (currentStepData.check(controller)) {
                // Auto-dismiss current hint
                hideHint();
                
                // Show success animation
                showSuccessAnimation();
                
                tutorialStep++;
                
                // Show success message, then next hint
                if (tutorialStep < TUTORIAL_STEPS.length) {
                    setTimeout(() => {
                        showHint(currentStepData.successTitle, currentStepData.successText);
                    }, 300);
                }
                
                // Check if tutorial is complete - show series hint
                if (tutorialStep >= TUTORIAL_STEPS.length) {
                    tutorialCompleted = true;
                    // Show series hint after a delay
                    setTimeout(() => {
                        if (!seriesHintShown) {
                            showSeriesHint();
                        }
                    }, 2000);
                }
            }
        }
        
        function showSeriesHint() {
            seriesHintShown = true;
            if (!areHintsEnabled()) return;
            
            const controller = allItems.find(i => i.type === 'controller');
            const arraySpecs = controller ? calculateConnectedArraySpecs(controller) : { voc: 0, panelCount: 0 };
            
            // Check if negative wire is connected to controller
            let hasNegativeConnection = false;
            if (controller) {
                const negConn = connections.find(c => 
                    c.targetHandleId === controller.handles.pvNegative.id || 
                    c.sourceHandleId === controller.handles.pvNegative.id
                );
                hasNegativeConnection = !!negConn;
            }
            
            const hintPopup = document.getElementById('hintPopup');
            let hintText = '';
            if (hasNegativeConnection) {
                hintText = `
                    <p style="margin: 0 0 8px 0;">To add more panels in series, first <strong>double-click the negative wire</strong> connecting the panel to the controller's PV- terminal to delete it.</p>
                    <p style="margin: 0 0 8px 0;">Then drag from the panel's - terminal to empty space to add more panels in series.</p>
                `;
            } else {
                hintText = `
                    <p style="margin: 0 0 8px 0;">Drag from the panel's - terminal to empty space to add more panels in series.</p>
                `;
            }
            
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #ffdd57;">‚ö° Expand Your Array</h3>
                        ${hintText}
                        <p style="margin: 0; color: #aaa; font-size: 12px;">
                            Series connection: <strong style="color: #ffdd57;">voltage adds up</strong>, current stays the same.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                        <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #5cb85c;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div id="livePanelCount" style="font-size: 10px; color: #888; margin-top: 2px;">${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
        }
        
        function showSeriesPanelHint() {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            let arraySpecs = controller ? calculateConnectedArraySpecs(controller) : { voc: 0, panelCount: 0 };
            
            // If no complete circuit, try to calculate partial string voltage
            if (arraySpecs.voc === 0 && arraySpecs.panelCount === 0 && controller) {
                // Find any panel connected to controller's PV+ (even if incomplete)
                if (controller.handles.pvPositive && controller.handles.pvPositive.connectedTo.length > 0) {
                    const firstConn = controller.handles.pvPositive.connectedTo[0];
                    const panel = allItems.find(i => i.id === firstConn.itemId);
                    if (panel && panel.type === 'panel') {
                        const handle = Object.values(panel.handles).find(h => h.id === firstConn.handleId);
                        if (handle) {
                            const partialSpecs = calculatePartialStringVoltage(panel, handle);
                            arraySpecs = {
                                voc: partialSpecs.voltage,
                                panelCount: partialSpecs.panelCount
                            };
                        }
                    }
                }
            }
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">‚ú® Panel Added!</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the new panel's - terminal to add more in series, or connect it back to the controller's PV- to complete the circuit.</p>
                        <p style="margin: 0; color: #aaa; font-size: 11px;">
                            <strong>Tips:</strong> Double-click wires to delete. Select nodes and press Delete to remove.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY Voc</div>
                        <div id="liveVoltageReadout" style="font-size: 22px; font-weight: bold; color: #5cb85c;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div id="livePanelCount" style="font-size: 10px; color: #888; margin-top: 2px;">${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesVoltageReadout, 200);
        }
        
        function updateSeriesVoltageReadout() {
            const readout = document.getElementById('liveVoltageReadout');
            if (!readout) {
                if (seriesVoltageInterval) {
                    clearInterval(seriesVoltageInterval);
                    seriesVoltageInterval = null;
                }
                return;
            }
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            // Try to get complete array specs first
            let arraySpecs = calculateConnectedArraySpecs(controller);
            let isPartial = false;
            
            // If no complete circuit, try to calculate partial string voltage
            if (arraySpecs.voc === 0 && arraySpecs.panelCount === 0) {
                // Find any panel connected to controller's PV+ (even if incomplete)
                if (controller.handles.pvPositive && controller.handles.pvPositive.connectedTo.length > 0) {
                    const firstConn = controller.handles.pvPositive.connectedTo[0];
                    const panel = allItems.find(i => i.id === firstConn.itemId);
                    if (panel && panel.type === 'panel') {
                        const handle = Object.values(panel.handles).find(h => h.id === firstConn.handleId);
                        if (handle) {
                            const partialSpecs = calculatePartialStringVoltage(panel, handle);
                            arraySpecs = {
                                voc: partialSpecs.voltage,
                                panelCount: partialSpecs.panelCount
                            };
                            isPartial = true;
                        }
                    }
                }
            }
            
            readout.textContent = arraySpecs.voc.toFixed(1) + 'V';
            
            // Update panel count too
            const countEl = document.getElementById('livePanelCount');
            if (countEl) {
                const countText = `${arraySpecs.panelCount} panel${arraySpecs.panelCount !== 1 ? 's' : ''}`;
                countEl.textContent = isPartial ? countText + ' (partial)' : countText;
                countEl.style.color = isPartial ? '#f0ad4e' : '#888'; // Orange for incomplete, gray for complete
            }
            
            // Change color based on controller limit (only if we have a controller to check against)
            if (arraySpecs.voc > 0) {
                if (arraySpecs.voc > controller.specs.maxVoc) {
                    readout.style.color = '#d9534f';
                } else if (arraySpecs.voc > controller.specs.maxVoc * 0.8) {
                    readout.style.color = '#f0ad4e';
                } else {
                    readout.style.color = '#5cb85c';
                }
            } else {
                readout.style.color = '#888';
            }
        }
        
        function showOptimalArrayHint(arraySpecs, batterySpecs, maxWattsAtBattery, maxWattsAt48V) {
            if (!areHintsEnabled()) return;
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üéâ Excellent Array Configuration!</h3>
                        <p style="margin: 0 0 8px 0;">
                            You've connected <strong style="color: #ffdd57;">${arraySpecs.wmp}W</strong> of solar panels without exceeding your controller's voltage limit!
                        </p>
                        <p style="margin: 0 0 8px 0; color: #aaa; font-size: 12px;">
                            But your <strong style="color: #f0ad4e;">${batterySpecs.voltage}V battery</strong> is limiting your controller's solar input to <strong>${maxWattsAtBattery}W</strong>.
                        </p>
                        <p style="margin: 0 0 8px 0; color: #5bc0de; font-size: 12px;">
                            With a <strong>48V battery</strong>, you could connect up to <strong>${maxWattsAt48V}W</strong> of solar panels!
                        </p>
                        <p style="margin: 0; color: #888; font-size: 11px;">
                            Try building a higher voltage battery pack by connecting batteries in series!
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(92, 184, 92, 0.2); border-radius: 8px; text-align: center; min-width: 110px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">ARRAY</div>
                        <div style="font-size: 18px; font-weight: bold; color: #5cb85c;">${arraySpecs.wmp}W</div>
                        <div style="font-size: 10px; color: #888; margin-top: 4px;">${arraySpecs.voc.toFixed(1)}V</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">MAX @ ${batterySpecs.voltage}V</div>
                            <div style="font-size: 14px; color: #f0ad4e;">${maxWattsAtBattery}W</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        function showSeriesBatteryHint() {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const batterySpecs = controller ? calculateConnectedBatterySpecs(controller) : { voltage: 0, kWh: 0 };
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5cb85c;">üîã Battery Added!</h3>
                        <p style="margin: 0 0 8px 0;">Drag from the new battery's terminal to add more in series, or connect it back to the controller's BATT terminals.</p>
                        <p style="margin: 0; color: #aaa; font-size: 11px;">
                            Series connection: <strong style="color: #ffdd57;">voltage adds up</strong>. Build 24V or 48V packs for more solar capacity!
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(40, 167, 69, 0.2); border-radius: 8px; text-align: center; min-width: 100px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">BANK VOLTAGE</div>
                        <div id="liveBatteryVoltage" style="font-size: 22px; font-weight: bold; color: #28a745;">${batterySpecs.voltage.toFixed(1)}V</div>
                        <div id="liveBatteryCount" style="font-size: 10px; color: #888; margin-top: 2px;">${batterySpecs.kWh.toFixed(2)} kWh</div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
            
            // Start live battery voltage updates
            if (seriesVoltageInterval) clearInterval(seriesVoltageInterval);
            seriesVoltageInterval = setInterval(updateSeriesBatteryReadout, 200);
        }
        
        function updateSeriesBatteryReadout() {
            const readout = document.getElementById('liveBatteryVoltage');
            if (!readout) {
                if (seriesVoltageInterval) {
                    clearInterval(seriesVoltageInterval);
                    seriesVoltageInterval = null;
                }
                return;
            }
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            readout.textContent = batterySpecs.voltage.toFixed(1) + 'V';
            
            // Update kWh too
            const kwhEl = document.getElementById('liveBatteryCount');
            if (kwhEl) {
                kwhEl.textContent = `${batterySpecs.kWh.toFixed(2)} kWh`;
            }
            
            // Change color based on voltage compatibility
            const supportedVoltages = controller.specs.supportedVoltages || [12, 24, 48];
            const maxSupported = Math.max(...supportedVoltages);
            
            if (batterySpecs.voltage > maxSupported) {
                readout.style.color = '#d9534f';
            } else if (!supportedVoltages.includes(Math.round(batterySpecs.voltage / 12) * 12)) {
                readout.style.color = '#f0ad4e';
            } else {
                readout.style.color = '#28a745';
            }
        }
        
        function showSuccessAnimation() {
            if (!areHintsEnabled()) return;
            
            // Create smooth green glow overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(92, 184, 92, 0.3) 0%, rgba(92, 184, 92, 0) 70%);
                pointer-events: none;
                z-index: 10001;
                opacity: 0;
                transition: opacity 0.4s ease-in-out;
            `;
            document.body.appendChild(overlay);
            
            // Fade in
            setTimeout(() => overlay.style.opacity = '1', 10);
            
            // Fade out and remove
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 400);
            }, 600);
            
            // Add a subtle green pulse to the canvas border
            const canvas = document.getElementById('canvas');
            canvas.style.boxShadow = '0 0 30px rgba(92, 184, 92, 0.6)';
            setTimeout(() => {
                canvas.style.transition = 'box-shadow 0.5s ease-out';
                canvas.style.boxShadow = 'none';
            }, 100);
            setTimeout(() => {
                canvas.style.transition = '';
            }, 600);
        }
        
        function startTutorial() {
            tutorialStep = 0;
            tutorialCompleted = false;
            
            const firstStep = TUTORIAL_STEPS[0];
            showHint(firstStep.title, firstStep.text);
        }
        
        // Calculate system statistics for review/display
        function calculateSystemStats() {
            const controllers = allItems.filter(i => i.type === 'controller');
            const panels = allItems.filter(i => i.type === 'panel');
            const batteries = allItems.filter(i => i.type === 'battery');
            
            // Initialize default stats
            let stats = {
                arrayWmp: 0,
                arrayVoc: 0,
                arrayVmp: 0,
                arrayIsc: 0,
                arrayImp: 0,
                panelCount: 0,
                seriesCount: 0,
                parallelCount: 0,
                batteryKwh: 0,
                batteryVoltage: 0,
                batteryAh: 0,
                batteryCount: 0,
                controllerName: 'None',
                controllerCount: 0,
                controllerMaxWmp: 0,
                controllerMaxVoc: 0,
                controllerRatedChargeCurrent: 0,
                cost: 0,
                optimization: 0,
                isOperational: false
            };
            
            // Calculate combined specs from ALL controllers (for hub-connected systems)
            if (controllers.length > 0) {
                let totalWmp = 0;
                let maxVoc = 0;
                let maxVmp = 0;
                let totalIsc = 0;
                let totalImp = 0;
                let totalPanelCount = 0;
                let maxSeriesCount = 0;
                let totalParallelCount = 0;
                let totalBatteryKwh = 0;
                let totalBatteryAh = 0;
                let totalBatteryCount = 0;
                let totalMaxWmp = 0;
                let maxMaxVoc = 0;
                let totalRatedChargeCurrent = 0;
                let controllerNames = [];
                let allOperational = true;
                
                controllers.forEach(controller => {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    
                    // Aggregate array specs
                    totalWmp += arraySpecs.wmp;
                    maxVoc = Math.max(maxVoc, arraySpecs.voc);
                    maxVmp = Math.max(maxVmp, arraySpecs.vmp);
                    totalIsc += arraySpecs.isc;
                    totalImp += arraySpecs.imp;
                    totalPanelCount += arraySpecs.panelCount;
                    maxSeriesCount = Math.max(maxSeriesCount, arraySpecs.seriesCount);
                    totalParallelCount += arraySpecs.parallelCount;
                    
                    // Aggregate battery specs
                    totalBatteryKwh += batterySpecs.kWh;
                    totalBatteryAh += batterySpecs.ah;
                    totalBatteryCount += batterySpecs.batteryCount;
                    
                    // Aggregate controller specs
                    totalMaxWmp += controller.specs.maxWmp || 0;
                    maxMaxVoc = Math.max(maxMaxVoc, controller.specs.maxVoc || 0);
                    totalRatedChargeCurrent += controller.specs.ratedChargeCurrent || 0;
                    
                    const controllerName = controller.specs.name || 'Unknown';
                    if (!controllerNames.includes(controllerName)) {
                        controllerNames.push(controllerName);
                    }
                    
                    // Check if this controller is operational
                    const pvPositive = controller.handles?.pvPositive;
                    const pvNegative = controller.handles?.pvNegative;
                    const batteryPositive = controller.handles?.batteryPositive;
                    const batteryNegative = controller.handles?.batteryNegative;
                    
                    const pvConnected = pvPositive && pvNegative && 
                                       pvPositive.connectedTo && pvNegative.connectedTo &&
                                       pvPositive.connectedTo.length > 0 && pvNegative.connectedTo.length > 0;
                    const battConnected = batteryPositive && batteryNegative &&
                                         batteryPositive.connectedTo && batteryNegative.connectedTo &&
                                         batteryPositive.connectedTo.length > 0 && batteryNegative.connectedTo.length > 0;
                    
                    // For all-in-one controllers, check if they have internal battery
                    const isAllInOne = controller.specs?.type === 'all_in_one' || controller.subtype === 'all_in_one';
                    const hasInternalBattery = isAllInOne && controller.specs?.internalBatteryKWh > 0;
                    
                    const controllerOperational = (pvConnected && (battConnected || hasInternalBattery)) && 
                                                  arraySpecs.wmp > 0 && batterySpecs.kWh > 0;
                    
                    if (!controllerOperational) {
                        allOperational = false;
                    }
                });
                
                // Set aggregated stats
                stats.arrayWmp = totalWmp;
                stats.arrayVoc = maxVoc;
                stats.arrayVmp = maxVmp;
                stats.arrayIsc = totalIsc;
                stats.arrayImp = totalImp;
                stats.panelCount = totalPanelCount;
                stats.seriesCount = maxSeriesCount;
                stats.parallelCount = totalParallelCount;
                
                stats.batteryKwh = totalBatteryKwh;
                stats.batteryAh = totalBatteryAh;
                stats.batteryCount = totalBatteryCount;
                
                // Use first controller's battery voltage (they should all be the same in parallel)
                if (controllers.length > 0) {
                    const firstBatterySpecs = calculateConnectedBatterySpecs(controllers[0]);
                    stats.batteryVoltage = firstBatterySpecs.voltage;
                }
                
                // Controller info
                stats.controllerCount = controllers.length;
                stats.controllerName = controllerNames.length === 1 ? controllerNames[0] : 
                                      controllerNames.length > 1 ? `${controllerNames[0]} (${controllers.length}x)` :
                                      'Unknown';
                stats.controllerMaxWmp = totalMaxWmp;
                stats.controllerMaxVoc = maxMaxVoc;
                stats.controllerRatedChargeCurrent = totalRatedChargeCurrent;
                
                // System is operational if all controllers are operational
                stats.isOperational = allOperational && totalWmp > 0 && totalBatteryKwh > 0;
                
                // Calculate optimization score (based on total array vs total controller capacity)
                if (totalWmp > 0 && totalMaxWmp > 0) {
                    stats.optimization = Math.min(100, (totalWmp / totalMaxWmp) * 100);
                }
            }
            
            // Calculate total cost (including wires)
            stats.cost = calculateTotalCost();
            
            return stats;
        }
        
        function showAchievement(title, stats) {
            if (!areHintsEnabled()) return;
            
            document.getElementById('achievementTitle').textContent = title;
            
            // Calculate daily energy estimate (assuming 4.5 peak sun hours)
            const peakSunHours = 4.5;
            const dailyKwh = (stats.arrayWmp * peakSunHours) / 1000;
            
            // Calculate cost metrics
            const costPerWatt = stats.arrayWmp > 0 ? (stats.cost / stats.arrayWmp).toFixed(2) : 0;
            const costPerKwh = stats.batteryKwh > 0 ? (stats.cost / stats.batteryKwh).toFixed(0) : 0;
            
            // Calculate payback (assuming $0.12/kWh grid cost)
            const gridCostPerKwh = 0.12;
            const annualSavings = dailyKwh * 365 * gridCostPerKwh;
            const paybackYears = annualSavings > 0 ? (stats.cost / annualSavings).toFixed(1) : '‚àû';
            
            const statsContainer = document.getElementById('achievementStats');
            statsContainer.innerHTML = `
                <div class="achievement-stat">
                    <div class="label">Array Power</div>
                    <div class="value">${stats.arrayWmp} W</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Array Voltage</div>
                    <div class="value">${stats.arrayVoc.toFixed(1)} V</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Battery Storage</div>
                    <div class="value">${stats.batteryKwh.toFixed(2)} kWh</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Battery Voltage</div>
                    <div class="value">${stats.batteryVoltage.toFixed(1)} V</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Optimization</div>
                    <div class="value">${stats.optimization.toFixed(0)}%</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Est. Daily Output</div>
                    <div class="value">${dailyKwh.toFixed(1)} kWh</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Total Cost</div>
                    <div class="value">$${stats.cost.toLocaleString()}</div>
                </div>
                <div class="achievement-stat">
                    <div class="label">Est. Payback</div>
                    <div class="value">${paybackYears} years</div>
                </div>
            `;
            
            document.getElementById('achievementOverlay').classList.add('visible');
        }
        
        // ============================================
        // SYSTEM REVIEW MODULE
        // ============================================
        const SystemReview = {
            // Configuration constants
            config: {
                peakSunHours: 4.5,
                gridCostPerKwh: 0.12
            },
            
            // Calculate system statistics with derived values
            calculateStats: function() {
                const stats = calculateSystemStats();
                const dailyKwh = (stats.arrayWmp * this.config.peakSunHours) / 1000;
                const annualSavings = dailyKwh * 365 * this.config.gridCostPerKwh;
                const paybackYears = annualSavings > 0 && stats.cost > 0 
                    ? (stats.cost / annualSavings).toFixed(1) 
                    : '‚àû';
                
                return {
                    ...stats,
                    dailyKwh,
                    annualSavings,
                    paybackYears
                };
            },
            
            // Format a single stat item
            formatStatItem: function(label, value, options = {}) {
                const valueClass = options.disabled ? 'system-review-stat-disabled' : '';
                return `
                    <div class="achievement-stat">
                        <div class="label">${label}</div>
                        <div class="value ${valueClass}">${value}</div>
                    </div>
                `;
            },
            
            // Render all stats HTML
            render: function(stats) {
                let statsHTML = '';
                
                // Panel stats
                if (stats.panelCount > 0) {
                    statsHTML += this.formatStatItem('Array Power', `${stats.arrayWmp} W`);
                    statsHTML += this.formatStatItem('Array Voltage', `${stats.arrayVoc.toFixed(1)} V`);
                    statsHTML += this.formatStatItem('Array Current', `${stats.arrayImp.toFixed(1)} A`);
                    statsHTML += this.formatStatItem('Panel Count', `${stats.panelCount} (${stats.parallelCount}P${stats.seriesCount}S)`);
                } else {
                    statsHTML += this.formatStatItem('Solar Panels', 'Not Connected', { disabled: true });
                }
                
                // Battery stats
                if (stats.batteryCount > 0) {
                    statsHTML += this.formatStatItem('Battery Storage', `${stats.batteryKwh.toFixed(2)} kWh`);
                    statsHTML += this.formatStatItem('Battery Voltage', `${stats.batteryVoltage.toFixed(1)} V`);
                    statsHTML += this.formatStatItem('Battery Count', `${stats.batteryCount}`);
                } else {
                    statsHTML += this.formatStatItem('Batteries', 'Not Connected', { disabled: true });
                }
                
                // Controller stats
                if (stats.controllerName !== 'None') {
                    statsHTML += this.formatStatItem(
                        `Controller${stats.controllerCount > 1 ? 's' : ''}`,
                        `${stats.controllerName}${stats.controllerCount > 1 ? ` (${stats.controllerCount}x)` : ''}`
                    );
                    statsHTML += this.formatStatItem(
                        `Max PV Input${stats.controllerCount > 1 ? ' (Combined)' : ''}`,
                        `${stats.controllerMaxWmp} W`
                    );
                    statsHTML += this.formatStatItem('Max Voc', `${stats.controllerMaxVoc} V`);
                    
                    if (stats.optimization > 0) {
                        statsHTML += this.formatStatItem('Optimization', `${stats.optimization.toFixed(0)}%`);
                    }
                }
                
                // Daily output
                if (stats.arrayWmp > 0) {
                    statsHTML += this.formatStatItem('Est. Daily Output', `${stats.dailyKwh.toFixed(1)} kWh`);
                }
                
                // Cost
                statsHTML += this.formatStatItem('Total Cost', `$${stats.cost.toLocaleString()}`);
                
                // Payback
                if (stats.isOperational && stats.cost > 0) {
                    statsHTML += this.formatStatItem('Est. Payback', `${stats.paybackYears} years`);
                }
                
                return statsHTML;
            },
            
            // Main entry point - show system review
            show: function() {
                const stats = this.calculateStats();
                
                // Set title based on system status
                const title = stats.isOperational ? 'üìä System Review' : 'üìä System Overview';
                document.getElementById('achievementTitle').textContent = title;
                
                // Build and display stats
                const statsContainer = document.getElementById('achievementStats');
                statsContainer.innerHTML = this.render(stats);
                
                // Update button visibility
                const startSimBtn = document.getElementById('startSimulation');
                const continueBtn = document.getElementById('achievementClose');
                
                // Add BOM button if it doesn't exist
                let bomBtn = document.getElementById('viewBomBtn');
                if (!bomBtn) {
                    const buttonContainer = document.querySelector('#achievementOverlay .achievement-content > div:last-child');
                    if (buttonContainer) {
                        bomBtn = document.createElement('button');
                        bomBtn.id = 'viewBomBtn';
                        bomBtn.textContent = 'üìã View Bill of Materials';
                        bomBtn.style.background = '#5bc0de';
                        bomBtn.style.marginRight = '10px';
                        buttonContainer.insertBefore(bomBtn, startSimBtn);
                        bomBtn.addEventListener('click', () => {
                            hideAchievement();
                            showBillOfMaterials();
                        });
                    }
                }
                bomBtn.style.display = 'inline-block';
                
                if (stats.isOperational) {
                    startSimBtn.style.display = 'inline-block';
                    continueBtn.textContent = 'Continue Building';
                } else {
                    startSimBtn.style.display = 'none';
                    continueBtn.textContent = 'Close';
                }
                
                document.getElementById('achievementOverlay').classList.add('visible');
            }
        };
        
        // Legacy function for backward compatibility
        function showSystemReview() {
            SystemReview.show();
        }
        
        function hideAchievement() {
            document.getElementById('achievementOverlay').classList.remove('visible');
        }
        
        // ============================================
        // COMPONENT LIBRARY
        // ============================================
        
        function populateLibraries() {
            // Panels
            const panelLibrary = document.getElementById('panelLibrary');
            panelLibrary.innerHTML = PANEL_PRESETS.map((p, i) => `
                <div class="component-item" data-preset-type="panel" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${p.name}</div>
                        <div class="component-specs">${p.wmp}W | ${p.vmp}V | $${p.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Batteries
            const batteryLibrary = document.getElementById('batteryLibrary');
            batteryLibrary.innerHTML = BATTERY_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="battery" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.voltage}V | ${b.ah}Ah | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Controllers
            const controllerLibrary = document.getElementById('controllerLibrary');
            controllerLibrary.innerHTML = CONTROLLER_PRESETS.map((c, i) => `
                <div class="component-item" data-preset-type="controller" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${c.name}</div>
                        <div class="component-specs">${c.maxVoc}V / ${c.ratedChargeCurrent}A | ${c.supportedVoltages.join('/')}V | $${c.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Breakers
            const breakerLibrary = document.getElementById('breakerLibrary');
            breakerLibrary.innerHTML = BREAKER_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="breaker" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.maxVoltage}V DC | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Combiners
            const combinerLibrary = document.getElementById('combinerLibrary');
            combinerLibrary.innerHTML = COMBINER_PRESETS.map((c, i) => `
                <div class="component-item" data-preset-type="combiner" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${c.name}</div>
                        <div class="component-specs">${c.inputs} inputs | ${c.maxAmpsPerInput}A/input | $${c.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // Solar Combiner Boxes
            const solarCombinerLibrary = document.getElementById('solarCombinerLibrary');
            solarCombinerLibrary.innerHTML = SOLAR_COMBINER_PRESETS.map((s, i) => `
                <div class="component-item" data-preset-type="solarcombiner" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${s.name}</div>
                        <div class="component-specs">${s.inputs}x ${s.breakerRating}A breakers | $${s.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // EcoFlow Ecosystem
            const ecoflowLibrary = document.getElementById('ecoflowLibrary');
            ecoflowLibrary.innerHTML = `
                <div class="component-item" data-preset-type="doublevoltagehub" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">Double Voltage Hub</div>
                        <div class="component-specs">120V/240V ‚Ä¢ 7200W | $400</div>
                    </div>
                </div>
            `;
            
            // AC Breakers
            const acBreakerLibrary = document.getElementById('acBreakerLibrary');
            acBreakerLibrary.innerHTML = AC_BREAKER_PRESETS.map((b, i) => `
                <div class="component-item" data-preset-type="acbreaker" data-preset-index="${i}">
                    <div class="component-info">
                        <div class="component-name">${b.name}</div>
                        <div class="component-specs">${b.maxWatts}W max | $${b.cost}</div>
                    </div>
                </div>
            `).join('');
            
            // AC Outlets
            const acOutletLibrary = document.getElementById('acOutletLibrary');
            acOutletLibrary.innerHTML = `
                <div class="component-item" data-preset-type="acoutlet" data-preset-index="120">
                    <div class="component-info">
                        <div class="component-name">120V Outlet</div>
                        <div class="component-specs">15A NEMA 5-15 | $5</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="acoutlet" data-preset-index="240">
                    <div class="component-info">
                        <div class="component-name">240V Outlet</div>
                        <div class="component-specs">30A NEMA 14-30 | $25</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="spiderbox" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">CEP Spider Box</div>
                        <div class="component-specs">240V 50A In ‚Ä¢ 6 circuits | $450</div>
                    </div>
                </div>
                <div class="component-item" data-preset-type="breakerpanel" data-preset-index="0">
                    <div class="component-info">
                        <div class="component-name">100A Breaker Panel</div>
                        <div class="component-specs">240V 100A ‚Ä¢ 8 circuits | $250</div>
                    </div>
                </div>
            `;
            
            // Add click handlers
            document.querySelectorAll('.component-item').forEach(el => {
                el.addEventListener('click', () => {
                    const type = el.dataset.presetType;
                    const index = parseInt(el.dataset.presetIndex);
                    addComponentFromPreset(type, index);
                });
            });
            
            // Resource container buttons
            document.querySelectorAll('#resourceContainerLibrary .library-item').forEach(btn => {
                btn.addEventListener('click', () => {
                    const resourceType = btn.dataset.resource;
                    const x = svgWidth / 2 - 50 + Math.random() * 100;
                    const y = svgHeight / 2 - 50 + Math.random() * 100;
                    const container = createResourceContainer(x, y, resourceType);
                    allItems.push(container);
                    render();
                });
            });
            
            // Processor library removed - processors are now available as appliances
        }
        
        function addComponentFromPreset(type, index) {
            const x = svgWidth / 2 - 50 + Math.random() * 100;
            const y = svgHeight / 2 - 50 + Math.random() * 100;
            
            let item;
            if (type === 'panel') {
                item = createPanel(x, y, PANEL_PRESETS[index]);
            } else if (type === 'battery') {
                item = createBattery(x, y, BATTERY_PRESETS[index]);
            } else if (type === 'controller') {
                item = createController(x, y, CONTROLLER_PRESETS[index]);
            } else if (type === 'breaker') {
                item = createBreaker(x, y, BREAKER_PRESETS[index]);
            } else if (type === 'combiner') {
                item = createCombiner(x, y, COMBINER_PRESETS[index]);
            } else if (type === 'solarcombiner') {
                item = createSolarCombinerBox(x, y, SOLAR_COMBINER_PRESETS[index]);
            } else if (type === 'doublevoltagehub') {
                item = createDoubleVoltageHub(x, y);
            } else if (type === 'acbreaker') {
                item = createACBreaker(x, y, AC_BREAKER_PRESETS[index]);
            } else if (type === 'acoutlet') {
                // index is voltage (120 or 240)
                item = createACOutlet(x, y, index);
            } else if (type === 'spiderbox') {
                item = createSpiderBox(x, y);
            } else if (type === 'breakerpanel') {
                item = createBreakerPanel(x, y);
            }
            
            if (item) {
                allItems.push(item);
                if (item.type === 'panel' && typeof updatePanelArrayArea === 'function') {
                    updatePanelArrayArea();
                }
                render();
            }
        }
        
        // ============================================
        // MODE SWITCHING
        // ============================================
        
        function setMode(mode) {
            currentMode = mode;
            
            document.getElementById('buildModeBtn').classList.toggle('active', mode === 'build');
            document.getElementById('liveViewModeBtn').classList.toggle('active', mode === 'live');
            document.getElementById('simulateModeBtn').classList.toggle('active', mode === 'simulate');
            
            // buildControls was removed, so check if it exists before accessing
            const buildControls = document.getElementById('buildControls');
            if (buildControls) {
                buildControls.classList.toggle('hidden', mode !== 'build');
            }
            
            const liveViewControls = document.getElementById('liveViewControls');
            if (liveViewControls) {
                liveViewControls.classList.toggle('hidden', mode !== 'live');
            }
            
            // Show/hide left-side power summary in live mode
            const liveViewPowerSummaryLeft = document.getElementById('liveViewPowerSummaryLeft');
            if (liveViewPowerSummaryLeft) {
                liveViewPowerSummaryLeft.classList.toggle('hidden', mode !== 'live');
            }
            
            const simulateControls = document.getElementById('simulateControls');
            if (simulateControls) {
                simulateControls.classList.toggle('hidden', mode !== 'simulate');
            }
            
            // Show/hide simulate mode specific buttons
            const challengeModeBtn = document.getElementById('challengeModeBtn');
            const weatherControls = document.querySelector('.weather-controls');
            if (challengeModeBtn) challengeModeBtn.classList.toggle('hidden', mode !== 'simulate');
            if (weatherControls) weatherControls.classList.toggle('hidden', mode !== 'simulate');
            
            // Show/hide simulation stats section
            document.getElementById('simStatsSection').style.display = mode === 'simulate' ? 'block' : 'none';
            
            if (mode === 'live') {
                // Initialize live view mode
                LiveView.initialize();
            } else if (mode === 'simulate') {
                // Check if system is valid for simulation
                const controller = allItems.find(i => i.type === 'controller');
                if (controller) {
                    const arraySpecs = calculateConnectedArraySpecs(controller);
                    const batterySpecs = calculateConnectedBatterySpecs(controller);
                    
                    if (arraySpecs.wmp === 0 || batterySpecs.kWh === 0) {
                        showHint("‚ö†Ô∏è Incomplete System", 
                            "Your system needs connected solar panels and batteries to simulate. " +
                            "Go back to Build mode and complete the connections.");
                        return;
                    }
                    
                    // Stop any running simulation
                    if (isPlaying) {
                        playPause();
                    }
                    
                    // Initialize inline simulation
                    initializeSimulationFromBuild();
                    
                    // Initialize visual state
                    const hourOfDay = Math.floor(elapsedHours) % 24;
                    updateBackgroundColor(hourOfDay);
                    updateShadowAngle(hourOfDay);
                    
                    // Show hint about simulation
                    showSimulationStartHint(arraySpecs, batterySpecs);
                    
                    // Update display
                    updateTimeDisplay();
                    updateSimulationDisplay();
                    render();
                } else {
                    showHint("‚ö†Ô∏è No Controller", 
                        "Add a charge controller to your system before simulating.");
                }
            } else {
                // Stop simulation when switching to build mode
                if (isPlaying) {
                    playPause();
                }
                // Stop live view animation when switching away
                LiveView.stop();
            }
        }
        
        
        function initializeSimulationFromBuild() {
            resetSimulation();
            
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            const arraySpecs = calculateConnectedArraySpecs(controller);
            const batterySpecs = calculateConnectedBatterySpecs(controller);
            
            // Store the built system specs for simulation
            simStats.systemSpecs = {
                arrayWmp: arraySpecs.wmp,
                arrayVoc: arraySpecs.voc,
                arrayImp: arraySpecs.imp,
                arrayConfig: arraySpecs.config,
                batteryKwh: batterySpecs.kWh,
                batteryVoltage: batterySpecs.voltage,
                controllerMaxWatts: getMaxWattsForController(controller, batterySpecs.voltage),
                controllerMaxIsc: controller.specs.maxIsc
            };
            
            // Initialize battery charge to 20% (morning scenario)
            simStats.maxBatteryCapacity = batterySpecs.kWh;
            simStats.batteryCharge = batterySpecs.kWh * 0.2;
            
            updateSimulationDisplay();
        }
        
        function showSimulationStartHint(arraySpecs, batterySpecs) {
            if (!areHintsEnabled()) return;
            const controller = allItems.find(i => i.type === 'controller');
            const maxWatts = controller ? getMaxWattsForController(controller, batterySpecs.voltage) : 0;
            
            const hintPopup = document.getElementById('hintPopup');
            hintPopup.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 8px 0; color: #5bc0de;">‚ñ∂ Simulation Started!</h3>
                        <p style="margin: 0 0 8px 0;">
                            Your <strong>${arraySpecs.wmp}W</strong> solar array and <strong>${batterySpecs.kWh.toFixed(2)} kWh</strong> battery are now simulating.
                        </p>
                        <p style="margin: 0; color: #aaa; font-size: 12px;">
                            Press <strong>Play</strong> to start time progression. Watch your battery charge during the day and discharge at night.
                            Use the speed slider to fast-forward through days.
                        </p>
                        <button onclick="hideHint()" style="margin-top: 10px;">Got it</button>
                    </div>
                    <div style="padding: 10px 15px; background: rgba(91, 192, 222, 0.2); border-radius: 8px; text-align: center; min-width: 110px;">
                        <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">SYSTEM</div>
                        <div style="font-size: 16px; font-weight: bold; color: #5bc0de;">${arraySpecs.config || '1P1S'}</div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">${arraySpecs.wmp}W / ${batterySpecs.kWh.toFixed(1)}kWh</div>
                        <div style="border-top: 1px solid #444; margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 10px; color: #aaa;">BATTERY</div>
                            <div style="font-size: 14px; color: #5cb85c;">20%</div>
                        </div>
                    </div>
                </div>
            `;
            hintPopup.classList.remove('hidden');
        }
        
        // ============================================
        // SIMULATION
        // ============================================
        
        // Simulation stats
        let simStats = {
            controllerACOutputEnabled: true, // Track if controller AC output is enabled (disabled when battery is low)
            totalSolarGenerated: 0,
            totalEnergyUsed: 0,
            batteryCharge: 0,
            maxBatteryCapacity: 0,
            peakPower: 0,
            currentSolarOutput: 0, // Current solar output in watts
            currentLoadPower: 0, // Current total load power consumption in watts
            loadConsumption: {}, // Track per-load power consumption: { loadId: { watts, kwh } }
            inverterLoadConsumption: {} // Track per-controller inverter load consumption: { controllerId: { watts, kwh } }
        };
        
        // ========== SOLAR CALCULATION FUNCTIONS ==========
        
        // Convert day of year to month and day for display
        function dayOfYearToDate(dayOfYear) {
            const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                           'July', 'August', 'September', 'October', 'November', 'December'];
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            
            let day = dayOfYear;
            let month = 0;
            
            while (month < 12 && day > daysInMonth[month]) {
                day -= daysInMonth[month];
                month++;
            }
            
            // Short month names for display
            const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            return {
                month: month,
                day: day,
                monthName: months[month],
                shortMonth: shortMonths[month],
                formatted: `${shortMonths[month]} ${day}`
            };
        }
        
        // Calculate daylight hours based on latitude and day of year
        function getDaylightHours(latitude, dayOfYear) {
            // Solar declination angle (simplified equation)
            const declination = 23.45 * Math.sin((360/365) * (dayOfYear - 81) * Math.PI / 180);
            const latRad = latitude * Math.PI / 180;
            const decRad = declination * Math.PI / 180;
            
            // Hour angle at sunrise/sunset
            const cosHourAngle = -Math.tan(latRad) * Math.tan(decRad);
            
            // Handle polar regions
            if (cosHourAngle > 1) return 0;   // Polar night
            if (cosHourAngle < -1) return 24; // Midnight sun
            
            const hourAngle = Math.acos(cosHourAngle) * 180 / Math.PI;
            const daylightHours = 2 * hourAngle / 15;
            
            return daylightHours;
        }
        
        // Get sunrise and sunset times
        function getSunriseSunset(latitude, dayOfYear) {
            const daylight = getDaylightHours(latitude, dayOfYear);
            const solarNoon = 12; // Simplified (ignores longitude/timezone)
            
            return {
                sunrise: Math.max(0, solarNoon - daylight / 2),
                sunset: Math.min(24, solarNoon + daylight / 2),
                daylight: daylight
            };
        }
        
        // Calculate seasonal irradiance intensity based on sun angle
        function getSeasonalIrradianceFactor(latitude, dayOfYear, hourOfDay) {
            const declination = 23.45 * Math.sin((360/365) * (dayOfYear - 81) * Math.PI / 180);
            const latRad = latitude * Math.PI / 180;
            const decRad = declination * Math.PI / 180;
            
            // Hour angle (15 degrees per hour from solar noon)
            const hourAngle = (hourOfDay - 12) * 15 * Math.PI / 180;
            
            // Solar elevation angle
            const sinElevation = Math.sin(latRad) * Math.sin(decRad) + 
                                 Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngle);
            
            // Return 0 if sun is below horizon
            if (sinElevation <= 0) return 0;
            
            // Air mass factor (atmosphere attenuation at low angles)
            // Simplified Kasten-Young formula
            const elevation = Math.asin(sinElevation) * 180 / Math.PI;
            const airMass = 1 / (sinElevation + 0.50572 * Math.pow(elevation + 6.07995, -1.6364));
            
            // Atmospheric attenuation (Beer-Lambert approximation)
            const atmosphericTransmittance = Math.pow(0.7, Math.pow(airMass, 0.678));
            
            // Combine elevation angle effect with atmospheric attenuation
            return sinElevation * atmosphericTransmittance;
        }
        
        // Get summer solstice day for given latitude (June 21 for North, Dec 21 for South)
        function getSummerSolsticeDay(latitude) {
            return latitude >= 0 ? 172 : 355; // June 21 or December 21
        }
        
        // Main solar irradiance function with latitude and seasonal effects
        function getSolarIrradiance(hourOfDay, dayOfYear = null, latitude = null) {
            // Use global values if not provided
            if (dayOfYear === null) dayOfYear = currentDayOfYear;
            if (latitude === null) latitude = simulationLatitude;
            
            // Get sunrise/sunset for this day and location
            const { sunrise, sunset, daylight } = getSunriseSunset(latitude, dayOfYear);
            
            // Night time - no solar output
            if (hourOfDay < sunrise || hourOfDay >= sunset) return 0;
            
            // Sinusoidal curve within daylight hours (peaks at solar noon)
            const dayLength = sunset - sunrise;
            if (dayLength <= 0) return 0;
            
            const normalizedHour = (hourOfDay - sunrise) / dayLength;
            const baseCurve = Math.sin(normalizedHour * Math.PI);
            
            // Apply seasonal/angular intensity factor
            const seasonalFactor = getSeasonalIrradianceFactor(latitude, dayOfYear, hourOfDay);
            
            // Normalize seasonal factor (peak summer midday = ~0.9, winter midday = ~0.5)
            // This gives a realistic range of output
            const normalizedSeasonal = Math.min(1, seasonalFactor * 1.2);
            
            // Combine with efficiency derating (60% for real-world conditions: temp, dust, etc.)
            return baseCurve * normalizedSeasonal * 0.6;
        }
        
        // Evaluate if a load should be ON based on its schedule and current hour
        function evaluateLoadSchedule(load, hourOfDay) {
            if (!load || !load.specs || !load.specs.behavior) return false;
            
            // If automations exist and have set isRunning, use that state
            if (load.automations && load.automations.length > 0 && load.simState) {
                return load.simState.isRunning || false;
            }
            
            const behavior = load.specs.behavior;
            
            if (behavior.type === 'constant') {
                // Constant loads are always on (user controls via LiveView)
                // For simulation, we'll check if they were on in live mode or use a default
                return true; // Will be filtered by actual load states
            } else if (behavior.type === 'scheduled') {
                const schedule = behavior.schedule;
                if (!schedule) return false;
                
                // Parse trigger times (using dynamic sunrise/sunset)
                const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
                const parseTrigger = (trigger) => {
                    if (trigger === 'sunrise') return Math.floor(sunrise);
                    if (trigger === 'sunset') return Math.floor(sunset);
                    // Parse "HH:MM" format
                    const match = trigger.match(/(\d{1,2}):(\d{2})/);
                    if (match) {
                        return parseInt(match[1], 10);
                    }
                    return 0;
                };
                
                const onHour = parseTrigger(schedule.onTrigger || 'sunset');
                const offHour = parseTrigger(schedule.offTrigger || 'sunrise');
                
                // Handle time ranges that cross midnight
                if (onHour > offHour) {
                    return hourOfDay >= onHour || hourOfDay < offHour;
                } else {
                    return hourOfDay >= onHour && hourOfDay < offHour;
                }
            } else if (behavior.type === 'thermostat') {
                // Thermostat loads use duty cycle - simplified: on during day, off at night
                // More sophisticated: could use temperature simulation
                return hourOfDay >= 6 && hourOfDay < 22;
            } else if (behavior.type === 'charging') {
                // Charging loads: check if battery needs charging
                // Simplified: charge during day when solar is available
                return hourOfDay >= 6 && hourOfDay < 20;
            } else if (behavior.type === 'batch') {
                // Batch loads: check recipe automations
                const recipes = behavior.recipes || [];
                if (recipes.length === 0) return false;
                
                // Check if any recipe has automation/schedule
                for (const recipe of recipes) {
                    if (recipe.automation) {
                        const auto = recipe.automation;
                        if (auto.type === 'schedule') {
                            // Schedule-based automation (using dynamic sunrise/sunset)
                            const { sunrise: batchSunrise, sunset: batchSunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
                            const parseTrigger = (trigger) => {
                                if (trigger === 'sunrise') return Math.floor(batchSunrise);
                                if (trigger === 'sunset') return Math.floor(batchSunset);
                                const match = trigger.match(/(\d{1,2}):(\d{2})/);
                                if (match) return parseInt(match[1], 10);
                                return 0;
                            };
                            
                            const onHour = parseTrigger(auto.onTrigger || 'sunset');
                            const offHour = parseTrigger(auto.offTrigger || 'sunrise');
                            
                            if (onHour > offHour) {
                                if (hourOfDay >= onHour || hourOfDay < offHour) return true;
                            } else {
                                if (hourOfDay >= onHour && hourOfDay < offHour) return true;
                            }
                        } else if (auto.type === 'interval') {
                            // Interval-based: run every N hours
                            const interval = auto.intervalHours || 24;
                            if (hourOfDay % interval === 0) return true;
                        } else if (auto.type === 'always') {
                            // Always run when conditions are met
                            return true;
                        }
                    } else {
                        // No automation - check if load has been manually triggered
                        // For simulation, we'll use a default schedule (e.g., during day)
                        return hourOfDay >= 6 && hourOfDay < 20;
                    }
                }
                
                // Default: batch loads run during day hours
                return hourOfDay >= 6 && hourOfDay < 20;
            }
            
            return false;
        }
        
        // Calculate total load consumption for current hour
        function calculateLoadConsumption(hourOfDay) {
            let totalWatts = 0;
            
            // Initialize load state tracking if not exists
            const loads = allItems.filter(i => i.type === 'acload');
            loads.forEach(load => {
                // Initialize simulation state
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0
                    };
                }
                
                // Check if load's circuit is live - loads can only consume power when circuit is live
                // This handles low-battery shutdown (controller AC output disabled) and other circuit issues
                const loadConn = connections.find(c => {
                    const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                    const targetItem = allItems.find(i => i.id === c.targetItemId);
                    return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                           (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
                });
                
                if (loadConn) {
                    const outlet = allItems.find(i => 
                        (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                        i.type === 'acoutlet'
                    );
                    if (outlet) {
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) {
                            // Circuit is not live - no power consumption (controller AC output disabled or breaker tripped)
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (LiveView.state && LiveView.state.loadStates) {
                                LiveView.state.loadStates[load.id] = false;
                            }
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return; // Skip power calculation for this load
                        }
                    }
                }
                
                // Check if load has automations - if so, automation state takes precedence
                const hasAutomations = load.automations && load.automations.length > 0;
                
                if (hasAutomations) {
                    // Automation-controlled load - use simState.isRunning set by executeLoadAutomations
                    // Automation state takes absolute precedence - don't check manual toggle or schedule
                    // The automation system has already set isRunning based on automation rules
                    if (!load.simState.isRunning) {
                        // Automation says off - no power consumption
                        load.simState.currentPowerWatts = 0;
                        if (!simStats.loadConsumption[load.id]) {
                            simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                        }
                        return; // Skip power calculation for this load
                    }
                    // Automation says on - continue to calculate power consumption below
                    // Don't check manual toggle state - automation controls this load
                } else {
                    // No automations - check manual state first (for constant loads) or schedule
                    const behavior = load.specs.behavior || { type: 'constant' };
                    
                    // For constant loads, manual toggle state (LiveView.state.loadStates) is the primary control
                    if (behavior.type === 'constant') {
                        if (LiveView.state && LiveView.state.loadStates) {
                            const isActuallyOn = LiveView.state.loadStates[load.id] === true;
                            if (!isActuallyOn) {
                                // Constant load is manually turned off - no power consumption
                                load.simState.isRunning = false;
                                load.simState.currentPowerWatts = 0;
                                if (!simStats.loadConsumption[load.id]) {
                                    simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                                }
                                return; // Skip power calculation for this load
                            }
                            // Constant load is manually turned on - set isRunning and continue
                            load.simState.isRunning = true;
                        } else {
                            // No LiveView state - default to off for constant loads
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return;
                        }
                    } else {
                        // Non-constant loads - check schedule first
                        const shouldBeOn = evaluateLoadSchedule(load, hourOfDay);
                        if (!shouldBeOn) {
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return; // Skip power calculation for this load
                        }
                        
                        // Check if load is manually turned off (overrides schedule)
                        if (LiveView.state && LiveView.state.loadStates && LiveView.state.loadStates[load.id] === false) {
                            // Load is explicitly turned off (regardless of schedule) - no power consumption
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (!simStats.loadConsumption[load.id]) {
                                simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                            }
                            return;
                        }
                        
                        load.simState.isRunning = true;
                    }
                }
                
                // Get load power consumption
                const behavior = load.specs.behavior || { type: 'constant' };
                
                let loadWatts = 0;
                let powerMultiplier = 1.0; // For batch loads, adjust based on batch duration
                
                if (behavior.type === 'constant' || behavior.type === 'simple') {
                    // Simple and constant loads use avgWatts (or maxWatts as fallback)
                    loadWatts = load.specs.avgWatts || load.specs.maxWatts || 0;
                    // Power calculated for simple/constant load
                } else if (behavior.type === 'scheduled') {
                    // Scheduled loads use maxWatts when on
                    loadWatts = load.specs.maxWatts || load.specs.avgWatts || 0;
                } else if (behavior.type === 'thermostat') {
                    // Thermostat: use duty cycle percentage
                    const dutyPercent = behavior.dutyPercent || 50;
                    loadWatts = (load.specs.maxWatts || 0) * (dutyPercent / 100);
                } else if (behavior.type === 'charging') {
                    // Charging: use charge rate
                    const chargeRateKw = behavior.chargeRateKw || 0.5;
                    loadWatts = chargeRateKw * 1000; // Convert kW to W
                } else if (behavior.type === 'recipe' || (load.specs.recipes && load.specs.recipes.length > 0)) {
                    // Recipe-based loads: handle recipe processing with time-based power consumption
                    const recipes = load.specs.recipes || [];
                    if (recipes.length > 0) {
                        // Get active recipe
                        const activeRecipeIndex = load.activeRecipeIndex !== null && load.activeRecipeIndex !== undefined 
                            ? load.activeRecipeIndex 
                            : 0;
                        const recipe = recipes[activeRecipeIndex] || recipes[0];
                        
                        // If load is running (via automation or manual), calculate power consumption
                        if (load.simState.isRunning) {
                            // Check if we're processing a recipe OR about to start one (pendingRecipeStart)
                            if (load.isProcessing || load.simState.isProcessing || load.pendingRecipeStart) {
                                load.simState.isProcessing = true;
                                
                                // Calculate power consumption based on recipe duration and energy
                                // Note: durationHours is the canonical field, durationMin is legacy
                                const durationHours = recipe.durationHours || (recipe.durationMin ? recipe.durationMin / 60.0 : 1);
                                const energyWh = recipe.energyWh || 0;
                                
                                // Calculate power for this hour (energy / duration)
                                // Power calculation only - time tracking is done in processRecipeLoads
                                if (durationHours > 0) {
                                    loadWatts = energyWh / durationHours; // Watts = Wh / hours
                                } else {
                                    loadWatts = 0;
                                }
                            } else {
                                // Not processing yet - will start in processRecipeLoads if conditions are met
                                // Show small standby power to indicate load is ON but awaiting inputs
                                loadWatts = 5; // 5W standby power while awaiting inputs
                                // Recipe load on standby awaiting inputs
                            }
                        } else {
                            // Load is not running - no power consumption
                            loadWatts = 0;
                        }
                    }
                } else if (behavior.type === 'batch') {
                    // Legacy batch loads: handle batch processing with time-based power consumption
                    const recipes = behavior.recipes || [];
                    if (recipes.length > 0) {
                        // Check if we're in an active batch
                        if (load.simState.isInBatch) {
                                // Calculate power consumption based on batch duration
                                // Find the active recipe (simplified: use first recipe for now)
                                const recipe = recipes[0];
                                const batchDurationHours = (recipe.durationMin || 2) / 60.0; // Convert minutes to hours
                                
                                // Update batch time elapsed
                                load.simState.batchTimeElapsed += 1.0; // 1 hour
                                
                                // Calculate power for this hour (proportional to batch duration)
                                if (load.simState.batchTimeElapsed < batchDurationHours) {
                                    // Still in batch - consume power for the remaining time (max 1 hour)
                                    const remainingTime = Math.min(1.0, batchDurationHours - (load.simState.batchTimeElapsed - 1.0));
                                    powerMultiplier = remainingTime;
                                    loadWatts = (recipe.energyWh / batchDurationHours) * 1000; // Convert Wh to W, then scale
                                } else {
                                    // Batch complete
                                    load.simState.isInBatch = false;
                                    load.simState.batchTimeElapsed = 0;
                                    loadWatts = 0; // No power consumption after batch completes
                                }
                            } else {
                                // Not in batch - check if we should start one
                                // For now, batch loads are triggered by schedule or manual
                                // If schedule says on, start a batch
                                load.simState.isInBatch = true;
                                load.simState.batchTimeElapsed = 0;
                                const recipe = recipes[0];
                                const batchDurationHours = (recipe.durationMin || 2) / 60.0;
                                // Consume power for the batch duration (or 1 hour max)
                                powerMultiplier = Math.min(1.0, batchDurationHours);
                                loadWatts = (recipe.energyWh / batchDurationHours) * 1000;
                            }
                        } else {
                            // No recipes - fallback to average calculation
                            loadWatts = load.specs.avgWatts || load.specs.maxWatts || 0;
                        }
                }
                
                // Apply power multiplier for batch loads
                loadWatts = loadWatts * powerMultiplier;
                
                // Track individual load consumption
                if (!simStats.loadConsumption[load.id]) {
                    simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                }
                simStats.loadConsumption[load.id].watts = loadWatts;
                load.simState.currentPowerWatts = loadWatts;
                
                totalWatts += loadWatts;
            });
            
            return totalWatts / 1000; // Convert to kW
        }
        
        // Execute automation rules for load nodes
        function executeLoadAutomations(hourOfDay) {
            const loads = allItems.filter(i => i.type === 'acload' && i.automations && i.automations.length > 0);
            
            // Process automations for all loads with automation rules
            
            loads.forEach(load => {
                // Initialize simState if needed
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0,
                        wasAutoShutoff: false // Track if load was auto-shutoff due to low battery
                    };
                }
                
                // Check if load's circuit is live - automations only apply when circuit is live
                // If circuit is not live (e.g., controller AC output disabled due to low battery),
                // turn off load and skip automation processing
                const loadConn = connections.find(c => {
                    const sourceItem = allItems.find(i => i.id === c.sourceItemId);
                    const targetItem = allItems.find(i => i.id === c.targetItemId);
                    return (sourceItem?.id === load.id && targetItem?.type === 'acoutlet') ||
                           (targetItem?.id === load.id && sourceItem?.type === 'acoutlet');
                });
                
                if (loadConn) {
                    const outlet = allItems.find(i => 
                        (i.id === loadConn.sourceItemId || i.id === loadConn.targetItemId) &&
                        i.type === 'acoutlet'
                    );
                    if (outlet) {
                        const circuitStatus = checkOutletCircuitStatus(outlet);
                        if (!circuitStatus.isLive) {
                            // Circuit is not live - turn off load and skip automation processing
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (LiveView.state && LiveView.state.loadStates) {
                                LiveView.state.loadStates[load.id] = false;
                            }
                            return; // Skip automation processing - circuit is not live
                        }
                    }
                }
                
                // Process all automations and determine final state
                // turnOff takes precedence over turnOn
                let shouldBeOn = false;
                let shouldBeOff = false;
                
                load.automations.forEach(automation => {
                    let shouldTrigger = false;
                    
                    if (automation.triggerType === 'timeOfDay') {
                        const startHour = automation.startHour || 18;
                        const endHour = automation.endHour || 6;
                        // Determine if we're currently in the time range
                        let isInRange = false;
                        if (startHour > endHour) {
                            // Range crosses midnight (e.g., 18:00 to 6:00)
                            isInRange = hourOfDay >= startHour || hourOfDay < endHour;
                        } else {
                            // Range within same day (e.g., 6:00 to 18:00)
                            isInRange = hourOfDay >= startHour && hourOfDay < endHour;
                        }
                        
                        // For time-based automations with "turnOn" action:
                        // - If we're in the time range, turn on
                        // - If we're outside the time range, turn off
                        // This allows a single automation to handle both on and off
                        if (automation.action === 'turnOn') {
                            shouldTrigger = isInRange; // Turn on when in range
                            // Also check if we should turn off when outside range
                            if (!isInRange) {
                                // We're outside the range - trigger turnOff
                                shouldBeOff = true;
                            }
                        } else if (automation.action === 'turnOff') {
                            // TurnOff action means turn off during this time range
                            shouldTrigger = isInRange;
                        } else if (automation.action === 'startRecipe') {
                            // For startRecipe, trigger when we're in the time range
                            // This allows recipes to start either at the exact start hour,
                            // or when simulation starts/resumes within the time range
                            shouldTrigger = isInRange;
                            // Recipe time trigger evaluated
                        }
                    } else if (automation.triggerType === 'batteryLevel') {
                        // Find target battery by label or name, or use first battery if no label specified
                        let targetBattery = null;
                        if (automation.targetNodeLabel) {
                            targetBattery = allItems.find(i => 
                                i.type === 'battery' && 
                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                            );
                        }
                        // If no specific battery found, use the controller's connected battery capacity
                        if (!targetBattery) {
                            const controller = allItems.find(i => i.type === 'controller');
                            if (controller) {
                                const batterySpecs = calculateConnectedBatterySpecs(controller);
                                // Use simStats for current charge and capacity
                                const currentKwh = simStats && simStats.batteryCharge !== undefined 
                                    ? simStats.batteryCharge 
                                    : 0;
                                const capacity = simStats.maxBatteryCapacity || batterySpecs.kWh || 1;
                                const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                                
                                if (automation.condition === 'above') {
                                    shouldTrigger = percentage > automation.threshold;
                                } else if (automation.condition === 'below') {
                                    shouldTrigger = percentage < automation.threshold;
                                }
                            }
                        } else {
                            // Use simStats for current charge and capacity (more accurate in simulate mode)
                            const currentKwh = simStats && simStats.batteryCharge !== undefined 
                                ? simStats.batteryCharge 
                                : (targetBattery.specs.charge || 0);
                            const capacity = simStats.maxBatteryCapacity || targetBattery.specs.capacity || targetBattery.specs.kWh || 1;
                            const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                            if (automation.condition === 'above') {
                                shouldTrigger = percentage > automation.threshold;
                            } else if (automation.condition === 'below') {
                                shouldTrigger = percentage < automation.threshold;
                            }
                        }
                    } else if (automation.triggerType === 'solarInput') {
                        // Find target solar array by label
                        const targetArray = allItems.find(i => 
                            i.type === 'panel' && 
                            (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                        );
                        if (targetArray) {
                            // Calculate current solar output (simplified - would need actual irradiance)
                            const arrayWmp = targetArray.specs.wmp || 0;
                            const irradiance = getSolarIrradiance(hourOfDay);
                            const currentOutput = (arrayWmp / 1000) * irradiance; // kW
                            if (automation.condition === 'zero') {
                                shouldTrigger = currentOutput <= 0.001;
                            } else if (automation.condition === 'aboveZero') {
                                shouldTrigger = currentOutput > 0.001;
                            }
                        }
                    } else if (automation.triggerType === 'containerValue') {
                        // Find target container by label
                        const targetContainer = allItems.find(i => 
                            i.type === 'resourcecontainer' && 
                            (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                        );
                        if (targetContainer) {
                            const value = targetContainer.specs.value || 0;
                            if (automation.condition === 'above') {
                                shouldTrigger = value > automation.threshold;
                            } else if (automation.condition === 'below') {
                                shouldTrigger = value < automation.threshold;
                            } else if (automation.condition === 'equals') {
                                shouldTrigger = Math.abs(value - automation.threshold) < 0.1;
                            }
                        }
                    }
                    
                    // Collect automation decisions (turnOff takes precedence)
                    if (shouldTrigger) {
                        if (automation.action === 'turnOn') {
                            shouldBeOn = true;
                        } else if (automation.action === 'turnOff') {
                            shouldBeOff = true; // turnOff takes precedence
                        } else if (automation.action === 'startRecipe') {
                            // Start a specific recipe
                            const recipeIdx = automation.recipeIndex || 0;
                            const recipes = load.specs.recipes || [];
                            // Recipe automation status logged when state changes
                            if (recipes.length > 0 && recipeIdx < recipes.length) {
                                // If already processing, keep the load running
                                if (load.isProcessing) {
                                    shouldBeOn = true; // Keep load marked as ON while processing
                                } else {
                                    // Not yet processing - check if we should start
                                    let shouldStartRecipe = false;
                                    
                                    if (automation.triggerType === 'timeOfDay') {
                                        // For time-based triggers, use day+hour tracking to allow daily triggers
                                        const totalHours = Math.floor(elapsedHours);
                                        const currentDay = Math.floor(totalHours / 24);
                                        const triggerKey = `recipe_${recipeIdx}_timeOfDay`;
                                        if (!load.lastRecipeTriggers) load.lastRecipeTriggers = {};
                                        
                                        // Check if we haven't triggered this recipe today
                                        const lastTriggerDay = load.lastRecipeTriggers[triggerKey];
                                        // Day tracking for recipe triggers
                                        if (lastTriggerDay !== currentDay) {
                                            shouldStartRecipe = true;
                                            load.lastRecipeTriggers[triggerKey] = currentDay;
                                        }
                                    } else {
                                        // For non-time triggers (battery, solar, container), start when condition is met
                                        shouldStartRecipe = true;
                                    }
                                    
                                    if (shouldStartRecipe) {
                                        // Set active recipe and start processing
                                        load.activeRecipeIndex = recipeIdx;
                                        shouldBeOn = true;
                                        load.isProcessing = true; // Start processing immediately
                                        load.recipeTimeElapsed = 0;
                                        load.pendingRecipeStart = true;
                                        console.log(`‚úÖ RECIPE STARTED: "${recipes[recipeIdx].name}" on ${load.specs.name} at hour ${hourOfDay}`);
                                        console.log(`   Recipe details: ${recipes[recipeIdx].energyWh}Wh over ${recipes[recipeIdx].durationHours}h`);
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Apply final state (turnOff takes precedence over turnOn)
                // Explicitly set the state - don't just keep current state
                if (shouldBeOff) {
                    load.simState.isRunning = false;
                    load.isProcessing = false;
                    load.recipeTimeElapsed = 0;
                    load.simState.currentPowerWatts = 0; // Ensure power is zero when off
                    load.pendingRecipeStart = false;
                    // Also clear manual toggle state to prevent conflicts
                    if (LiveView.state && LiveView.state.loadStates) {
                        LiveView.state.loadStates[load.id] = false;
                    }
                } else if (shouldBeOn) {
                    load.simState.isRunning = true;
                    // Also set manual toggle state to match
                    if (LiveView.state && LiveView.state.loadStates) {
                        LiveView.state.loadStates[load.id] = true;
                    }
                    // Load turned on by automation
                } else {
                    // Neither shouldBeOn nor shouldBeOff - check if we need to turn off based on time range
                    // This handles the case where a time-based automation should turn off when outside range
                    const timeBasedAuto = load.automations.find(a => a.triggerType === 'timeOfDay' && a.action === 'turnOn');
                    if (timeBasedAuto) {
                        const startHour = timeBasedAuto.startHour || 18;
                        const endHour = timeBasedAuto.endHour || 6;
                        let isInRange = false;
                        if (startHour > endHour) {
                            isInRange = hourOfDay >= startHour || hourOfDay < endHour;
                        } else {
                            isInRange = hourOfDay >= startHour && hourOfDay < endHour;
                        }
                        if (!isInRange && load.simState.isRunning) {
                            // Outside time range - turn off
                            load.simState.isRunning = false;
                            load.simState.currentPowerWatts = 0;
                            if (LiveView.state && LiveView.state.loadStates) {
                                LiveView.state.loadStates[load.id] = false;
                            }
                        }
                    }
                }
            });
        }
        
        function updateTimeDisplay() {
            const totalHours = Math.floor(elapsedHours);
            const simDay = Math.floor(totalHours / 24) + 1; // Days since simulation start
            const hour = totalHours % 24;
            
            // Update currentDayOfYear based on elapsed days (wraps at 365)
            const daysElapsed = Math.floor(totalHours / 24);
            currentDayOfYear = ((simulationStartDayOfYear - 1 + daysElapsed) % 365) + 1;
            
            // Get date info for display
            const dateInfo = dayOfYearToDate(currentDayOfYear);
            
            document.getElementById('timeDisplay').textContent = 
                `Day ${simDay} (${dateInfo.formatted}, ${String(hour).padStart(2, '0')}:00)`;
            
            // Update date display in sidebar
            const dateEl = document.getElementById('simCurrentDate');
            if (dateEl) {
                dateEl.textContent = dateInfo.formatted;
            }
            
            // Update daylight hours display
            const daylightEl = document.getElementById('simDaylightHours');
            if (daylightEl) {
                const daylight = getDaylightHours(simulationLatitude, currentDayOfYear);
                const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
                const sunriseStr = `${Math.floor(sunrise)}:${String(Math.round((sunrise % 1) * 60)).padStart(2, '0')}`;
                const sunsetStr = `${Math.floor(sunset)}:${String(Math.round((sunset % 1) * 60)).padStart(2, '0')}`;
                daylightEl.textContent = `${daylight.toFixed(1)} hrs (${sunriseStr}-${sunsetStr})`;
            }
        }
        
        function playPause() {
            isPlaying = !isPlaying;
            document.getElementById('playPauseButton').textContent = isPlaying ? '‚è∏' : '‚ñ∂';
            
            if (isPlaying) {
                lastTimestamp = performance.now();
                animationFrameId = requestAnimationFrame(simulationLoop);
            } else if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }
        
        function simulationLoop(timestamp) {
            // Always execute automations and calculate power flow, even when paused
            // This ensures wire glow and automation state are always up to date
            const currentHourOfDay = Math.floor(elapsedHours) % 24;
            executeLoadAutomations(currentHourOfDay);
            
            if (!isPlaying) {
                // When paused, still update displays, power flow, and render
                SimulateMode.calculatePowerFlow();
                updateTimeDisplay();
                updateSimulationDisplay();
                render();
                animationFrameId = requestAnimationFrame(simulationLoop);
                return;
            }
            
            const delta = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            
            // Advance simulation (1 real second = simulationSpeed hours)
            // Use discrete hour steps for accurate load scheduling
            const hoursToAdvance = delta * simulationSpeed;
            elapsedHours += hoursToAdvance;
            const currentHour = Math.floor(elapsedHours);
            
            // Process simulation step only for complete hours that have elapsed
            // This ensures power consumption happens once per simulated hour
            // Process all hours between lastProcessedHour and currentHour
            const hoursToProcess = currentHour - lastProcessedHour;
            if (hoursToProcess > 0) {
                simulateStep(hoursToProcess, lastProcessedHour);
                lastProcessedHour = currentHour; // Update last processed hour
            }
            
            // Calculate power flow for visualization (after automations have updated state)
            SimulateMode.calculatePowerFlow();
            
            // Update displays every frame for smooth animation
            updateTimeDisplay();
            updateSimulationDisplay();
            
            // Update visual elements if we crossed an hour boundary
            if (currentHour !== previousDisplayHour) {
                const hourOfDay = currentHour % 24;
                updateBackgroundColor(hourOfDay);
                updateShadowAngle(hourOfDay);
                previousDisplayHour = currentHour;
            }
            
            // Re-render to show power flow animation
            render();
            
            animationFrameId = requestAnimationFrame(simulationLoop);
        }
        
        function simulateStep(hours, startHour) {
            const controller = allItems.find(i => i.type === 'controller');
            if (!controller) return;
            
            // Use stored specs if available, otherwise calculate
            const specs = simStats.systemSpecs || {};
            const arrayWmp = specs.arrayWmp || calculateConnectedArraySpecs(controller).wmp;
            const batteryKwh = specs.batteryKwh || calculateConnectedBatterySpecs(controller).kWh;
            const controllerMaxWatts = specs.controllerMaxWatts || 9999;
            
            if (arrayWmp === 0 || batteryKwh === 0) return;
            
            // Process hour-by-hour for accurate load scheduling
            // Only process complete hours that have elapsed
            // This ensures power consumption happens once per simulated hour
            // hours is the number of complete hours to process, starting from startHour
            for (let h = 0; h < hours && h < 24; h++) {
                const currentHour = startHour + h;
                const hourOfDay = currentHour % 24;
                
                // Execute automation rules for loads (before checking battery level)
                executeLoadAutomations(hourOfDay);
                
                // Check battery level and auto-shutoff loads if battery is too low
                // Get low-battery protection settings from connected batteries
                const batterySpecs = calculateConnectedBatterySpecs(controller);
                const connectedBatteries = allItems.filter(i => i.type === 'battery');
                let lowBatteryProtection = null;
                
                // Find the first battery with low-battery protection settings (or use defaults)
                for (const battery of connectedBatteries) {
                    if (battery.specs.lowBatteryProtection) {
                        lowBatteryProtection = battery.specs.lowBatteryProtection;
                        break;
                    }
                }
                
                // Use defaults if no battery has settings configured
                if (!lowBatteryProtection) {
                    lowBatteryProtection = {
                        enabled: true,
                        shutdownThreshold: 10,
                        reenableThreshold: 15
                    };
                }
                
                const batteryPercentage = batteryKwh > 0 ? (simStats.batteryCharge / batteryKwh) * 100 : 0;
                const allLoads = allItems.filter(i => i.type === 'acload');
                
                // Only apply low-battery protection if enabled
                if (lowBatteryProtection.enabled) {
                    if (batteryPercentage < lowBatteryProtection.shutdownThreshold) {
                        // Battery below shutdown threshold - turn off all loads
                        allLoads.forEach(load => {
                            if (!load.simState) {
                                load.simState = {
                                    isRunning: false,
                                    isProcessing: false,
                                    recipeTimeElapsed: 0,
                                    currentPowerWatts: 0,
                                    lastConsumptionKwh: 0,
                                    wasAutoShutoff: false
                                };
                            }
                            // Only shutoff if not already marked as auto-shutoff (to avoid resetting state)
                            if (load.simState.isRunning && !load.simState.wasAutoShutoff) {
                                load.simState.wasAutoShutoff = true; // Mark as auto-shutoff
                                load.simState.isRunning = false;
                                load.isProcessing = false;
                                load.recipeTimeElapsed = 0;
                                load.simState.currentPowerWatts = 0;
                            } else if (!load.simState.isRunning) {
                                // Already off - mark as auto-shutoff if not already marked
                                load.simState.wasAutoShutoff = true;
                            }
                        });
                    } else if (batteryPercentage >= lowBatteryProtection.reenableThreshold) {
                        // Battery recovered above re-enable threshold - re-enable loads that were auto-shutoff
                        allLoads.forEach(load => {
                            if (load.simState && load.simState.wasAutoShutoff) {
                                load.simState.wasAutoShutoff = false; // Clear auto-shutoff flag
                                // Re-evaluate automations to determine if load should be on
                                // Re-execute automations for this load to get correct state
                                if (load.automations && load.automations.length > 0) {
                                    // Re-evaluate automations for this specific load
                                    let shouldBeOn = false;
                                    let shouldBeOff = false;
                                    
                                    load.automations.forEach(automation => {
                                        let shouldTrigger = false;
                                        
                                        if (automation.triggerType === 'timeOfDay') {
                                            const startHour = automation.startHour || 18;
                                            const endHour = automation.endHour || 6;
                                            if (startHour > endHour) {
                                                shouldTrigger = hourOfDay >= startHour || hourOfDay < endHour;
                                            } else {
                                                shouldTrigger = hourOfDay >= startHour && hourOfDay < endHour;
                                            }
                                        } else if (automation.triggerType === 'batteryLevel') {
                                            const targetBattery = allItems.find(i => 
                                                i.type === 'battery' && 
                                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                            );
                                            if (targetBattery) {
                                                const currentKwh = simStats.batteryCharge || 0;
                                                const capacity = targetBattery.specs.capacity || simStats.maxBatteryCapacity || 1;
                                                const percentage = capacity > 0 ? (currentKwh / capacity) * 100 : 0;
                                                if (automation.condition === 'above') {
                                                    shouldTrigger = percentage > automation.threshold;
                                                } else if (automation.condition === 'below') {
                                                    shouldTrigger = percentage < automation.threshold;
                                                }
                                            }
                                        } else if (automation.triggerType === 'solarInput') {
                                            const targetArray = allItems.find(i => 
                                                i.type === 'panel' && 
                                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                            );
                                            if (targetArray) {
                                                const arrayWmp = targetArray.specs.wmp || 0;
                                                const irradiance = getSolarIrradiance(hourOfDay);
                                                const currentOutput = (arrayWmp / 1000) * irradiance;
                                                if (automation.condition === 'zero') {
                                                    shouldTrigger = currentOutput <= 0.001;
                                                } else if (automation.condition === 'aboveZero') {
                                                    shouldTrigger = currentOutput > 0.001;
                                                }
                                            }
                                        } else if (automation.triggerType === 'containerValue') {
                                            const targetContainer = allItems.find(i => 
                                                i.type === 'resourcecontainer' && 
                                                (i.specs.name === automation.targetNodeLabel || i.label === automation.targetNodeLabel)
                                            );
                                            if (targetContainer) {
                                                const value = targetContainer.specs.value || 0;
                                                if (automation.condition === 'above') {
                                                    shouldTrigger = value > automation.threshold;
                                                } else if (automation.condition === 'below') {
                                                    shouldTrigger = value < automation.threshold;
                                                } else if (automation.condition === 'equals') {
                                                    shouldTrigger = Math.abs(value - automation.threshold) < 0.1;
                                                }
                                            }
                                        }
                                        
                                        if (shouldTrigger) {
                                            if (automation.action === 'turnOn') {
                                                shouldBeOn = true;
                                            } else if (automation.action === 'turnOff') {
                                                shouldBeOff = true;
                                            } else if (automation.action === 'startRecipe') {
                                                // Handle recipe start on recovery
                                                const recipeIdx = automation.recipeIndex || 0;
                                                if (load.specs.recipes && load.specs.recipes.length > recipeIdx) {
                                                    if (!load.isProcessing) {
                                                        load.activeRecipeIndex = recipeIdx;
                                                        shouldBeOn = true;
                                                        load.pendingRecipeStart = true;
                                                    }
                                                }
                                            }
                                        }
                                    });
                                    
                                    if (shouldBeOff) {
                                        load.simState.isRunning = false;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = false;
                                        }
                                    } else if (shouldBeOn) {
                                        load.simState.isRunning = true;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = true;
                                        }
                                    }
                                } else {
                                    // No automations - check schedule
                                    const shouldBeOn = evaluateLoadSchedule(load, hourOfDay);
                                    if (shouldBeOn) {
                                        load.simState.isRunning = true;
                                        if (LiveView.state && LiveView.state.loadStates) {
                                            LiveView.state.loadStates[load.id] = true;
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Update visual background color based on time of day
                updateBackgroundColor(hourOfDay);
                
                // Update shadow angles
                updateShadowAngle(hourOfDay);
                
                // Calculate solar generation for this hour
                const irradiance = getSolarIrradiance(hourOfDay);
                const rawSolarPowerKw = (arrayWmp / 1000) * irradiance;
                const maxControllerPowerKw = controllerMaxWatts / 1000;
                const effectiveSolarPowerKw = Math.min(rawSolarPowerKw, maxControllerPowerKw);
                const solarGeneratedKwh = effectiveSolarPowerKw * 1.0; // 1 hour
                
                // Track clipping
                if (rawSolarPowerKw > maxControllerPowerKw && irradiance > 0.5) {
                    simStats.clippedEnergy = (simStats.clippedEnergy || 0) + (rawSolarPowerKw - effectiveSolarPowerKw) * 1.0;
                }
                
                // Update battery
                simStats.maxBatteryCapacity = batteryKwh;
                const previousCharge = simStats.batteryCharge;
                
                // Add solar to battery (capped at capacity)
                simStats.batteryCharge = Math.min(
                    simStats.maxBatteryCapacity,
                    simStats.batteryCharge + solarGeneratedKwh
                );
                
                // Track actual captured energy (what went into battery)
                const actualCaptured = simStats.batteryCharge - previousCharge;
                simStats.totalSolarGenerated += actualCaptured;
                
                // Track peak power (effective, after clipping)
                if (effectiveSolarPowerKw > simStats.peakPower) {
                    simStats.peakPower = effectiveSolarPowerKw;
                }
                
                // Update current solar output (in watts) for display
                simStats.currentSolarOutput = effectiveSolarPowerKw * 1000;
                
                // Calculate load consumption for this hour
                const loadConsumptionKw = calculateLoadConsumption(hourOfDay);
                const loadConsumptionKwh = loadConsumptionKw * 1.0; // 1 hour
                
                // Update per-load consumption tracking (convert watts to kWh for this hour)
                // Only track and consume power from loads that are actually running
                const loads = allItems.filter(i => i.type === 'acload');
                let actualConsumptionKwh = 0; // Track actual consumption from running loads only
                
                let currentLoadWatts = 0; // Track current load power in watts
                loads.forEach(load => {
                    // Only process loads that are actually running
                    if (load.simState && load.simState.isRunning && load.simState.currentPowerWatts > 0) {
                        if (!simStats.loadConsumption[load.id]) {
                            simStats.loadConsumption[load.id] = { watts: 0, kwh: 0 };
                        }
                        const loadKwh = (load.simState.currentPowerWatts / 1000) * 1.0; // Convert W to kW, then to kWh for 1 hour
                        simStats.loadConsumption[load.id].kwh += loadKwh;
                        load.simState.lastConsumptionKwh = loadKwh;
                        actualConsumptionKwh += loadKwh; // Sum only running loads
                        currentLoadWatts += load.simState.currentPowerWatts; // Sum current power
                    } else {
                        // Ensure off loads have zero consumption
                        if (load.simState) {
                            load.simState.currentPowerWatts = 0;
                        }
                    }
                });
                
                // Process recipe-based loads (for non-power resource processing only)
                // Power consumption is now handled in calculateLoadConsumption()
                processRecipeLoads(hourOfDay);
                
                // Calculate inverter load consumption for hybrid/all-in-one controllers
                // Inverter load is consumed whenever the controller is outputting live AC power
                let inverterLoadKwh = 0;
                let inverterLoadWattsTotal = 0; // Track total inverter load watts for display
                const controllers = allItems.filter(i => i.type === 'controller');
                controllers.forEach(ctrl => {
                    const isHybridOrAllInOne = ctrl.specs.type === 'hybrid_inverter' || ctrl.specs.type === 'all_in_one';
                    const inverterLoadWatts = ctrl.specs.inverterLoad || 0;
                    
                    if (isHybridOrAllInOne && inverterLoadWatts > 0 && simStats.controllerACOutputEnabled !== false) {
                        // Check if controller has any AC connections (is actively outputting power)
                        const hasACConnection = ctrl.handles?.acOutput?.connectedTo?.length > 0;
                        if (hasACConnection) {
                            const ctrlInverterKwh = (inverterLoadWatts / 1000) * 1.0; // 1 hour
                            inverterLoadKwh += ctrlInverterKwh;
                            inverterLoadWattsTotal += inverterLoadWatts;
                            
                            // Track inverter load consumption per controller
                            if (!simStats.inverterLoadConsumption) {
                                simStats.inverterLoadConsumption = {};
                            }
                            if (!simStats.inverterLoadConsumption[ctrl.id]) {
                                simStats.inverterLoadConsumption[ctrl.id] = { watts: inverterLoadWatts, kwh: 0 };
                            }
                            simStats.inverterLoadConsumption[ctrl.id].kwh += ctrlInverterKwh;
                        }
                    }
                });
                
                // Add inverter load to current load power display
                simStats.currentLoadPower = currentLoadWatts + inverterLoadWattsTotal;
                // Total power consumption updated
                
                // Deduct load consumption plus inverter load from battery
                const totalConsumptionKwh = actualConsumptionKwh + inverterLoadKwh;
                simStats.batteryCharge = Math.max(0, simStats.batteryCharge - totalConsumptionKwh);
                simStats.totalEnergyUsed += totalConsumptionKwh;
            }
            
            // Note: Fractional hours are handled by accumulating elapsedHours continuously
            // and only processing complete hours. This ensures accurate power consumption
            // (once per simulated hour) while maintaining correct simulation speed.
            // Fractional hours will be processed when they accumulate to a complete hour.
        }
        
        // Process recipe-based loads during simulation (non-power resources only)
        // Power consumption is now handled in calculateLoadConsumption()
        function processRecipeLoads(hourOfDay) {
            // Recipe-based loads are treated as loads for power consumption
            // This function only handles non-power resource processing
            const recipeLoads = allItems.filter(i => i.type === 'acload' && i.specs.recipes && i.specs.recipes.length > 0);
            
            recipeLoads.forEach(load => {
                // Initialize simulation state if not exists
                if (!load.simState) {
                    load.simState = {
                        isRunning: false,
                        isProcessing: false,
                        recipeTimeElapsed: 0,
                        currentPowerWatts: 0,
                        lastConsumptionKwh: 0
                    };
                }
                
                // Check if load should be running (power consumption handled by calculateLoadConsumption)
                // Recipe loads run if they have power and automation allows it
                if (!load.simState.isRunning) {
                    load.isProcessing = false;
                    return;
                }
                
                const recipes = load.specs.recipes || [];
                if (recipes.length === 0) return;
                
                // Get active recipe (for now, use first recipe, later support recipe selection)
                const activeRecipeIndex = load.activeRecipeIndex !== null && load.activeRecipeIndex !== undefined 
                    ? load.activeRecipeIndex 
                    : 0;
                const recipe = recipes[activeRecipeIndex];
                if (!recipe) return;
                
                // Check if load has AC power via cord connection
                const cordHandle = load.handles.cord;
                const hasPower = cordHandle && cordHandle.connectedTo.length > 0;
                if (!hasPower) {
                    load.isProcessing = false;
                    return;
                }
                
                // Recipe processing logic
                const recipeInputs = recipe.inputs || [];
                const recipeOutputs = recipe.outputs || [];
                const durationHours = recipe.durationHours || 0;
                
                // Check if this is an automation-triggered recipe start
                const isAutomationTriggered = load.pendingRecipeStart === true;
                
                if (!load.isProcessing) {
                    // Check if we have all required recipe inputs
                    let hasAllInputs = true;
                    
                    for (const recipeInput of recipeInputs) {
                        // Find input handle - either matching exact type OR Generic
                        const inputHandle = Object.values(load.handles).find(h => 
                            (h.resourceType === recipeInput.resourceType || h.resourceType === RESOURCE_TYPES.GENERIC) && 
                            h.polarity === 'input'
                        );
                        if (!inputHandle || inputHandle.connectedTo.length === 0) {
                            hasAllInputs = false;
                            break;
                        }
                        
                        // Find source container - check both connection directions
                        const conn = connections.find(c => 
                            c.targetHandleId === inputHandle.id || 
                            c.sourceHandleId === inputHandle.id
                        );
                        if (conn) {
                            // Container could be source OR target depending on how connection was made
                            let container = allItems.find(i => i.id === conn.sourceItemId && i.type === 'resourcecontainer');
                            if (!container) {
                                container = allItems.find(i => i.id === conn.targetItemId && i.type === 'resourcecontainer');
                            }
                            if (container) {
                                const requiredAmount = recipeInput.amount || 0;
                                if ((container.specs.value || 0) < requiredAmount) {
                                    hasAllInputs = false;
                                    console.log(`[Recipe] Insufficient input: ${container.specs.name} has ${container.specs.value}, need ${requiredAmount}`);
                                    break;
                                }
                            } else {
                                hasAllInputs = false;
                                break;
                            }
                        } else {
                            hasAllInputs = false;
                            break;
                        }
                    }
                    
                    if (hasAllInputs && hasPower) {
                        // Start recipe processing
                        load.isProcessing = true;
                        load.recipeTimeElapsed = 0;
                        load.awaitingInputs = false;
                        load.pendingRecipeStart = false; // Clear automation trigger flag
                        
                        // Log recipe start for debugging
                        console.log(`Recipe "${recipe.name}" started on ${load.specs.name}. Duration: ${durationHours} hours`);
                        
                        // Note: Inputs are now consumed gradually each hour, not all at once
                        // This simulates realistic processing (e.g., 100g/hour for 5 hours = 500g total)
                    } else {
                        load.awaitingInputs = !hasAllInputs;
                        load.isProcessing = false;
                        load.pendingRecipeStart = false; // Clear automation trigger flag on failure too
                        return;
                    }
                }
                
                // Process recipe - consume inputs gradually each hour
                load.recipeTimeElapsed += 1.0; // 1 hour
                
                // Consume proportional inputs each hour (gradual consumption)
                if (durationHours > 0) {
                    const inputsPerHour = 1.0 / durationHours; // Fraction of inputs to consume each hour
                    
                    for (const recipeInput of recipeInputs) {
                        // Find input handle - either matching the exact resource type OR a connected Generic type
                        const inputHandle = Object.values(load.handles).find(h => 
                            (h.resourceType === recipeInput.resourceType || h.resourceType === RESOURCE_TYPES.GENERIC) && 
                            h.polarity === 'input'
                        );
                        
                        if (inputHandle) {
                            // Find connected container - check both connection directions
                            const conn = connections.find(c => 
                                c.targetHandleId === inputHandle.id || 
                                c.sourceHandleId === inputHandle.id
                            );
                            
                            if (conn) {
                                // Container could be source OR target depending on how connection was made
                                let container = allItems.find(i => i.id === conn.sourceItemId && i.type === 'resourcecontainer');
                                if (!container) {
                                    container = allItems.find(i => i.id === conn.targetItemId && i.type === 'resourcecontainer');
                                }
                                if (container) {
                                    const hourlyConsumption = (recipeInput.amount || 0) * inputsPerHour;
                                    container.specs.value = (container.specs.value || 0) - hourlyConsumption;
                                }
                            }
                        }
                    }
                }
                
                if (load.recipeTimeElapsed >= durationHours) {
                    // Recipe complete - produce outputs
                    recipeOutputs.forEach(recipeOutput => {
                        // Find output handle - either matching exact type OR Generic
                        const outputHandle = Object.values(load.handles).find(h => 
                            (h.resourceType === recipeOutput.resourceType || h.resourceType === RESOURCE_TYPES.GENERIC) && 
                            h.polarity === 'output'
                        );
                        if (outputHandle) {
                            // Find connected container - check both connection directions
                            const conn = connections.find(c => 
                                c.sourceHandleId === outputHandle.id || 
                                c.targetHandleId === outputHandle.id
                            );
                            if (conn) {
                                // Container could be source OR target depending on how connection was made
                                let container = allItems.find(i => i.id === conn.targetItemId && i.type === 'resourcecontainer');
                                if (!container) {
                                    container = allItems.find(i => i.id === conn.sourceItemId && i.type === 'resourcecontainer');
                                }
                                if (container) {
                                    const produced = recipeOutput.amount || 0;
                                    const capacity = container.specs.capacity || Infinity;
                                    container.specs.value = Math.min(capacity, (container.specs.value || 0) + produced);
                                    console.log(`[Recipe] Produced ${produced} to ${container.specs.name}, total: ${container.specs.value}`);
                                }
                            }
                        }
                    });
                    
                    // Reset recipe processing
                    load.isProcessing = false;
                    load.recipeTimeElapsed = 0;
                    
                    // Log recipe completion
                    console.log(`Recipe "${recipe.name}" completed on ${load.specs.name}!`);
                    
                    // Turn off load after recipe completes (it can be re-triggered by automation)
                    // Only auto-shutoff if this was a single-run recipe triggered by automation
                    load.simState.isRunning = false;
                    load.simState.currentPowerWatts = 0;
                    if (LiveView.state && LiveView.state.loadStates) {
                        LiveView.state.loadStates[load.id] = false;
                    }
                }
            });
        }
        
        // Update background color based on time of day
        function updateBackgroundColor(hourOfDay) {
            // Get dynamic sunrise/sunset based on latitude and day
            const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
            
            let brightness = 0;
            // Day period: from sunrise to sunset (dynamic based on location/season)
            if (hourOfDay >= sunrise && hourOfDay < sunset) {
                // Normalize to 0-1 range over daylight hours, then apply sine curve
                const dayLength = sunset - sunrise;
                if (dayLength > 0) {
                    const normalizedHour = (hourOfDay - sunrise) / dayLength;
                    brightness = Math.max(0, Math.sin(normalizedHour * Math.PI));
                }
            }
            
            // Calculate background color based on brightness
            const baseColor = { r: 26, g: 43, b: 60 }; // #1a2b3c (night)
            const maxColor = { r: 173, g: 216, b: 230 }; // #add8e6 (light blue day)
            
            const r = Math.round(baseColor.r + (maxColor.r - baseColor.r) * brightness);
            const g = Math.round(baseColor.g + (maxColor.g - baseColor.g) * brightness);
            const b = Math.round(baseColor.b + (maxColor.b - baseColor.b) * brightness);
            
            // Update canvas container background
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                const newColor = `rgb(${r}, ${g}, ${b})`;
                canvasContainer.style.backgroundColor = newColor;
                // Also update SVG background if it exists
                const svg = d3.select('#main-content svg');
                if (!svg.empty()) {
                    svg.style('background-color', newColor);
                }
            }
        }
        
        // Update shadow angles based on time of day
        function updateShadowAngle(hourOfDay) {
            // Shadow angle calculation:
            // - Morning: shadow to the RIGHT (positive dx) - sun in east
            // - Midday (12): shadow straight down (dx = 0) - sun overhead
            // - Evening: shadow to the LEFT (negative dx) - sun in west
            // - Night: no shadow (faded out)
            
            // Get dynamic sunrise/sunset based on latitude and day
            const { sunrise, sunset } = getSunriseSunset(simulationLatitude, currentDayOfYear);
            
            // Define fade zones (1 hour before/after actual sunrise/sunset)
            const sunriseStart = Math.max(0, sunrise - 1);
            const sunriseEnd = sunrise;
            const sunsetStart = sunset;
            const sunsetEnd = Math.min(24, sunset + 1);
            
            let dx = 0;
            let dy = 0;
            let shadowOpacity = 0;
            
            if (hourOfDay >= sunriseEnd && hourOfDay < sunsetStart) {
                // Full day: shadows fully visible
                shadowOpacity = 0.7;
                
                // Normalize hour to 0-1 range (sunrise = 0, sunset = 1)
                const normalizedHour = (hourOfDay - sunriseEnd) / (sunsetStart - sunriseEnd);
                // Convert to angle: 0 = +90¬∞ (morning, shadow right), 0.5 = 0¬∞ (noon, shadow down), 1 = -90¬∞ (evening, shadow left)
                const angle = (0.5 - normalizedHour) * Math.PI; // +œÄ/2 to -œÄ/2
                
                // Calculate shadow length: longer in morning/evening, shorter at noon
                // Also factor in latitude - higher latitudes have longer shadows
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const latitudeFactor = 1 + Math.abs(simulationLatitude) / 90 * 0.5; // 1.0 to 1.5
                const shadowLength = (8 + (distanceFromNoon * 32)) * latitudeFactor;
                
                // Calculate dx and dy from angle
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else if (hourOfDay >= sunriseStart && hourOfDay < sunriseEnd) {
                // Sunrise fade-in
                const fadeProgress = (hourOfDay - sunriseStart) / (sunriseEnd - sunriseStart);
                shadowOpacity = 0.7 * fadeProgress;
                
                const normalizedHour = (hourOfDay - sunriseStart) / (sunsetStart - sunriseStart);
                const angle = (0.5 - normalizedHour) * Math.PI;
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const latitudeFactor = 1 + Math.abs(simulationLatitude) / 90 * 0.5;
                const shadowLength = (8 + (distanceFromNoon * 32)) * latitudeFactor;
                
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else if (hourOfDay >= sunsetStart && hourOfDay < sunsetEnd) {
                // Sunset fade-out
                const fadeProgress = (sunsetEnd - hourOfDay) / (sunsetEnd - sunsetStart);
                shadowOpacity = 0.7 * fadeProgress;
                
                const normalizedHour = (hourOfDay - sunriseStart) / (sunsetStart - sunriseStart);
                const angle = (0.5 - normalizedHour) * Math.PI;
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const latitudeFactor = 1 + Math.abs(simulationLatitude) / 90 * 0.5;
                const shadowLength = (8 + (distanceFromNoon * 32)) * latitudeFactor;
                
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
            }
            
            // Store shadow properties for use in rendering (if needed)
            // Could be used to update visual elements with shadows
            simStats.shadowDx = dx;
            simStats.shadowDy = dy;
            simStats.shadowOpacity = shadowOpacity;
        }
        
        // Update the load toggle button in inspector during simulation
        function updateInspectorLoadToggle() {
            const toggleBtn = document.getElementById('loadToggleBtn');
            const statusText = document.getElementById('loadStatusText');
            const inspectorVisible = !document.getElementById('acloadInspector').classList.contains('hidden');
            
            if (inspectorVisible && selectedItem && selectedItem.type === 'acload') {
                // Determine if load is on
                let isOn = false;
                if (currentMode === 'simulate') {
                    isOn = (selectedItem.simState && selectedItem.simState.isRunning) || 
                           (LiveView.state.loadStates && LiveView.state.loadStates[selectedItem.id] === true);
                } else {
                    isOn = LiveView.state.loadStates && LiveView.state.loadStates[selectedItem.id] === true;
                }
                
                if (toggleBtn) {
                    toggleBtn.textContent = isOn ? 'ON' : 'OFF';
                    toggleBtn.style.background = isOn ? '#5cb85c' : '#d9534f';
                }
                
                if (statusText) {
                    const circuitStatus = checkLoadCircuitStatus(selectedItem);
                    if (!circuitStatus.isLive && isOn) {
                        statusText.textContent = circuitStatus.message;
                        statusText.style.color = '#d9534f';
                    } else if (isOn) {
                        const loadWatts = selectedItem.simState?.currentPowerWatts || getLoadWatts(selectedItem);
                        statusText.textContent = `Drawing ${loadWatts.toFixed(0)}W`;
                        statusText.style.color = '#5cb85c';
                    } else {
                        statusText.textContent = 'Load is off';
                        statusText.style.color = '#888';
                    }
                }
            }
            
            // Also update resource container display if one is selected
            const containerInspectorVisible = !document.getElementById('resourceContainerInspector').classList.contains('hidden');
            if (containerInspectorVisible && selectedItem && selectedItem.type === 'resourcecontainer') {
                // Update value display
                document.getElementById('containerValue').value = selectedItem.specs.value || 0;
                
                // Update fill level
                const capacity = selectedItem.specs.capacity || 100;
                const value = selectedItem.specs.value || 0;
                const percent = capacity > 0 ? Math.min(100, (value / capacity) * 100) : 0;
                document.getElementById('containerFillPercent').textContent = `${percent.toFixed(1)}%`;
                document.getElementById('containerFillBar').style.width = `${percent}%`;
            }
        }
        
        function updateSimulationDisplay() {
            // Update inspector toggle state
            updateInspectorLoadToggle();
            
            // Update simulation stats display
            const simSolarGeneratedEl = document.getElementById('simSolarGenerated');
            const simEnergyUsedEl = document.getElementById('simEnergyUsed');
            const simPeakPowerEl = document.getElementById('simPeakPower');
            const simCurrentSolarEl = document.getElementById('simCurrentSolar');
            const simCurrentLoadEl = document.getElementById('simCurrentLoad');
            
            // Update current solar output
            if (simCurrentSolarEl) {
                const solarWatts = simStats.currentSolarOutput || 0;
                if (solarWatts >= 1000) {
                    simCurrentSolarEl.textContent = (solarWatts / 1000).toFixed(2) + ' kW';
                } else {
                    simCurrentSolarEl.textContent = solarWatts.toFixed(0) + ' W';
                }
            }
            
            // Update current load power
            if (simCurrentLoadEl) {
                const loadWatts = simStats.currentLoadPower || 0;
                if (loadWatts >= 1000) {
                    simCurrentLoadEl.textContent = (loadWatts / 1000).toFixed(2) + ' kW';
                } else {
                    simCurrentLoadEl.textContent = loadWatts.toFixed(0) + ' W';
                }
            }
            
            if (simSolarGeneratedEl) {
                simSolarGeneratedEl.textContent = simStats.totalSolarGenerated.toFixed(2) + ' kWh';
            }
            if (simEnergyUsedEl) {
                simEnergyUsedEl.textContent = simStats.totalEnergyUsed.toFixed(2) + ' kWh';
            }
            if (simPeakPowerEl) {
                simPeakPowerEl.textContent = simStats.peakPower.toFixed(2) + ' kW';
            }
            
            const chargePercent = simStats.maxBatteryCapacity > 0 
                ? (simStats.batteryCharge / simStats.maxBatteryCapacity) * 100 
                : 0;
            const chargeEl = document.getElementById('simBatteryCharge');
            if (chargeEl) {
                chargeEl.textContent = chargePercent.toFixed(0) + '%';
                chargeEl.classList.remove('good', 'warning', 'error');
                if (chargePercent >= 50) chargeEl.classList.add('good');
                else if (chargePercent >= 20) chargeEl.classList.add('warning');
                else chargeEl.classList.add('error');
            }
            
            // Update battery visual representation on canvas
            if (currentMode === 'simulate') {
                updateBatteryVisuals(chargePercent);
            }
        }
        
        // Update battery visuals on the canvas during simulation
        function updateBatteryVisuals(chargePercent) {
            // Find all battery items and update their display
            const batteries = allItems.filter(i => i.type === 'battery' || i.type === 'smartbattery');
            const itemGroups = d3.select('#main-content svg').selectAll('.item-group');
            
            batteries.forEach(battery => {
                const batteryGroup = itemGroups.filter(d => d && d.id === battery.id);
                if (!batteryGroup.empty()) {
                    // Update battery charge display
                    const batterySpecsEl = batteryGroup.select('.battery-specs');
                    if (!batterySpecsEl.empty()) {
                        const batteryKwh = simStats.batteryCharge;
                        const color = chargePercent >= 50 ? '#5cb85c' : 
                                     chargePercent >= 20 ? '#f0ad4e' : '#d9534f';
                        batterySpecsEl
                            .text(`${batteryKwh.toFixed(1)}kWh (${chargePercent.toFixed(0)}%)`)
                            .attr('fill', color);
                    }
                }
            });
            
            // Trigger a re-render to update visuals
            render();
        }
        
        function resetSimulation() {
            // Set start day based on hemisphere (summer solstice for easier start)
            // Northern hemisphere: June 21 (day 172), Southern: December 21 (day 355)
            simulationStartDayOfYear = getSummerSolsticeDay(simulationLatitude);
            currentDayOfYear = simulationStartDayOfYear;
            
            // Start at noon on summer solstice for best solar conditions
            elapsedHours = 12;
            lastProcessedHour = 12;
            previousDisplayHour = 12;
            
            const preservedSpecs = simStats.systemSpecs; // Preserve system specs before reset
            simStats = {
                totalSolarGenerated: 0,
                totalEnergyUsed: 0,
                batteryCharge: 0,
                maxBatteryCapacity: 0,
                peakPower: 0,
                clippedEnergy: 0,
                currentSolarOutput: 0, // Reset current solar output
                currentLoadPower: 0, // Reset current load power
                loadConsumption: {}, // Reset per-load tracking
                inverterLoadConsumption: {}, // Reset per-controller inverter load tracking
                systemSpecs: preservedSpecs, // Restore preserved specs
                controllerACOutputEnabled: true // Reset to enabled
            };
            
            // Reset load simulation states
            const loads = allItems.filter(i => i.type === 'acload' || i.type === 'processor');
            loads.forEach(load => {
                if (load.simState) {
                    load.simState.isRunning = false;
                    load.simState.isInBatch = false;
                    load.simState.batchTimeElapsed = 0;
                    load.simState.currentPowerWatts = 0;
                    load.simState.lastConsumptionKwh = 0;
                    load.simState.isProcessing = false;
                }
                // Reset recipe-related state
                load.isProcessing = false;
                load.recipeTimeElapsed = 0;
                load.pendingRecipeStart = false;
                load.lastRecipeTriggers = {}; // Clear automation trigger tracking
            });
            
            // Re-initialize battery charge from preserved specs if available
            // Start at 50% battery for realistic mid-simulation feel
            if (preservedSpecs && preservedSpecs.batteryKwh) {
                simStats.maxBatteryCapacity = preservedSpecs.batteryKwh;
                simStats.batteryCharge = preservedSpecs.batteryKwh * 0.5; // Start at 50% battery
            }
            
            // Reset all resource display node values to zero (except batteries)
            // This merges the functionality of resetTime and resetValues
            if (typeof allItems !== 'undefined' && Array.isArray(allItems)) {
                allItems.forEach(item => {
                    // Check if this is a resource display item (adjust based on actual structure)
                    if (item.type === 'resource-display' || (item.specs && item.specs.resourceType && item.specs.resourceType !== 'Power')) {
                        if (item.value !== undefined) {
                            item.value = 0;
                        }
                        if (item.specs && item.specs.value !== undefined) {
                            item.specs.value = 0;
                        }
                    }
                });
            }
            
            updateTimeDisplay();
            updateSimulationDisplay();
        }
        
        // ============================================
        // LAUNCH SIMULATOR
        // ============================================
        
        // launchSimulator() function removed - simulation now runs inline via setMode('simulate')
        
        // ============================================
        // SAVE/LOAD
        // ============================================
        
        function saveSystem() {
            const data = {
                items: allItems,
                connections: connections,
                version: 1
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-system-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadSystem() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        allItems = data.items || [];
                        connections = data.connections || [];
                        invalidateSpecsCache(); // New data loaded - clear cached specs
                        
                        // Initialize wire properties for old connections that don't have them
                        connections.forEach(conn => {
                            if (!conn.wireGauge) {
                                updateWireGaugeForConnection(conn);
                                // If still no length, estimate it
                                if (!conn.estimatedLength) {
                                    const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                                    const targetItem = allItems.find(i => i.id === conn.targetItemId);
                                    if (sourceItem && targetItem) {
                                        const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                                        const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                                        if (sourceHandle && targetHandle) {
                                            conn.estimatedLength = estimateWireLength(sourceItem, sourceHandle, targetItem, targetHandle);
                                            conn.costPerFoot = WIRE_COST_PER_FOOT[conn.wireGauge] || WIRE_COST_PER_FOOT['10'];
                                            conn.totalWireCost = conn.estimatedLength * conn.costPerFoot;
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Initialize AC load properties for loaded items
                        allItems.forEach(item => {
                            if (item.type === 'acload') {
                                // Ensure automations array exists
                                if (!item.automations) {
                                    item.automations = [];
                                }
                                // Ensure recipe-related properties exist
                                if (item.activeRecipeIndex === undefined) {
                                    item.activeRecipeIndex = null;
                                }
                                if (item.recipeTimeElapsed === undefined) {
                                    item.recipeTimeElapsed = 0;
                                }
                                if (item.isProcessing === undefined) {
                                    item.isProcessing = false;
                                }
                                if (item.awaitingInputs === undefined) {
                                    item.awaitingInputs = false;
                                }
                                // Ensure behavior exists in specs
                                if (!item.specs.behavior) {
                                    item.specs.behavior = { type: 'simple' };
                                }
                            }
                        });
                        
                        // Update ID counters
                        itemIdCounter = Math.max(0, ...allItems.map(i => parseInt(i.id.split('-')[1]) || 0));
                        connectionIdCounter = Math.max(0, ...connections.map(c => parseInt(c.id.split('-')[1]) || 0));
                        
                        render();
                    } catch (err) {
                        alert('Error loading file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // ============================================
        // DEFAULT LAYOUT
        // ============================================
        
        function setupDefaultLayout() {
            // Reset tutorial state
            tutorialStep = 0;
            tutorialCompleted = false;
            connectedSolarFirst = false;
            seriesHintShown = false;
            optimalArrayHintShown = false;
            lastConnectedArrayWmp = 0;
            systemValidated = false;
            
            // Calculate center position based on actual canvas dimensions
            const centerX = svgWidth / 2;
            const startY = svgHeight / 2 - 150;
            
            // Create components in a vertical column: panel on top, controller middle, battery bottom
            const panel = createPanel(centerX - PANEL_WIDTH / 2, startY, PANEL_PRESETS[0]);
            const controller = createController(centerX - CONTROLLER_WIDTH / 2, startY + 120, CONTROLLER_PRESETS[0]);
            const battery = createBattery(centerX - BATTERY_WIDTH / 2, startY + 260, BATTERY_PRESETS[0]);
            
            allItems.push(panel, controller, battery);
            
            render();
            
            // Start tutorial after a short delay
            setTimeout(() => {
                startTutorial();
            }, 800);
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            updateSvgDimensions();
            populateLibraries();
            
            // Initialize latitude input with default value
            const latInput = document.getElementById('simLatitudeInput');
            if (latInput) {
                latInput.value = simulationLatitude;
            }
            
            // Check if returning from simulator with saved state
            const savedState = localStorage.getItem('solarBuilderState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    allItems = state.items || [];
                    connections = state.connections || [];
                    invalidateSpecsCache(); // New data loaded - clear cached specs
                    itemIdCounter = state.itemIdCounter || 0;
                    connectionIdCounter = state.connectionIdCounter || 0;
                    
                    // Rebuild handle.connectedTo arrays from connections
                    // (these don't serialize properly with circular refs)
                    allItems.forEach(item => {
                        Object.values(item.handles).forEach(h => h.connectedTo = []);
                    });
                    connections.forEach(conn => {
                        const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                        const targetItem = allItems.find(i => i.id === conn.targetItemId);
                        if (sourceItem && targetItem) {
                            const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                            const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                            if (sourceHandle && targetHandle) {
                                sourceHandle.connectedTo.push({ itemId: targetItem.id, handleId: targetHandle.id, connectionId: conn.id });
                                targetHandle.connectedTo.push({ itemId: sourceItem.id, handleId: sourceHandle.id, connectionId: conn.id });
                            }
                        }
                    });
                    
                    // Skip tutorial if returning with existing design
                    tutorialCompleted = true;
                    systemValidated = true;
                    
                    render();
                    // Don't remove state - keep it for future returns
                } catch (e) {
                    console.error('Failed to restore builder state:', e);
                    setupDefaultLayout();
                }
            } else {
                setupDefaultLayout();
            }
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    // Don't delete if user is typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (selectedItem) {
                        deleteItem(selectedItem.id);
                        e.preventDefault();
                    } else if (selectedConnection) {
                        deleteConnection(selectedConnection.id);
                        closeInspector();
                        e.preventDefault();
                    }
                }
            });
            
            // Mode toggle
            document.getElementById('buildModeBtn').addEventListener('click', () => setMode('build'));
            document.getElementById('liveViewModeBtn').addEventListener('click', () => setMode('live'));
            document.getElementById('simulateModeBtn').addEventListener('click', () => {
                setMode('simulate');
            });
            
            // Live view controls
            document.getElementById('resetAllLoadsBtn').addEventListener('click', () => {
                Object.keys(liveViewLoadStates).forEach(loadId => {
                    LiveView.state.loadStates[loadId] = false;
                });
                render();
            });
            
            document.getElementById('resetAllBreakersBtn').addEventListener('click', () => {
                // Reset regular AC breakers
                allItems.filter(i => i.type === 'acbreaker' || i.type === 'breaker').forEach(breaker => {
                    breaker.isClosed = true;
                    LiveView.state.breakerStates[breaker.id] = { isClosed: true, wasTripped: false };
                });
                
                // Reset breaker panel circuits
                allItems.filter(i => i.type === 'breakerpanel').forEach(panel => {
                    // Reset main breaker
                    panel.mainBreakerOn = true;
                    
                    // Reset all circuit breakers
                    if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                    for (let i = 0; i < 8; i++) {
                        panel.breakerStates[i] = true;
                        const breakerId = `${panel.id}-circuit-${i + 1}`;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                });
                
                // Reset spiderbox (CEP box) circuit breakers
                allItems.filter(i => i.type === 'spiderbox').forEach(spiderbox => {
                    // Reset main breaker
                    spiderbox.mainBreakerOn = true;
                    
                    if (spiderbox.handles) {
                        Object.keys(spiderbox.handles).forEach(handleKey => {
                            const handle = spiderbox.handles[handleKey];
                            if (handle && handleKey.startsWith('circuit')) {
                                handle.isClosed = true;
                                // Sync with LiveView state
                                const circuitIndex = parseInt(handleKey.match(/circuit(\d+)/)?.[1]) - 1;
                                if (circuitIndex >= 0) {
                                    const breakerId = `${spiderbox.id}-circuit-${circuitIndex + 1}`;
                                    LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                                }
                            }
                        });
                    }
                });
                
                // Recalculate power flow after resetting all breakers
                if (LiveView.state.active) {
                    LiveView.PowerFlow.calculate();
                }
                
                render();
                
                // Refresh inspector if a load, breaker panel, or spiderbox is currently selected
                if (selectedItem) {
                    if (selectedItem.type === 'acload' || selectedItem.type === 'breakerpanel' || selectedItem.type === 'spiderbox') {
                        openInspector(selectedItem);
                    }
                }
            });
            
            // Function to reset a specific tripped breaker (called from hint button)
            window.resetTrippedBreaker = function(breakerId, breakerType, panelId = null, circuitIndex = null) {
                if (breakerType === 'acbreaker') {
                    // Reset regular AC breaker
                    const breaker = allItems.find(i => i.id === breakerId && (i.type === 'acbreaker' || i.type === 'breaker'));
                    if (breaker) {
                        breaker.isClosed = true;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                } else if (breakerType === 'breakerpanel' && panelId && circuitIndex !== null) {
                    // Reset breaker panel circuit
                    const panel = allItems.find(i => i.id === panelId && i.type === 'breakerpanel');
                    if (panel) {
                        if (!panel.breakerStates) panel.breakerStates = Array(8).fill(true);
                        panel.breakerStates[circuitIndex] = true;
                        LiveView.state.breakerStates[breakerId] = { isClosed: true, wasTripped: false };
                    }
                }
                
                // Hide hint and re-render
                hideHint();
                render();
                
                // Refresh inspector if a load is currently selected (to update circuit status)
                if (selectedItem && selectedItem.type === 'acload') {
                    openInspector(selectedItem);
                }
            };
            
            // System Review button
            document.getElementById('systemReviewBtn').addEventListener('click', () => {
                showSystemReview();
            });
            
            // BOM buttons
            document.getElementById('bomCloseBtn').addEventListener('click', hideBillOfMaterials);
            document.getElementById('bomExportBtn').addEventListener('click', exportBillOfMaterials);
            
            // Simulate controls
            document.getElementById('playPauseButton').addEventListener('click', playPause);
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                simulationSpeed = parseInt(e.target.value);
                const speedLabel = document.getElementById('speedLabel');
                if (speedLabel) {
                    speedLabel.textContent = simulationSpeed + 'x';
                }
            });
            const resetSimulationBtn = document.getElementById('resetSimulationBtn');
            if (resetSimulationBtn) {
                resetSimulationBtn.addEventListener('click', () => {
                    if (isPlaying) {
                        playPause(); // Stop simulation first
                    }
                    resetSimulation();
                    updateSimulationDisplay();
                    const hourOfDay = Math.floor(elapsedHours) % 24;
                    updateBackgroundColor(hourOfDay);
                    updateShadowAngle(hourOfDay);
                    render();
                });
            }
            
            // Latitude input - update simulation when changed
            const latitudeInput = document.getElementById('simLatitudeInput');
            if (latitudeInput) {
                latitudeInput.addEventListener('change', (e) => {
                    const newLat = parseFloat(e.target.value);
                    if (!isNaN(newLat) && newLat >= -90 && newLat <= 90) {
                        simulationLatitude = newLat;
                        // Update summer solstice day based on hemisphere
                        simulationStartDayOfYear = getSummerSolsticeDay(simulationLatitude);
                        // Update displays
                        updateTimeDisplay();
                        updateSimulationDisplay();
                        const hourOfDay = Math.floor(elapsedHours) % 24;
                        updateBackgroundColor(hourOfDay);
                        render();
                    }
                });
            }
            
            // Show Hints toggle - hide any visible hint when unchecked
            document.getElementById('showHintsToggle').addEventListener('change', (e) => {
                if (!e.target.checked) {
                    hideHint();
                }
            });
            
            // Save/Load
            document.getElementById('saveBtn').addEventListener('click', saveSystem);
            document.getElementById('loadBtn').addEventListener('click', loadSystem);
            
            // Simulate mode specific buttons
            const challengeModeBtn = document.getElementById('challengeModeBtn');
            if (challengeModeBtn) {
                challengeModeBtn.addEventListener('click', () => {
                    // Toggle challenge mode - implement based on existing challenge mode system
                    // For now, just show a message
                    alert('Challenge Mode functionality needs to be implemented based on existing system');
                });
            }
            
            const weatherDifficulty = document.getElementById('weatherDifficulty');
            if (weatherDifficulty) {
                weatherDifficulty.addEventListener('change', (e) => {
                    // Store weather difficulty setting
                    if (typeof window !== 'undefined') {
                        window.weatherDifficulty = e.target.value;
                    }
                });
            }
            
            // Sidebar toggles
            document.getElementById('left-sidebar-toggle').addEventListener('click', () => {
                document.getElementById('left-sidebar').classList.toggle('collapsed');
            });
            
            // === EVENT HANDLER HELPERS ===
            
            // Simple apply handler: reads fields from DOM, updates specs, renders
            function _applySimple(type, fields) {
                if (!selectedItem || selectedItem.type !== type) return;
                fields.forEach(([specKey, elId, parser]) => {
                    const el = document.getElementById(elId);
                    if (el) selectedItem.specs[specKey] = parser ? parser(el.value) : el.value;
                });
                render();
            }
            
            // Toggle all circuits on/off for panel-type components
            function _setAllCircuits(type, circuitCount, isOn, useHandles = false) {
                if (!selectedItem || selectedItem.type !== type) return;
                if (isOn) selectedItem.mainBreakerOn = true;
                for (let i = 0; i < circuitCount; i++) {
                    if (useHandles) {
                        selectedItem.handles[`circuit${i + 1}`].isClosed = isOn;
                    } else {
                        selectedItem.breakerStates[i] = isOn;
                    }
                    const breakerId = `${selectedItem.id}-circuit-${i + 1}`;
                    LiveView.state.breakerStates[breakerId] = { isClosed: isOn, wasTripped: false };
                }
                if (!isOn && LiveView.state.active) {
                    Object.keys(LiveView.state.loadStates).forEach(loadId => {
                        const load = allItems.find(i => i.id === loadId);
                        if (load && load.type === 'acload' && !checkLoadCircuitStatus(load).isLive) {
                            LiveView.state.loadStates[loadId] = false;
                        }
                    });
                }
                if (LiveView.state.active) LiveView.Animation.scheduleUpdate();
                openInspector(selectedItem);
                render();
            }
            
            // Inspector apply buttons
            document.getElementById('applyPanelChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'panel') return;
                
                const newSpecs = {
                    name: document.getElementById('panelName').value,
                    wmp: parseFloat(document.getElementById('panelWmp').value),
                    vmp: parseFloat(document.getElementById('panelVmp').value),
                    voc: parseFloat(document.getElementById('panelVoc').value),
                    isc: parseFloat(document.getElementById('panelIsc').value),
                    imp: parseFloat(document.getElementById('panelImp').value) || 0,
                    width: parseFloat(document.getElementById('panelWidth').value) || 0,
                    height: parseFloat(document.getElementById('panelHeight').value) || 0,
                    cost: parseFloat(document.getElementById('panelCost').value)
                };
                
                // Ensure IMP is calculated if missing or zero
                if (!newSpecs.imp || newSpecs.imp === 0) {
                    if (newSpecs.wmp && newSpecs.vmp) {
                        newSpecs.imp = parseFloat((newSpecs.wmp / newSpecs.vmp).toFixed(2));
                    } else if (newSpecs.isc) {
                        newSpecs.imp = parseFloat((newSpecs.isc * 0.9).toFixed(2));
                    }
                }
                
                // Check if we should update only the array (parallel strings) or all panels
                const updateArrayOnly = document.getElementById('updateArrayOnly')?.checked || false;
                let panelsToUpdate = [];
                
                if (updateArrayOnly && selectedItem.type === 'panel') {
                    // Update only panels in the same array (all parallel strings)
                    const parallelStrings = findParallelStrings(selectedItem);
                    parallelStrings.forEach(string => {
                        panelsToUpdate.push(...string);
                    });
                } else {
                    // Update ALL panels
                    panelsToUpdate = allItems.filter(i => i.type === 'panel');
                }
                
                // Apply to selected panels
                panelsToUpdate.forEach(p => {
                    Object.assign(p.specs, newSpecs);
                    // Ensure each panel has IMP calculated if still missing
                    if (!p.specs.imp || p.specs.imp === 0) {
                        if (p.specs.wmp && p.specs.vmp) {
                            p.specs.imp = parseFloat((p.specs.wmp / p.specs.vmp).toFixed(2));
                        } else if (p.specs.isc) {
                            p.specs.imp = parseFloat((p.specs.isc * 0.9).toFixed(2));
                        }
                    }
                    
                    // Recalculate panel dimensions based on new specs
                    const panelHeightMm = p.specs.height || 992;
                    const panelWidthMm = p.specs.width || 1650;
                    const baseScale = 120; // pixels per meter
                    const pixelsPerMm = baseScale / 1000;
                    
                    const panelHeightPx = Math.max(80, Math.min(200, panelHeightMm * pixelsPerMm));
                    const panelWidthPx = (panelWidthMm / panelHeightMm) * panelHeightPx;
                    
                    p.width = panelWidthPx;
                    p.height = panelHeightPx;
                    p.specs.scaleFactor = panelHeightPx / (panelHeightMm / 1000);
                    
                    // Update handle positions
                    if (p.handles) {
                        p.handles.positive.y = panelHeightPx / 2;
                        p.handles.negative.x = panelWidthPx;
                        p.handles.negative.y = panelHeightPx / 2;
                    }
                });
                
                updatePanelArrayArea();
                render();
                validateSystem();
            });
            
            document.getElementById('applyBatteryChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'battery') return;
                
                const voltage = parseFloat(document.getElementById('batteryVoltage').value);
                const ah = parseFloat(document.getElementById('batteryAh').value);
                
                // Get low-battery protection settings
                const enableLowBatteryShutdown = document.getElementById('batteryEnableLowBatteryShutdown').checked;
                const shutdownThreshold = parseFloat(document.getElementById('batteryShutdownThreshold').value) || 10;
                const reenableThreshold = parseFloat(document.getElementById('batteryReenableThreshold').value) || 15;
                
                // Validate thresholds
                if (shutdownThreshold >= reenableThreshold) {
                    alert('Shutdown threshold must be less than re-enable threshold');
                    return;
                }
                
                const newSpecs = {
                    name: document.getElementById('batteryName').value,
                    voltage,
                    ah,
                    maxDischarge: parseFloat(document.getElementById('batteryMaxDischarge').value),
                    cost: parseFloat(document.getElementById('batteryCost').value),
                    width: parseFloat(document.getElementById('batteryWidth').value) || 200,
                    height: parseFloat(document.getElementById('batteryHeight').value) || 300,
                    kWh: (voltage * ah) / 1000,
                    lowBatteryProtection: {
                        enabled: enableLowBatteryShutdown,
                        shutdownThreshold: shutdownThreshold,
                        reenableThreshold: reenableThreshold
                    }
                };
                
                // Apply to ALL batteries
                allItems.filter(i => i.type === 'battery').forEach(b => {
                    Object.assign(b.specs, newSpecs);
                    
                    // Recalculate battery dimensions based on new specs
                    const batteryHeightMm = b.specs.height || 300;
                    const batteryWidthMm = b.specs.width || 200;
                    const baseScale = 120; // pixels per meter
                    const pixelsPerMm = baseScale / 1000;
                    
                    let batteryHeightPx = batteryHeightMm * pixelsPerMm;
                    batteryHeightPx = Math.max(60, Math.min(150, batteryHeightPx));
                    
                    const aspectRatio = batteryWidthMm / batteryHeightMm;
                    let batteryWidthPx = batteryHeightPx * aspectRatio;
                    batteryWidthPx = Math.max(80, Math.min(200, batteryWidthPx));
                    
                    b.width = batteryWidthPx;
                    b.height = batteryHeightPx;
                    b.specs.scaleFactor = batteryHeightPx / (batteryHeightMm / 1000);
                    
                    // Update handle positions
                    if (b.handles) {
                        b.handles.positive.x = batteryWidthPx * 0.25;
                        b.handles.negative.x = batteryWidthPx * 0.75;
                    }
                });
                
                render();
                validateSystem();
            });
            
            document.getElementById('applyControllerChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'controller') return;
                
                const newType = document.getElementById('controllerType').value;
                const oldType = selectedItem.specs.type;
                
                selectedItem.specs.name = document.getElementById('controllerName').value;
                selectedItem.specs.type = newType;
                selectedItem.subtype = newType;
                selectedItem.specs.maxVoc = parseFloat(document.getElementById('controllerMaxVoc').value);
                selectedItem.specs.minVmp = parseFloat(document.getElementById('controllerMinVmp').value) || 0;
                selectedItem.specs.mppVoltageMin = parseFloat(document.getElementById('controllerMppMin').value) || 0;
                selectedItem.specs.mppVoltageMax = parseFloat(document.getElementById('controllerMppMax').value) || selectedItem.specs.maxVoc;
                selectedItem.specs.maxIsc = parseFloat(document.getElementById('controllerMaxIsc').value);
                selectedItem.specs.maxWmp = parseFloat(document.getElementById('controllerMaxWmp').value);
                const newMpptCount = parseInt(document.getElementById('controllerMpptCount').value) || 1;
                const oldMpptCount = selectedItem.specs.mpptCount || 1;
                selectedItem.specs.mpptCount = newMpptCount;
                selectedItem.specs.ratedChargeCurrent = parseFloat(document.getElementById('controllerChargeCurrent').value);
                selectedItem.specs.cost = parseFloat(document.getElementById('controllerCost').value);
                selectedItem.specs.width = parseFloat(document.getElementById('controllerWidth').value) || 400;
                selectedItem.specs.height = parseFloat(document.getElementById('controllerHeight').value) || 600;
                
                // Recalculate controller dimensions based on new specs
                const controllerHeightMm = selectedItem.specs.height || 600;
                const controllerWidthMm = selectedItem.specs.width || 400;
                const baseScale = 120; // pixels per meter
                const pixelsPerMm = baseScale / 1000;
                
                let controllerHeightPx = controllerHeightMm * pixelsPerMm;
                controllerHeightPx = Math.max(80, Math.min(200, controllerHeightPx));
                
                const aspectRatio = controllerWidthMm / controllerHeightMm;
                let controllerWidthPx = controllerHeightPx * aspectRatio;
                controllerWidthPx = Math.max(100, Math.min(300, controllerWidthPx));
                
                selectedItem.width = controllerWidthPx;
                selectedItem.height = controllerHeightPx;
                selectedItem.specs.scaleFactor = controllerHeightPx / (controllerHeightMm / 1000);
                
                // Update handle positions based on new dimensions
                // Note: isHybrid and isAllInOne will be declared later in this function, so we use newType here
                const nodeHeight = controllerHeightPx;
                
                // Update PV input handles
                if (newMpptCount === 1) {
                    if (selectedItem.handles.pvPositive) {
                        selectedItem.handles.pvPositive.x = controllerWidthPx * 0.375;
                        selectedItem.handles.pvNegative.x = controllerWidthPx * 0.625;
                    }
                } else {
                    const margin = 25;
                    const availableWidth = controllerWidthPx - (2 * margin);
                    const pairWidth = 35;
                    for (let i = 0; i < newMpptCount; i++) {
                        const firstCenter = margin + pairWidth / 2;
                        const lastCenter = controllerWidthPx - margin - pairWidth / 2;
                        const xPos = firstCenter + ((lastCenter - firstCenter) / (newMpptCount - 1)) * i;
                        if (selectedItem.handles[`pvPositive${i + 1}`]) {
                            selectedItem.handles[`pvPositive${i + 1}`].x = xPos - pairWidth / 2;
                            selectedItem.handles[`pvNegative${i + 1}`].x = xPos + pairWidth / 2;
                        }
                    }
                }
                
                // Update battery output handles (only for non-all-in-one controllers)
                if (newType !== 'all_in_one' && selectedItem.handles.batteryPositive) {
                    selectedItem.handles.batteryPositive.x = controllerWidthPx * 0.375;
                    selectedItem.handles.batteryNegative.x = controllerWidthPx * 0.625;
                    selectedItem.handles.batteryPositive.y = nodeHeight + 5;
                    selectedItem.handles.batteryNegative.y = nodeHeight + 5;
                }
                
                // Update AC output handle (will be handled later in the function)
                // Update smart battery ports (will be handled later in the function)
                // Update parallel port (will be handled later in the function)
                
                // If MPPT count changed, recreate PV handles
                if (newMpptCount !== oldMpptCount) {
                    // Remove old PV handles
                    Object.keys(selectedItem.handles).forEach(key => {
                        if (key.startsWith('pvPositive') || key.startsWith('pvNegative')) {
                            delete selectedItem.handles[key];
                        }
                    });
                    
                    // Create new PV handles based on MPPT count using calculated dimensions
                    const isAllInOne = selectedItem.specs.type === 'all_in_one';
                    const nodeHeight = controllerHeightPx; // Use calculated height
                    
                    if (newMpptCount === 1) {
                        selectedItem.handles.pvPositive = { 
                            id: `${selectedItem.id}-pv-pos`, 
                            polarity: 'pv-positive', 
                            x: controllerWidthPx * 0.375, 
                            y: -5, 
                            side: 'top', 
                            connectedTo: [], 
                            mpptIndex: 0 
                        };
                        selectedItem.handles.pvNegative = { 
                            id: `${selectedItem.id}-pv-neg`, 
                            polarity: 'pv-negative', 
                            x: controllerWidthPx * 0.625, 
                            y: -5, 
                            side: 'top', 
                            connectedTo: [], 
                            mpptIndex: 0 
                        };
                    } else {
                        // Multiple MPPTs: distribute ports with more spacing to prevent overlap
                        const margin = 25; // Margin on each side
                        const pairWidth = 35; // Width of each port pair (distance between + and -)
                        
                        // Calculate spacing: distribute pairs evenly across available width
                        for (let i = 0; i < newMpptCount; i++) {
                            let xPos;
                            if (newMpptCount === 1) {
                                xPos = controllerWidthPx / 2;
                            } else {
                                // Distribute evenly: first at margin + pairWidth/2, last at controllerWidthPx - margin - pairWidth/2
                                const firstCenter = margin + pairWidth / 2;
                                const lastCenter = controllerWidthPx - margin - pairWidth / 2;
                                xPos = firstCenter + ((lastCenter - firstCenter) / (newMpptCount - 1)) * i;
                            }
                            
                            selectedItem.handles[`pvPositive${i + 1}`] = { 
                                id: `${selectedItem.id}-pv-pos-${i + 1}`, 
                                polarity: 'pv-positive', 
                                x: xPos - pairWidth / 2, 
                                y: -5, 
                                side: 'top', 
                                connectedTo: [], 
                                mpptIndex: i 
                            };
                            selectedItem.handles[`pvNegative${i + 1}`] = { 
                                id: `${selectedItem.id}-pv-neg-${i + 1}`, 
                                polarity: 'pv-negative', 
                                x: xPos + pairWidth / 2, 
                                y: -5, 
                                side: 'top', 
                                connectedTo: [], 
                                mpptIndex: i 
                            };
                        }
                        // Also create legacy handles for backward compatibility
                        selectedItem.handles.pvPositive = selectedItem.handles.pvPositive1;
                        selectedItem.handles.pvNegative = selectedItem.handles.pvNegative1;
                    }
                }
                
                // Get supported voltages from checkboxes
                const supportedVoltages = [];
                if (document.getElementById('controllerV12').checked) supportedVoltages.push(12);
                if (document.getElementById('controllerV24').checked) supportedVoltages.push(24);
                if (document.getElementById('controllerV36').checked) supportedVoltages.push(36);
                if (document.getElementById('controllerV48').checked) supportedVoltages.push(48);
                selectedItem.specs.supportedVoltages = supportedVoltages.length > 0 ? supportedVoltages : [12];
                
                // Handle AC output for hybrid inverters
                const isHybrid = newType === 'hybrid_inverter' || newType === 'all_in_one';
                const isAllInOne = newType === 'all_in_one';
                const wasHybrid = oldType === 'hybrid_inverter' || oldType === 'all_in_one';
                
                if (isHybrid) {
                    selectedItem.specs.maxACOutputW = parseFloat(document.getElementById('controllerACOutputW').value) || 0;
                    selectedItem.specs.inverterLoad = parseFloat(document.getElementById('controllerInverterLoad').value) || 0;
                    // Add AC output handle if it doesn't exist
                    if (!selectedItem.handles.acOutput) {
                        selectedItem.handles.acOutput = { 
                            id: `${selectedItem.id}-ac-out`, 
                            polarity: 'ac', 
                            x: selectedItem.width + 5, 
                            y: selectedItem.height * 0.5, 
                            side: 'right', 
                            connectedTo: [] 
                        };
                    } else {
                        // Update AC output handle position with new dimensions
                        selectedItem.handles.acOutput.x = selectedItem.width + 5;
                        selectedItem.handles.acOutput.y = selectedItem.height * 0.5;
                    }
                } else {
                    // Remove AC output handle if switching from hybrid to non-hybrid
                    if (wasHybrid && selectedItem.handles.acOutput) {
                        // Delete any connections to this handle
                        const acHandleId = selectedItem.handles.acOutput.id;
                        const connToDelete = connections.filter(c => 
                            c.sourceHandleId === acHandleId || c.targetHandleId === acHandleId
                        );
                        connToDelete.forEach(c => deleteConnection(c.id));
                        delete selectedItem.handles.acOutput;
                        delete selectedItem.specs.maxACOutputW;
                    }
                }
                
                // Update smart battery ports with new dimensions
                if (isAllInOne && selectedItem.specs.smartBatteryPorts) {
                    for (let i = 0; i < selectedItem.specs.smartBatteryPorts; i++) {
                        if (selectedItem.handles[`smartBattery${i + 1}`]) {
                            selectedItem.handles[`smartBattery${i + 1}`].y = selectedItem.height * 0.35 + (i * 35);
                        }
                    }
                }
                
                // Update parallel port with new dimensions
                if (selectedItem.specs.parallelCapable && selectedItem.handles.parallelPort) {
                    selectedItem.handles.parallelPort.x = selectedItem.width + 5;
                    selectedItem.handles.parallelPort.y = selectedItem.height * 0.25;
                }
                
                // Save styling options
                selectedItem.specs.topColor = document.getElementById('controllerTopColor').value;
                selectedItem.specs.bottomColor = document.getElementById('controllerBottomColor').value;
                selectedItem.specs.dividerHeight = parseFloat(document.getElementById('controllerDividerHeight').value) || 50;
                const imageUrlValue = document.getElementById('controllerImageUrl').value.trim();
                selectedItem.specs.imageUrl = imageUrlValue || null;
                
                // Force a full re-render by clearing the controller group and re-rendering
                // This ensures dimensions and styling changes are immediately visible
                const controllerGroup = itemsGroup.select(`[data-id="${selectedItem.id}"]`);
                if (controllerGroup.node()) {
                    controllerGroup.selectAll("*").remove(); // Clear all existing content
                }
                
                render(); // Full re-render
                validateSystem();
            });
            
            // Toggle AC output visibility when controller type changes
            document.getElementById('controllerType').addEventListener('change', (e) => {
                const isHybrid = e.target.value === 'hybrid_inverter' || e.target.value === 'all_in_one';
                document.getElementById('controllerACOutput').classList.toggle('hidden', !isHybrid);
            });
            
            document.getElementById('deleteWire').addEventListener('click', () => {
                if (selectedConnection) {
                    deleteConnection(selectedConnection.id);
                    closeInspector();
                }
            });
            
            // Add breaker to wire
            document.getElementById('addBreakerToWire').addEventListener('click', () => {
                if (!selectedConnection) return;
                
                const conn = selectedConnection;
                const sourceItem = allItems.find(i => i.id === conn.sourceItemId);
                const targetItem = allItems.find(i => i.id === conn.targetItemId);
                if (!sourceItem || !targetItem) return;
                
                // Calculate expected current and auto-size breaker
                const expectedCurrent = calculateWireCurrent(conn);
                const breakerRating = autosizeBreaker(expectedCurrent > 0 ? expectedCurrent : 10);
                const breakerPreset = BREAKER_PRESETS.find(b => b.rating >= breakerRating) || BREAKER_PRESETS[1];
                
                // Position breaker between source and target
                const sourceHandle = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                const targetHandle = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                const midX = (sourceItem.x + sourceHandle.x + targetItem.x + targetHandle.x) / 2 - BREAKER_WIDTH / 2;
                const midY = (sourceItem.y + sourceHandle.y + targetItem.y + targetHandle.y) / 2 - BREAKER_HEIGHT / 2;
                
                // Create breaker
                const breaker = createBreaker(midX, midY, breakerPreset);
                allItems.push(breaker);
                
                // Delete old connection
                deleteConnection(conn.id);
                
                // Create new connections through breaker
                // Source -> Breaker Line
                const sourceHandleObj = Object.values(sourceItem.handles).find(h => h.id === conn.sourceHandleId);
                const breakerLineHandle = sourceHandleObj.polarity === 'positive' || sourceHandleObj.polarity === 'pv-positive' 
                    ? breaker.handles.linePositive : breaker.handles.lineNegative;
                createConnection(sourceItem, sourceHandleObj, breaker, breakerLineHandle);
                
                // Breaker Load -> Target
                const targetHandleObj = Object.values(targetItem.handles).find(h => h.id === conn.targetHandleId);
                const breakerLoadHandle = targetHandleObj.polarity === 'positive' || targetHandleObj.polarity === 'pv-positive'
                    ? breaker.handles.loadPositive : breaker.handles.loadNegative;
                createConnection(breaker, breakerLoadHandle, targetItem, targetHandleObj);
                
                closeInspector();
                render();
                showHint("üîå Breaker Added", `A ${breakerPreset.rating}A breaker has been added to protect this circuit.`);
            });
            
            // Breaker inspector buttons
            document.getElementById('toggleBreaker').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                selectedItem.isClosed = !selectedItem.isClosed;
                openInspector(selectedItem); // Refresh inspector
                render();
            });
            
            document.getElementById('applyBreakerChanges').addEventListener('click', () => _applySimple('breaker', [
                ['rating', 'breakerRating', parseInt], ['maxVoltage', 'breakerMaxVoltage', parseFloat], ['cost', 'breakerCost', parseFloat]
            ]));
            
            document.getElementById('autosizeBreaker').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'breaker') return;
                
                // Find connections to this breaker and calculate expected current
                const breakerConns = connections.filter(c => 
                    c.sourceItemId === selectedItem.id || c.targetItemId === selectedItem.id
                );
                
                let maxCurrent = 0;
                breakerConns.forEach(conn => {
                    const current = calculateWireCurrent(conn);
                    if (current > maxCurrent) maxCurrent = current;
                });
                
                if (maxCurrent > 0) {
                    const newRating = autosizeBreaker(maxCurrent);
                    selectedItem.specs.rating = newRating;
                    document.getElementById('breakerRating').value = newRating;
                    render();
                    showHint("‚ö° Breaker Auto-Sized", `Breaker sized to ${newRating}A based on expected ${maxCurrent.toFixed(1)}A current.`);
                } else {
                    showHint("‚ö†Ô∏è Cannot Auto-Size", "Connect the breaker to a circuit first to auto-size based on expected current.");
                }
            });
            
            // Combiner inspectors
            document.getElementById('applyCombinerChanges').addEventListener('click', () => _applySimple('combiner', [
                ['maxAmpsPerInput', 'combinerMaxAmps', parseFloat], ['cost', 'combinerCost', parseFloat]
            ]));
            document.getElementById('applySolarCombinerChanges').addEventListener('click', () => _applySimple('solarcombiner', [
                ['breakerRating', 'solarCombinerBreakerRating', parseInt], ['maxVoltage', 'solarCombinerMaxVoltage', parseFloat], ['cost', 'solarCombinerCost', parseFloat]
            ]));
            
            // Spider Box inspector
            document.getElementById('applySpiderboxChanges').addEventListener('click', () => _applySimple('spiderbox', [['cost', 'spiderboxCost', parseFloat]]));
            document.getElementById('spiderboxAllOn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                _setAllCircuits('spiderbox', selectedItem.specs.circuits.length, true, true);
            });
            document.getElementById('spiderboxAllOff').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'spiderbox') return;
                _setAllCircuits('spiderbox', selectedItem.specs.circuits.length, false, true);
            });
            
            // Breaker Panel inspector
            document.getElementById('applyBreakerpanelChanges').addEventListener('click', () => _applySimple('breakerpanel', [['cost', 'breakerpanelCost', parseFloat]]));
            document.getElementById('breakerpanelAllOn').addEventListener('click', () => _setAllCircuits('breakerpanel', 8, true, false));
            document.getElementById('breakerpanelAllOff').addEventListener('click', () => _setAllCircuits('breakerpanel', 8, false, false));
            
            // AC Load inspector
            document.getElementById('loadPreset').addEventListener('change', (e) => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                const preset = APPLIANCE_PRESETS[parseInt(e.target.value)];
                selectedItem.specs.name = preset.name;
                selectedItem.specs.voltage = preset.voltage;
                selectedItem.specs.maxWatts = preset.maxWatts;
                selectedItem.specs.avgWatts = preset.avgWatts;
                selectedItem.specs.icon = preset.icon;
                // Deep copy behavior
                selectedItem.specs.behavior = preset.behavior ? JSON.parse(JSON.stringify(preset.behavior)) : { type: 'constant' };
                // Deep copy recipes if present
                selectedItem.specs.recipes = preset.recipes ? JSON.parse(JSON.stringify(preset.recipes)) : undefined;
                
                // Update dimensions for recipe-based loads
                const isRecipeBased = selectedItem.specs.recipes && selectedItem.specs.recipes.length > 0;
                if (isRecipeBased) {
                    selectedItem.width = RECIPE_LOAD_WIDTH;
                    selectedItem.height = RECIPE_LOAD_HEIGHT;
                    // Move cord to left side
                    selectedItem.handles.cord.x = -5;
                    selectedItem.handles.cord.y = selectedItem.height / 2;
                    selectedItem.handles.cord.side = 'left';
                    // Regenerate resource ports
                    regeneratePortsForLoad(selectedItem);
                } else {
                    selectedItem.width = AC_LOAD_WIDTH;
                    selectedItem.height = AC_LOAD_HEIGHT;
                    // Move cord to top
                    selectedItem.handles.cord.x = selectedItem.width / 2;
                    selectedItem.handles.cord.y = -5;
                    selectedItem.handles.cord.side = 'top';
                    // Remove resource ports (keep only cord)
                    selectedItem.handles = { cord: selectedItem.handles.cord };
                }
                
                openInspector(selectedItem);
                render();
            });
            
            // Behavior type change
            document.getElementById('loadBehaviorType').addEventListener('change', (e) => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                const newType = e.target.value;
                
                // Hide all behavior sections
                document.querySelectorAll('.behavior-section').forEach(el => el.classList.add('hidden'));
                
                if (newType === 'simple') {
                    selectedItem.specs.behavior = { type: 'simple' };
                    document.getElementById('behaviorSimple').classList.remove('hidden');
                } else if (newType === 'recipe') {
                    selectedItem.specs.behavior = { type: 'recipe' };
                    if (!selectedItem.specs.recipes) {
                        selectedItem.specs.recipes = [];
                    }
                    document.getElementById('behaviorRecipe').classList.remove('hidden');
                    populateRecipeList(selectedItem);
                }
            });
            
            // Add recipe button - opens inline editor
            document.getElementById('addRecipeBtn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                if (!selectedItem.specs.recipes) selectedItem.specs.recipes = [];
                openRecipeEditor(selectedItem, null);
            });
            
            // Recipe editor - Add Input button
            document.getElementById('addRecipeInputBtn').addEventListener('click', () => {
                addRecipeIORow('recipeEditorInputs', 'input');
            });
            
            // Recipe editor - Add Output button
            document.getElementById('addRecipeOutputBtn').addEventListener('click', () => {
                addRecipeIORow('recipeEditorOutputs', 'output');
            });
            
            // Recipe editor - Save button
            document.getElementById('saveRecipeBtn').addEventListener('click', () => {
                const editor = document.getElementById('recipeEditor');
                const itemId = editor.dataset.itemId;
                const recipeIndex = editor.dataset.recipeIndex;
                
                const item = allItems.find(i => i.id === itemId);
                if (!item || item.type !== 'acload') return;
                
                // Collect recipe data from editor
                const recipe = {
                    name: document.getElementById('recipeEditorName').value || 'Unnamed Recipe',
                    durationHours: (parseFloat(document.getElementById('recipeEditorDuration').value) || 60) / 60,
                    energyWh: parseFloat(document.getElementById('recipeEditorEnergy').value) || 100,
                    inputs: collectRecipeIO('recipeEditorInputs'),
                    outputs: collectRecipeIO('recipeEditorOutputs')
                };
                
                // Save or update recipe
                if (!item.specs.recipes) item.specs.recipes = [];
                
                if (recipeIndex === 'new') {
                    item.specs.recipes.push(recipe);
                } else {
                    const idx = parseInt(recipeIndex);
                    if (idx >= 0 && idx < item.specs.recipes.length) {
                        item.specs.recipes[idx] = recipe;
                    }
                }
                
                // Regenerate ports for the load based on new recipes
                regeneratePortsForLoad(item);
                
                // Close editor and refresh
                editor.classList.add('hidden');
                populateRecipeList(item);
                render();
            });
            
            // Recipe editor - Cancel button
            document.getElementById('cancelRecipeBtn').addEventListener('click', () => {
                document.getElementById('recipeEditor').classList.add('hidden');
            });
            
            // Add automation button
            document.getElementById('addAutomationBtn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                if (!selectedItem.automations) selectedItem.automations = [];
                openAutomationEditor(selectedItem, null);
            });
            
            // Automation editor handlers
            document.getElementById('automationTriggerType').addEventListener('change', updateAutomationFields);
            document.getElementById('automationAction').addEventListener('change', updateAutomationFields);
            
            // Recipe selection change - update details display
            document.getElementById('automationRecipeSelect').addEventListener('change', (e) => {
                const editor = document.getElementById('automationEditor');
                const itemId = editor.dataset.itemId;
                const item = allItems.find(i => i.id === itemId);
                if (item) {
                    updateRecipeDetails(item, parseInt(e.target.value) || 0);
                }
            });
            
            document.getElementById('saveAutomationBtn').addEventListener('click', () => {
                const editor = document.getElementById('automationEditor');
                const itemId = editor.dataset.itemId;
                const automationIndex = editor.dataset.automationIndex;
                
                if (!itemId) return;
                const item = allItems.find(i => i.id === itemId);
                if (!item || item.type !== 'acload') return;
                if (!item.automations) item.automations = [];
                
                const automation = {
                    action: document.getElementById('automationAction').value,
                    triggerType: document.getElementById('automationTriggerType').value
                };
                
                // Add fields based on trigger type
                if (automation.triggerType === 'timeOfDay') {
                    automation.startHour = parseInt(document.getElementById('automationStartHour').value) || 18;
                    automation.endHour = parseInt(document.getElementById('automationEndHour').value) || 6;
                } else if (automation.triggerType === 'batteryLevel') {
                    automation.targetNodeLabel = document.getElementById('automationBatteryLabel').value.trim();
                    automation.condition = document.getElementById('automationBatteryCondition').value;
                    automation.threshold = parseFloat(document.getElementById('automationBatteryThreshold').value) || 80;
                } else if (automation.triggerType === 'solarInput') {
                    automation.targetNodeLabel = document.getElementById('automationSolarLabel').value.trim();
                    automation.condition = document.getElementById('automationSolarCondition').value;
                } else if (automation.triggerType === 'containerValue') {
                    automation.targetNodeLabel = document.getElementById('automationContainerLabel').value.trim();
                    automation.condition = document.getElementById('automationContainerCondition').value;
                    automation.threshold = parseFloat(document.getElementById('automationContainerThreshold').value) || 10;
                }
                
                // Add recipe index if action is startRecipe
                if (automation.action === 'startRecipe') {
                    automation.recipeIndex = parseInt(document.getElementById('automationRecipeSelect').value) || 0;
                }
                
                // Save or update
                if (automationIndex === 'new') {
                    item.automations.push(automation);
                } else {
                    const idx = parseInt(automationIndex);
                    if (idx >= 0 && idx < item.automations.length) {
                        item.automations[idx] = automation;
                    }
                }
                
                editor.classList.add('hidden');
                populateAutomationList(item);
                render();
            });
            
            document.getElementById('cancelAutomationBtn').addEventListener('click', () => {
                document.getElementById('automationEditor').classList.add('hidden');
            });
            
            // Processor inspector removed - recipe-based loads are handled in load inspector
            
            // Resource Container Inspector handlers
            document.getElementById('applyContainerChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                
                selectedItem.specs.name = document.getElementById('containerName').value;
                selectedItem.specs.resourceType = document.getElementById('containerResourceType').value;
                selectedItem.specs.capacity = parseFloat(document.getElementById('containerCapacity').value) || 100;
                selectedItem.specs.value = parseFloat(document.getElementById('containerValue').value) || 0;
                selectedItem.specs.unit = document.getElementById('containerUnit').value || 'units';
                
                // Update handle resource types
                if (selectedItem.handles.input) {
                    selectedItem.handles.input.resourceType = selectedItem.specs.resourceType;
                }
                if (selectedItem.handles.output) {
                    selectedItem.handles.output.resourceType = selectedItem.specs.resourceType;
                }
                
                openInspector(selectedItem); // Refresh display
                render();
            });
            
            document.getElementById('containerFillBtn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                selectedItem.specs.value = selectedItem.specs.capacity || 100;
                document.getElementById('containerValue').value = selectedItem.specs.value;
                openInspector(selectedItem); // Refresh display
                render();
            });
            
            document.getElementById('containerEmptyBtn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                selectedItem.specs.value = 0;
                document.getElementById('containerValue').value = 0;
                openInspector(selectedItem); // Refresh display
                render();
            });
            
            document.getElementById('deleteContainerBtn').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'resourcecontainer') return;
                
                // Remove all connections to/from this container
                connections = connections.filter(c => 
                    c.sourceItemId !== selectedItem.id && c.targetItemId !== selectedItem.id
                );
                
                // Remove from allItems
                allItems = allItems.filter(i => i.id !== selectedItem.id);
                
                // Close inspector
                selectedItem = null;
                document.getElementById('resourceContainerInspector').classList.add('hidden');
                document.getElementById('inspectorEmpty').classList.remove('hidden');
                
                render();
            });
            
            document.getElementById('applyLoadChanges').addEventListener('click', () => {
                if (!selectedItem || selectedItem.type !== 'acload') return;
                selectedItem.specs.name = document.getElementById('loadName').value;
                selectedItem.specs.voltage = parseInt(document.getElementById('loadVoltage').value);
                selectedItem.specs.maxWatts = parseFloat(document.getElementById('loadMaxWatts').value) || 0;
                selectedItem.specs.icon = document.getElementById('loadIcon').value || '‚ö°';
                
                // Save power and behavior
                selectedItem.specs.avgWatts = parseFloat(document.getElementById('loadAvgWatts').value) || 0;
                
                const behaviorType = document.getElementById('loadBehaviorType').value;
                if (behaviorType === 'simple') {
                    selectedItem.specs.behavior = { type: 'simple' };
                } else if (behaviorType === 'recipe') {
                    selectedItem.specs.behavior = { type: 'recipe' };
                    // Recipes are managed separately via the recipe editor
                }
                render();
            });
            
            // Hint buttons - use event delegation so it works even after innerHTML replacement
            const hintPopup = document.getElementById('hintPopup');
            if (hintPopup) {
                hintPopup.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'hintDismiss') {
                        hideHint();
                    } else if (e.target && e.target.id === 'hintNext') {
                        // For now, "Next" just hides the hint (can be extended for hint progression)
                        hideHint();
                    } else if (e.target && e.target.id === 'hintHide') {
                        // Disable hints and hide the popup
                        const showHintsToggle = document.getElementById('showHintsToggle');
                        if (showHintsToggle) {
                            showHintsToggle.checked = false;
                        }
                        hideHint();
                    }
                });
            }
            
            // Achievement close
            document.getElementById('achievementClose').addEventListener('click', hideAchievement);
            document.getElementById('startSimulation').addEventListener('click', () => {
                hideAchievement();
                setMode('simulate');
            });
            
            // Canvas click to deselect
            svg.on("click", () => {
                deselectAll();
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                updateSvgDimensions();
            });
        });
    </script>
</body>
</html>

