<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node-Based System Simulator - Advanced Batching</title>
    <script src="./d3.v7.min.js"></script>
    <style>
        /* CSS same as "Refinements" version */
        body { font-family: Arial, sans-serif; background-color: #2d2d2d; color: #e8e8e8; margin: 0; padding: 0; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        .toolbar { 
            background: linear-gradient(135deg, #1a2b3c 0%, #2a3b4c 100%);
            border-top: 3px solid #ffdd57;
            box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.5);
            padding: 12px 20px; 
            display: flex; 
            gap: 15px; 
            align-items: center; 
            justify-content: space-between;
            flex-shrink: 0; 
            z-index: 999;
        }
        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 0 0 auto;
        }
        .toolbar-center {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1 1 auto;
            justify-content: center;
        }
        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 0 0 auto;
        }
        .toolbar button { 
            padding: 8px 14px; 
            background: rgba(0, 0, 0, 0.3);
            color: #fff; 
            border: 2px solid rgba(255, 221, 87, 0.3); 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        .toolbar button:hover { 
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 221, 87, 0.6);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 221, 87, 0.3);
        }
        .toolbar .time-display { 
            font-size: 1.1em; 
            color: #ffdd57; 
            font-weight: 600;
            text-shadow: 0 0 10px rgba(255, 221, 87, 0.5);
        }
        .toolbar .play-controls { 
            display: flex; 
            align-items: center; 
            gap: 12px;
        }
        .toolbar .play-controls button#playPauseButton { 
            font-size: 1.4em; 
            padding: 8px 16px;
            min-width: 50px;
        }
        .toolbar input[type="range"] { 
            width: 200px; 
            cursor: pointer; 
            margin: 0;
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            outline: none;
        }
        .toolbar input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ffdd57;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 221, 87, 0.6);
        }
        .toolbar input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #ffdd57;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(255, 221, 87, 0.6);
        }
        .toolbar .speed-label { 
            font-size: 0.95em; 
            color: #ffdd57; 
            font-weight: 600;
            min-width: 45px;
        }
        .toolbar select {
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            border: 2px solid rgba(255, 221, 87, 0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .toolbar select:hover {
            border-color: rgba(255, 221, 87, 0.6);
            background: rgba(0, 0, 0, 0.5);
        }
        .toolbar label {
            color: #aaa;
            font-size: 0.9em;
            font-weight: 600;
        }
        #main-content { 
            display: flex; 
            flex-grow: 1; 
            overflow: hidden; 
            position: relative;
        }
        #canvas-container { 
            flex-grow: 1; 
            position: relative; 
            overflow: hidden;
            transition: background-color 1s ease-in-out;
        }
        svg { 
            width: 100%; 
            height: 100%; 
            background-color: #1a2b3c; 
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px); 
            background-size: 35px 35px; 
            position: relative;
            transition: background-color 1s ease-in-out;
        }
        .node { cursor: grab; }
        .node-rect { 
            stroke: #666; 
            stroke-width: 1.5px; 
            rx: 8px; 
            ry: 8px; 
            fill: #444; 
            transition: stroke 0.2s ease-out, stroke-width 0.2s ease-out, fill 0.2s ease-out;
            will-change: stroke, stroke-width, fill;
        }
        .node.resource-display:not(.battery) .node-rect { fill: #e8e8e8 !important; stroke: #999 !important; }  /* Gray/white for IBC containers */
        .node.resource-display[class*="PlasticFlakes"] .node-rect,
        .node.resource-display[class*="Biochar"] .node-rect,
        .node.resource-display[class*="PoopGas"] .node-rect { fill: #e8e8e8 !important; stroke: #999 !important; }  /* Ensure specific IBC containers have light background */
        .node.selected .node-rect { stroke: #ffdd57; stroke-width: 3px; }
        .ibc-grid { stroke: #666666; stroke-width: 3px; fill: none; pointer-events: none; } 
        .node.processor .node-rect { stroke: #777; stroke-width: 2px; fill: #3a3a3a; rx: 12px; ry: 12px; }  /* More square, distinct styling for processors */
        .node.processor.is-running .node-rect, .node.solar-array.is-running .node-rect { stroke: #5cb85c; stroke-width: 3px; }
        .node.processor.is-stalled .node-rect { stroke: #d9534f; stroke-width: 3px; }
        .node.processor.is-awaiting-batch .node-rect { stroke: #f0ad4e; stroke-width: 3px; }
        .node-title { fill: #ffffff; font-size: 18px; font-weight: bold; text-anchor: middle; pointer-events: none; text-transform: uppercase; paint-order: stroke; stroke: #000000; stroke-width: 2px; stroke-linecap: round; stroke-linejoin: round; }
        .processor .node-title { font-size: 19px; }  /* Slightly larger for processors */
        .resource-display:not(.battery) .node-title { fill: #000000 !important; stroke: none !important; }  /* Black text for IBC containers, no stroke */
        .node-img { pointer-events: none; object-fit: contain; opacity: 0.9; }
        .node-extra-text { fill: #b0b0b0; font-size: 11px; text-anchor: middle; pointer-events: none; }
        .resource-display .node-value { fill: #ffffff; font-size: 52px; font-weight: bold; text-anchor: middle; pointer-events: none; }  /* Larger value labels */
        .resource-display .node-unit { fill: #d0d0d0; font-size: 24px; font-weight: 700; text-anchor: middle; pointer-events: none; }  /* Larger, bolder unit labels */
        .resource-display:not(.battery) .node-value { fill: #000000; }  /* Black text for IBC containers */
        .resource-display:not(.battery) .node-unit { fill: #333333; }  /* Dark gray text for IBC containers */
        .resource-display .node-img { opacity: 0.85; }
        .resource-display .capacity-bar-bg { fill: #303030; }
        .resource-display:not(.battery) .capacity-bar-bg { fill: #e8e8e8; }  /* Match IBC background for non-battery containers */
        .resource-display .capacity-bar-fill { 
            fill: #6fa06c; 
            transition: height 0.3s ease-out, y 0.3s ease-out;
            will-change: height, transform;
        }
        .processor .node-img { opacity: 0.95; }
        .processor .io-area { pointer-events: none; } 
        .processor .port-text-label { fill: #e0e0e0; font-size: 12px; font-weight: 500; pointer-events: none; }  /* Larger, more readable port labels */
        .processor .port-text-label.input { text-anchor: start; }
        .processor .port-text-label.output { text-anchor: end; }
        .processor .node-action-button rect { fill: #555; stroke: #777; rx: 4; ry: 4; cursor: pointer; }
        .processor .node-action-button rect:hover { fill: #6a6a6a; }
        .processor .node-action-button text { fill: #fff; font-size: 12px; text-anchor: middle; pointer-events: none; }
        .port-handle { 
            stroke: #aaa; 
            stroke-width: 2.5px; 
            cursor: pointer; 
            r: 13px;  /* Slightly larger for better visibility */
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));  /* Better visibility */
            user-select: none;
        }
        .port-handle.input { fill: #70a0d0; } 
        .port-handle.output { fill: #70c070; }
        .port-handle:hover { 
            r: 14px;
            filter: brightness(1.25); 
        }
        .port-handle:active {
            r: 14px;
            filter: brightness(1.5);
        }
        .connection { 
            stroke-width: 4.5px; 
            fill:none; 
            pointer-events:none;
            transition: opacity 0.2s ease-in-out;
            will-change: opacity;
            opacity: 0.4;  /* Default: inactive connections are faded */
        }
        .connection.connection-active {
            opacity: 1.0;  /* Active connections are fully visible */
        }
        .connection.is-flowing { stroke-dasharray: 10, 5; animation: flow 1s linear infinite; }
        @keyframes flow { to { stroke-dashoffset: -15; } }
        .connection.power { stroke: #e080e0; } .connection.plastic { stroke: #efdc70; } 
        .connection.plastic-flakes { stroke: #80b0e0; } .connection.wind-turbines { stroke: #80d080; }
        .connection.biomass { stroke: #8B4513; } .connection.woodgas { stroke: #FFDEAD; } .connection.biochar { stroke: #404040; }
        .temp-connection { stroke: #ffdd57; stroke-width: 3px; stroke-dasharray: 5,5; fill: none; }
        .close-button { cursor: pointer; fill: #aaa; font-size:14px; font-weight:bold; text-anchor: middle;}
        #challengeOverlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 0, 0, 0.95) 100%);
            z-index: 10000; 
            display: none; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            color: white; 
            font-family: Arial, sans-serif;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
        }
        #challengeOverlay.visible { display: flex; }
        #challengeOverlay h1 { 
            font-size: 42px; 
            color: #ff0000; 
            margin-bottom: 20px; 
            margin-top: 0;
            animation: flash 1s infinite;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8), 0 0 40px rgba(255, 0, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        #challengeOverlay .challenge-content {
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 221, 87, 0.3);
            overflow-y: auto;
            box-sizing: border-box;
        }
        #challengeOverlay .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }
        #challengeOverlay .stat-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 221, 87, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }
        #challengeOverlay .stat-card:hover {
            border-color: rgba(255, 221, 87, 0.5);
            background: rgba(0, 0, 0, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 221, 87, 0.2);
        }
        #challengeOverlay .stat-card .stat-label {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            font-weight: 600;
        }
        #challengeOverlay .stat-card .stat-value {
            font-size: 22px;
            font-weight: bold;
            color: #ffdd57;
            text-shadow: 0 0 10px rgba(255, 221, 87, 0.5);
            margin-bottom: 3px;
        }
        #challengeOverlay .stat-card .stat-unit {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #challengeOverlay .stat-card.negative .stat-value {
            color: #d9534f;
        }
        #challengeOverlay .stat-card.positive .stat-value {
            color: #5cb85c;
        }
        #challengeOverlay .resources-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid rgba(255, 221, 87, 0.2);
        }
        #challengeOverlay .resources-section h3 {
            font-size: 16px;
            color: #ffdd57;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #challengeOverlay .resources-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        #challengeOverlay .resource-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            border-left: 3px solid #ffdd57;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #challengeOverlay .resource-item .resource-name {
            color: #ccc;
            font-size: 12px;
        }
        #challengeOverlay .resource-item .resource-value {
            color: #ffdd57;
            font-weight: bold;
            font-size: 14px;
        }
        #challengeOverlay button { 
            margin-top: 25px; 
            padding: 12px 35px; 
            font-size: 16px; 
            background: linear-gradient(135deg, #555 0%, #444 100%);
            color: white; 
            border: 2px solid #777; 
            border-radius: 8px; 
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        #challengeOverlay button:hover { 
            background: linear-gradient(135deg, #6a6a6a 0%, #555 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .close-button:hover { fill: #fff; }
        #sidebar { 
            width: 300px;
            background-color: #3a3a3a;
            padding: 15px;
            padding-bottom: 80px;
            box-sizing: border-box;
            overflow-y: auto;
            border-right: 1px solid #555;
            color: #e8e8e8;
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            z-index: 1000;
            transition: width 0.3s ease, opacity 0.3s ease;
        }
        #sidebar.collapsed {
            width: 0 !important;
            padding: 0 !important;
            overflow: visible;
            border-right: none;
        }
        #sidebar.collapsed > *:not(#sidebar-toggle) {
            opacity: 0;
            pointer-events: none;
        }
        #sidebar:not(.collapsed) > *:not(#sidebar-toggle) {
            opacity: 1;
            pointer-events: auto;
        }
        #sidebar-toggle {
            position: fixed !important;
            right: 0 !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            width: 30px !important;
            height: 60px !important;
            min-width: 30px !important;
            max-width: 30px !important;
            min-height: 60px !important;
            max-height: 60px !important;
            background-color: #3a3a3a !important;
            border: 1px solid #555 !important;
            border-left: none !important;
            border-radius: 4px 0 0 4px !important;
            cursor: pointer;
            display: flex !important;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 18px;
            z-index: 10000 !important;
            transition: background-color 0.2s ease, right 0.3s ease, border-radius 0.3s ease;
            pointer-events: auto !important;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
            opacity: 1 !important;
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
            flex: none !important;
        }
        #sidebar-toggle:hover {
            background-color: #4a4a4a;
        }
        #sidebar:not(.collapsed) #sidebar-toggle {
            right: 300px;
            border-radius: 0 4px 4px 0;
            border-left: none;
            border-right: 1px solid #555;
        }
        #sidebar h3,#sidebar h4{margin-top:0;margin-bottom:10px;color:#fff;} #sidebar div>label,#sidebar label{margin-bottom:8px;display:block;font-size:0.95em;} #sidebar input[type="text"],#sidebar input[type="number"],#sidebar select, #sidebar input[type="checkbox"]{width:calc(100% - 12px);padding:7px;background-color:#4a4a4a;color:#fff;border:1px solid #666;border-radius:3px;box-sizing:border-box;margin-top:4px;}
        #sidebar input[type="checkbox"] { width: auto; margin-right: 5px; vertical-align: middle;}
        #sidebar button{
            padding:8px 12px;
            background-color:#555;
            color:#fff;
            border:1px solid #777;
            border-radius:4px;
            cursor:pointer;
            margin-top:5px;
            width:100%;
            box-sizing:border-box;
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }
        #sidebar button:hover{background-color:#6a6a6a;}
        #sidebar .sidebar-section button{width:auto;padding:3px 6px;float:right;font-size:1.1em;} .io-item{border:1px solid #505050;padding:10px;margin-bottom:10px;border-radius:4px;background-color:#424242;} .io-item label{margin-bottom:4px;font-size:0.9em;} .io-item input,.io-item select{width:calc(100% - 10px);} .hidden{display:none!important;}
        .batch-duration-field { margin-top: 10px; }
        .connection {
            transform-origin: 0 0;
            vector-effect: non-scaling-stroke;
        }
        .connection {
            vector-effect: non-scaling-stroke;
            stroke-width: 4.5px;
            fill: none;
            pointer-events: none;
        }
        .temp-connection {
            vector-effect: non-scaling-stroke;
            stroke: #ffdd57;
            stroke-width: 3px;
            stroke-dasharray: 5,5;
            fill: none;
        }
        #module-library { 
            width: 250px; 
            background-color: #3a3a3a; 
            border-right: 1px solid #555; 
            overflow-y: auto; 
            padding: 15px;
            padding-bottom: 80px;
            flex-shrink: 0;
            transition: width 0.3s ease, opacity 0.3s ease;
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            z-index: 1000;
        }
        #module-library.collapsed {
            width: 0 !important;
            padding: 0 !important;
            overflow: visible;
            border-right: none;
        }
        #module-library.collapsed > *:not(#module-library-toggle) {
            opacity: 0;
            pointer-events: none;
        }
        #module-library:not(.collapsed) > *:not(#module-library-toggle) {
            opacity: 1;
            pointer-events: auto;
        }
        #module-library-toggle {
            position: fixed !important;
            left: 0 !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            width: 30px !important;
            height: 60px !important;
            min-width: 30px !important;
            max-width: 30px !important;
            min-height: 60px !important;
            max-height: 60px !important;
            background-color: #3a3a3a !important;
            border: 1px solid #555 !important;
            border-right: none !important;
            border-radius: 0 4px 4px 0 !important;
            cursor: pointer;
            display: flex !important;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 18px;
            z-index: 10000 !important;
            transition: background-color 0.2s ease, left 0.3s ease, border-radius 0.3s ease;
            pointer-events: auto !important;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
            opacity: 1 !important;
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
            flex: none !important;
        }
        #module-library-toggle:hover {
            background-color: #4a4a4a;
        }
        #module-library:not(.collapsed) #module-library-toggle {
            left: 250px;
            border-radius: 4px 0 0 4px;
            border-right: none;
            border-left: 1px solid #555;
        }
        #module-library h3 { margin-top: 0; margin-bottom: 15px; color: #fff; }
        .module-category { margin-bottom: 20px; }
        .module-category h4 { color: #ddd; margin-bottom: 10px; font-size: 0.9em; text-transform: uppercase; }
        .module-button { 
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 8px;
            background-color: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s;
        }
        .module-button:hover { background-color: #555; }
        .module-button img { 
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
        }
        .connection.default-connection {
            stroke: #808080;
        }
        .temp-connection {
            stroke: #ffdd57;
            stroke-width: 3px;
            stroke-dasharray: 5,5;
            fill: none;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }
        .temp-connection-group {
            pointer-events: none;
        }
        .temp-connection {
            stroke: #ffdd57;
            stroke-width: 3px;
            stroke-dasharray: 5,5;
            fill: none;
            vector-effect: non-scaling-stroke;
        }
        .solar-array .port-text-label { fill: #d0d0d0; font-size: 11px; pointer-events: none; }
        .solar-array .port-text-label.input { text-anchor: start; }
        .solar-array .port-text-label.output { text-anchor: end; }
        .solar-array .power-bar-bg { fill: #303030; }
        .solar-array .power-bar-fill { 
            fill: #ffdd57; 
            transition: height 0.3s ease-out, y 0.3s ease-out;
            will-change: height, transform;
        }
    </style>
    <style>
        /* Stats Score Bar */
        #statsBar {
            background: linear-gradient(135deg, #1a2b3c 0%, #2a3b4c 100%);
            border-bottom: 3px solid #ffdd57;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 12px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
            gap: 10px;
            z-index: 1000;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        #statsBar::-webkit-scrollbar {
            height: 6px;
        }
        
        #statsBar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        
        #statsBar::-webkit-scrollbar-thumb {
            background: rgba(255, 221, 87, 0.5);
            border-radius: 3px;
        }
        
        #statsBar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 221, 87, 0.7);
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 120px;
            height: 90px;
            flex: 0 0 auto;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid rgba(255, 221, 87, 0.3);
            transition: all 0.3s ease;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .stat-item:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 221, 87, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 221, 87, 0.3);
        }
        
        .stat-item[style*="cursor: pointer"]:hover {
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 4px 12px rgba(100, 200, 255, 0.4);
        }
        
        .stat-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            font-weight: 600;
            white-space: nowrap;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
        }
        
        .stat-label.auto-scale {
            font-size: 11px;
        }
        
        .stat-unit {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
            font-weight: 600;
            white-space: nowrap;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
        }
        
        .stat-unit.auto-scale {
            font-size: 11px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #ffdd57;
            text-shadow: 0 0 10px rgba(255, 221, 87, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial', sans-serif;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            text-align: center;
            line-height: 1.2;
        }
        
        .stat-value.large {
            font-size: 24px;
        }
        
        .stat-value.auto-scale {
            font-size: 20px;
        }
        
        .stat-value.large.auto-scale {
            font-size: 24px;
        }
        
        .stat-resources {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }
        
        .resource-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #fff;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .resource-stat .resource-name {
            color: #aaa;
        }
        
        .resource-stat .resource-value {
            color: #ffdd57;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="statsBar">
        <div class="stat-item">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="liveTimeElapsed">0</div>
            <div class="stat-unit">hours</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Solar</div>
            <div class="stat-value large" id="liveSolarKwh">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Generated</div>
            <div class="stat-value large" id="liveKwhGenerated">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Consumed</div>
            <div class="stat-value large" id="liveKwhConsumed">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Net</div>
            <div class="stat-value large" id="liveNetKwh">0.00</div>
            <div class="stat-unit">kWh</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Solar</div>
            <div class="stat-value" id="liveEfficiency">0.00%</div>
            <div class="stat-unit">Utilization</div>
        </div>
        <div class="stat-item" title="Micro-Kardashev Scale: 0.1 = perfect capture, 0.02 = good, 0.015 = typical">
            <div class="stat-label">K<sub>micro</sub></div>
            <div class="stat-value" id="liveKMicro">0.00000</div>
            <div class="stat-unit">score</div>
        </div>
        <div class="stat-item" id="eco2SequesteredStat" style="cursor: pointer;" title="Double-click to edit factors">
            <div class="stat-label">CO‚ÇÇ Sequestered</div>
            <div class="stat-value large" id="liveEco2Sequestered">0.00</div>
            <div class="stat-unit">kg eCO‚ÇÇ</div>
        </div>
        <div class="stat-item" id="eco2AvoidedStat" style="cursor: pointer;" title="Double-click to edit factors">
            <div class="stat-label">CO‚ÇÇ Avoided</div>
            <div class="stat-value large" id="liveEco2Avoided">0.00</div>
            <div class="stat-unit">kg eCO‚ÇÇ</div>
        </div>
        <div class="stat-item" id="eco2TotalSavedStat" style="cursor: pointer;" title="Double-click to edit factors">
            <div class="stat-label">CO‚ÇÇ Saved</div>
            <div class="stat-value large" id="liveEco2TotalSaved">0.00</div>
            <div class="stat-unit">kg eCO‚ÇÇ</div>
        </div>
        <div id="resourceStatsContainer" style="display: flex; gap: 10px; flex-wrap: nowrap; align-items: center; flex: 0 0 auto;"></div>
    </div>
    <div id="challengeOverlay">
        <div class="challenge-content">
            <h1>TOTAL POWER FAILURE!</h1>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Time Elapsed</div>
                    <div class="stat-value" id="challengeTimeElapsed">0</div>
                    <div class="stat-unit">hours</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Solar Generated</div>
                    <div class="stat-value" id="challengeSolarKwh">0.00</div>
                    <div class="stat-unit">kWh</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Generated</div>
                    <div class="stat-value" id="challengeKwhGenerated">0.00</div>
                    <div class="stat-unit">kWh</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Consumed</div>
                    <div class="stat-value" id="challengeKwhConsumed">0.00</div>
                    <div class="stat-unit">kWh</div>
                </div>
                <div class="stat-card" id="challengeNetKwhCard">
                    <div class="stat-label">Net Power</div>
                    <div class="stat-value" id="challengeNetKwh">0.00</div>
                    <div class="stat-unit">kWh</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Solar Utilization</div>
                    <div class="stat-value" id="challengeKwhEfficiency">0.00</div>
                    <div class="stat-unit">%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">K<sub>micro</sub> Score</div>
                    <div class="stat-value" id="challengeKMicro">0.00000</div>
                    <div class="stat-unit">score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">CO‚ÇÇ Sequestered</div>
                    <div class="stat-value" id="challengeEco2Sequestered">0.00</div>
                    <div class="stat-unit">kg eCO‚ÇÇ</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">CO‚ÇÇ Avoided</div>
                    <div class="stat-value" id="challengeEco2Avoided">0.00</div>
                    <div class="stat-unit">kg eCO‚ÇÇ</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total CO‚ÇÇ Saved</div>
                    <div class="stat-value" id="challengeEco2TotalSaved">0.00</div>
                    <div class="stat-unit">kg eCO‚ÇÇ</div>
                </div>
            </div>
            <div class="resources-section">
                <h3>Resources</h3>
                <div class="resources-grid">
                    <div id="challengeResourceDetails"></div>
                </div>
            </div>
            <button id="challengeRestart">Restart Challenge</button>
        </div>
    </div>
    <div id="main-content">
        <div id="canvas-container" style="background-color: rgb(26, 43, 60);">
            <svg id="simulationCanvas" style="touch-action: none; background-color: rgb(26, 43, 60);"></svg>
        </div>
        <div id="module-library" class="collapsed">
            <button id="module-library-toggle" title="Toggle Module Library">‚ñ∂</button>
            <h3>Module Library</h3>
            <div class="module-category">
                <h4>Power Generation</h4>
                <button class="module-button" id="addSolarArray">Solar Array</button>
                <button class="module-button" id="addWindTurbines">Wind Turbines</button>
            </div>
            <div class="module-category">
                <h4>Storage</h4>
                <button class="module-button" id="addBatteryBank">Battery Bank</button>
            </div>
            <div class="module-category">
                <h4>Resources</h4>
                <button class="module-button" id="addPlasticTrash">Plastic Trash</button>
                <button class="module-button" id="addPlasticFlakes">Plastic Flakes</button>
                <button class="module-button" id="addBiomass">Biomass</button>
                <button class="module-button" id="addPoopGas">Woodgas</button>
                <button class="module-button" id="addBiochar">Biochar</button>
            </div>
            <div class="module-category">
                <h4>Processors</h4>
                <button class="module-button" id="addShredder">Shredder</button>
                <button class="module-button" id="addTrashPrinter">Trash Printer</button>
                <button class="module-button" id="addBiocharReactor">Biochar Reactor</button>
            </div>
            <div class="module-category">
                <h4>Kitchen Appliances</h4>
                <button class="module-button" id="addMicrowave">Microwave (1.2 kW)</button>
                <button class="module-button" id="addElectricKettle">Electric Kettle (1.5 kW)</button>
                <button class="module-button" id="addToaster">Toaster (0.9 kW)</button>
                <button class="module-button" id="addCoffeeMaker">Coffee Maker (0.8 kW)</button>
                <button class="module-button" id="addRefrigerator">Refrigerator (0.15 kW)</button>
                <button class="module-button" id="addFreezer">Freezer (0.1 kW)</button>
                <button class="module-button" id="addDishwasher">Dishwasher (1.8 kW)</button>
                <button class="module-button" id="addElectricStove">Electric Stove (2.5 kW)</button>
                <button class="module-button" id="addBlender">Blender (0.4 kW)</button>
                <button class="module-button" id="addRiceCooker">Rice Cooker (0.5 kW)</button>
            </div>
            <div class="module-category">
                <h4>Laundry &amp; Cleaning</h4>
                <button class="module-button" id="addWashingMachine">Washing Machine (0.5 kW)</button>
                <button class="module-button" id="addClothesDryer">Clothes Dryer (3.0 kW)</button>
                <button class="module-button" id="addVacuumCleaner">Vacuum Cleaner (1.4 kW)</button>
                <button class="module-button" id="addIron">Iron (1.2 kW)</button>
            </div>
            <div class="module-category">
                <h4>Climate Control</h4>
                <button class="module-button" id="addAirConditioner">Air Conditioner (1.5 kW)</button>
                <button class="module-button" id="addSpaceHeater">Space Heater (1.5 kW)</button>
                <button class="module-button" id="addCeilingFan">Ceiling Fan (0.075 kW)</button>
                <button class="module-button" id="addPortableFan">Portable Fan (0.05 kW)</button>
                <button class="module-button" id="addDehumidifier">Dehumidifier (0.3 kW)</button>
                <button class="module-button" id="addHumidifier">Humidifier (0.04 kW)</button>
            </div>
            <div class="module-category">
                <h4>Water Heating</h4>
                <button class="module-button" id="addWaterHeater">Water Heater (4.5 kW)</button>
                <button class="module-button" id="addInstantWaterHeater">Instant Water Heater (3.0 kW)</button>
                <button class="module-button" id="addWaterPump">Water Pump (0.75 kW)</button>
            </div>
            <div class="module-category">
                <h4>Lighting</h4>
                <button class="module-button" id="addLEDLights">LED Lights (0.01 kW)</button>
                <button class="module-button" id="addCFLBulb">CFL Bulb (0.02 kW)</button>
                <button class="module-button" id="addIncandescentBulb">Incandescent (0.06 kW)</button>
                <button class="module-button" id="addFloodlight">Outdoor Floodlight (0.15 kW)</button>
            </div>
            <div class="module-category">
                <h4>Electronics &amp; Office</h4>
                <button class="module-button" id="addPhoneCharger">Phone Charger (0.02 kW)</button>
                <button class="module-button" id="addLaptop">Laptop (0.065 kW)</button>
                <button class="module-button" id="addDesktopPC">Desktop PC (0.3 kW)</button>
                <button class="module-button" id="addGamingPC">Gaming PC (0.5 kW)</button>
                <button class="module-button" id="addMonitor">Monitor (0.03 kW)</button>
                <button class="module-button" id="addTV">Television (0.1 kW)</button>
                <button class="module-button" id="addGameConsole">Game Console (0.15 kW)</button>
                <button class="module-button" id="addWiFiRouter">WiFi Router (0.01 kW)</button>
                <button class="module-button" id="addPrinter">Printer (0.05 kW)</button>
            </div>
            <div class="module-category">
                <h4>Personal Care</h4>
                <button class="module-button" id="addHairDryer">Hair Dryer (1.8 kW)</button>
                <button class="module-button" id="addElectricShaver">Electric Shaver (0.015 kW)</button>
                <button class="module-button" id="addCurlingIron">Curling Iron (0.1 kW)</button>
            </div>
            <div class="module-category">
                <h4>Power Tools</h4>
                <button class="module-button" id="addDrill">Electric Drill (0.8 kW)</button>
                <button class="module-button" id="addCircularSaw">Circular Saw (1.4 kW)</button>
                <button class="module-button" id="addAngleGrinder">Angle Grinder (1.0 kW)</button>
                <button class="module-button" id="addAirCompressor">Air Compressor (1.5 kW)</button>
            </div>
            <div class="module-category">
                <h4>EV &amp; Transport</h4>
                <button class="module-button" id="addEVChargerL1">EV Charger L1 (1.4 kW)</button>
                <button class="module-button" id="addEVChargerL2">EV Charger L2 (7.2 kW)</button>
                <button class="module-button" id="addEBikeCharger">E-Bike Charger (0.3 kW)</button>
            </div>
            <div class="module-category">
                <h4>Custom</h4>
                <button class="module-button" id="openCustomBuilder" style="background-color: #4a6a4a;">Create Custom Module</button>
            </div>
        </div>
    </div>
    <div id="sidebar" class="collapsed">
        <button id="sidebar-toggle" title="Toggle Component Editor">‚óÄ</button>
        <div id="nodeBuilderSection" class="hidden">
            <h3>Custom Node Builder</h3>
            <div><label>Node Name: <input type="text" id="customNodeName" placeholder="e.g., My Assembler"></label></div>
            <div><label>Image URL: <input type="text" id="customNodeImageURL" placeholder="https://.../icon.png"></label></div>
            <div class="batch-duration-field"><label>Batch Duration (hrs, if batch proc.): <input type="number" id="customBatchDuration" value="6" min="1"></label></div>
            <h4 class="sidebar-section">Inputs <button id="addCustomInput">+</button></h4>
            <div id="customInputsContainer"><div class="io-item" id="custom-io-26"><label>Port Name: <input type="text" name="io_name" placeholder="e.g., Raw Material"></label><label>Resource Type: <select name="io_resource"><option value="Plastic">Plastic</option><option value="Plastic Flakes">Plastic Flakes</option><option value="Power">Power</option><option value="Wind Turbines">Wind Turbines</option><option value="Biomass">Biomass</option><option value="Woodgas">Woodgas</option><option value="Biochar">Biochar</option><option value="Custom Product A">Custom Product A</option><option value="Custom Product B">Custom Product B</option></select></label><label>Rate (per hour/batch): <input type="number" name="io_rate" value="1" step="0.001" min="0"></label><label><input type="checkbox" name="io_is_batch"> Batch I/O</label><button onclick="this.parentElement.remove()" style="width:auto;float:right;background-color:#c55;">X</button></div></div>
            <h4 class="sidebar-section">Outputs <button id="addCustomOutput">+</button></h4>
            <div id="customOutputsContainer"><div class="io-item" id="custom-io-29"><label>Port Name: <input type="text" name="io_name" placeholder="e.g., Raw Material"></label><label>Resource Type: <select name="io_resource"><option value="Plastic">Plastic</option><option value="Plastic Flakes">Plastic Flakes</option><option value="Power">Power</option><option value="Wind Turbines">Wind Turbines</option><option value="Biomass">Biomass</option><option value="Woodgas">Woodgas</option><option value="Biochar">Biochar</option><option value="Custom Product A">Custom Product A</option><option value="Custom Product B">Custom Product B</option></select></label><label>Rate (per hour/batch): <input type="number" name="io_rate" value="1" step="0.001" min="0"></label><label><input type="checkbox" name="io_is_batch"> Batch I/O</label><button onclick="this.parentElement.remove()" style="width:auto;float:right;background-color:#c55;">X</button></div></div>
            <button id="createCustomNodeInstance">Create Instance</button>
        
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button id="saveCustomModule" style="flex: 1;">Save Module Template</button>
                <button id="loadCustomModule" style="flex: 1;">Load Module Template</button>
            </div>
        </div>
        <div id="nodeInspectorSection" class="hidden">
            <h3>Edit Node Properties</h3>
            <div><label>Node Name: <input type="text" id="inspectorNodeName"></label></div>
            <div><label>Image URL: <input type="text" id="inspectorNodeImageURL" placeholder="https://.../icon.png"></label></div>
            <div><label>Port Orientation: <select id="inspectorPortOrientation"><option value="vertical">Top/Bottom (Vertical)</option><option value="horizontal">Left/Right (Horizontal)</option></select></label></div>
            <div><button id="inspectorFlipButton" style="width: 100%; margin-top: 5px; padding: 8px 12px; background-color: #555; color: #fff; border: 1px solid #777; border-radius: 4px; cursor: pointer;">‚Üî Flip Ports</button></div>
            <div id="inspectorBatchDurationField" class="batch-duration-field hidden"><label>Batch Duration (hrs): <input type="number" id="inspectorBatchDuration" min="1"></label></div>
            
            <!-- Recipe-Based Batch Processor UI -->
            <div id="inspectorRecipeFields" class="hidden" style="margin-top: 10px;">
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid #0f3460; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0; color: #e94560; font-size: 13px;">üìã Recipes</h4>
                        <button id="inspectorAddRecipe" style="font-size: 10px; padding: 4px 8px; background: #0f3460; border: 1px solid #e94560; color: #e94560; border-radius: 4px; cursor: pointer;">+ New</button>
                    </div>
                    <div id="inspectorRecipeList" style="max-height: 250px; overflow-y: auto;"></div>
                </div>
                
                <div style="background: linear-gradient(135deg, #1a2a1a 0%, #0d1f0d 100%); border: 1px solid #2d5a2d; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <h4 style="margin: 0; color: #4ade80; font-size: 13px;">‚è∞ Schedule</h4>
                        <button id="inspectorAddRecipeAutomation" style="font-size: 10px; padding: 4px 8px; background: #0d1f0d; border: 1px solid #4ade80; color: #4ade80; border-radius: 4px; cursor: pointer;">+ Rule</button>
                    </div>
                    <div id="inspectorRecipeAutomationContainer" style="max-height: 150px; overflow-y: auto;"></div>
                </div>
                
                <div id="inspectorPowerSettings" style="background: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 12px;">
                    <h4 style="margin: 0 0 8px 0; color: #fbbf24; font-size: 13px;">‚ö° Power Input</h4>
                    <label style="font-size: 11px;">Continuous Power (kW): <input type="number" id="inspectorContinuousPower" step="0.1" min="0" value="1.0" style="width: 70px;"></label>
                </div>
            </div>
            
            <!-- Traditional Processor Fields (for non-batch processors) -->
            <div id="inspectorProcessorFields" class="hidden">
                <h4 class="sidebar-section">Inputs <button id="inspectorAddInput">+</button></h4>
                <div id="inspectorInputsContainer"></div>
                <h4 class="sidebar-section">Outputs <button id="inspectorAddOutput">+</button></h4>
                <div id="inspectorOutputsContainer"></div>
            </div>
            <div id="inspectorSolarArrayFields" class="hidden">
                <div><label>Rated Output (kW): <input type="number" id="inspectorRatedOutput" step="0.1" value="5"></label></div>
                <div><span>Current Output: </span><span id="inspectorCurrentOutput">2.40 kW</span></div>
            </div>
            <div id="inspectorResourceDisplayFields" class="hidden">
                <div><label>Unit: <input type="text" id="inspectorNodeUnit" placeholder="e.g., kg, kWh"></label></div>
                <div><label>Passive Rate (/hr): <input type="number" id="inspectorPassiveRate" step="0.1" placeholder="e.g., 5 or -2"></label></div>
                <div><label>Max Capacity (optional): <input type="number" id="inspectorMaxCapacity" step="1" placeholder="e.g., 100"></label></div>
                <div><label>Progress Bar Color: <input type="color" id="inspectorProgressColor" value="#6fa06c"></label></div>
                <div><label><input type="checkbox" id="inspectorIsExternal"> Is External Source (can go negative)</label></div>
            </div>
            <div id="inspectorAutomationFields" style="margin-top: 20px; border-top: 1px solid #555; padding-top: 15px;">
                <h4 class="sidebar-section">Automation Rules <button id="inspectorAddAutomation">+</button></h4>
                <div id="inspectorAutomationContainer"></div>
            </div>
            <button id="saveNodeChanges" style="opacity: 0.7;">Auto-Save Enabled</button>
            <button id="cancelNodeChanges" style="background-color:#5a5a5a;">Done / Deselect</button>
        </div>
        <div id="eco2FactorsSection" class="hidden">
            <h3>eCO‚ÇÇ Calculation Factors</h3>
            <div><label>Biochar Capture Factor (kg eCO‚ÇÇ per kg Biochar): <input type="number" id="eco2BiocharFactor" value="1.8" step="0.1" min="0"></label></div>
            <div><label>Woodgas Avoidance Factor (kg eCO‚ÇÇ per m¬≥ woodgas): <input type="number" id="eco2WoodgasFactor" value="1.2" step="0.1" min="0"></label></div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; font-size: 0.9em; color: #aaa;">
                <strong>Current Calculations:</strong><br>
                Biochar Sequestered: <span id="eco2BiocharCalc">0.00</span> kg eCO‚ÇÇ<br>
                Woodgas Avoided: <span id="eco2WoodgasCalc">0.00</span> kg eCO‚ÇÇ<br>
                Total Saved: <span id="eco2TotalCalc">0.00</span> kg eCO‚ÇÇ
            </div>
            <button id="saveEco2Factors" style="margin-top: 15px;">Save Factors</button>
            <button id="cancelEco2Factors" style="background-color:#5a5a5a;">Close</button>
        </div>
    </div>
    </div>
    <div class="toolbar"> 
        <div class="toolbar-left">
            <div class="time-display">1205 total hours (Day 51, 05:00)</div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="weatherDifficulty">Weather:</label>
                <select id="weatherDifficulty">
                    <option value="clear" selected>Clear Sky (100%)</option>
                    <option value="easy">Easy (80-100%)</option>
                    <option value="medium">Medium (50-80%)</option>
                    <option value="hard">Hard (20-60%)</option>
                </select>
            </div>
        </div>
        <div class="toolbar-center">
            <div class="play-controls"> 
                <button id="playPauseButton">‚ùö‚ùö</button> 
                <input type="range" id="speedSlider" min="100" max="10000" value="1000"> 
                <span class="speed-label">1.0x</span> 
            </div>
        </div>
        <div class="toolbar-right">
            <button id="backToBuilder" style="background: rgba(91, 192, 222, 0.3); border-color: #5bc0de;">‚Üê Edit Design</button>
            <button id="saveSystem">Save System</button>
            <button id="loadSystem">Load System</button>
            <button id="resetTime">Reset Time</button>
            <button id="resetValues">Reset Values</button>
            <button id="challengeMode">Challenge Mode</button>
            <div class="zoom-controls" style="display: flex; gap: 5px;">
                <button id="zoomIn" style="padding: 5px 10px;">+</button>
                <button id="zoomOut" style="padding: 5px 10px;">-</button>
                <button id="resetZoom" style="padding: 5px 10px;">Reset</button>
            </div>
        </div>
    </div>

    <script>
        // ... (Initial consts, global vars same as before) ...
        const svg = d3.select("#simulationCanvas");
        let svgWidth, svgHeight;
        let currentZoom = d3.zoomIdentity;
        let isPanning = false;
        let lastPanPoint = null;

        const updateSvgDimensions = () => { 
            svgWidth = svg.node().getBoundingClientRect().width; 
            svgHeight = svg.node().getBoundingClientRect().height; 
        };

        // Fix zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                currentZoom = event.transform;
                getZoomGroup().attr("transform", `translate(${event.transform.x},${event.transform.y}) scale(${event.transform.k})`);
                // Phase 2: Invalidate viewport cache on zoom/pan
                selectionCache.zoomGroup = null;
                // Phase 3: Invalidate position and path caches on zoom/pan
                portPositionCache.clear();
                connectionPathCache.clear();
            })
            .filter(event => {
                // Allow zoom on mouse wheel and touch gestures
                return event.type === 'wheel' || event.type === 'touchstart' || event.type === 'touchmove';
            });

        // Add defs section for filters
        const defs = svg.append("defs");
        
        // Wattage drop shadow filter
        const dropShadowFilter = defs.append("filter")
            .attr("id", "wattage-drop-shadow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%");
        dropShadowFilter.append("feGaussianBlur")
            .attr("in", "SourceAlpha")
            .attr("stdDeviation", "2");
        dropShadowFilter.append("feOffset")
            .attr("dx", "2")
            .attr("dy", "2")
            .attr("result", "offsetblur");
        const feMerge = dropShadowFilter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "offsetblur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Dynamic node shadow filter (angle changes with time of day)
        const nodeShadowFilter = defs.append("filter")
            .attr("id", "node-dynamic-shadow")
            .attr("x", "-100%")
            .attr("y", "-100%")
            .attr("width", "300%")
            .attr("height", "300%");
        
        // Create shadow components in correct order
        // First: blur the alpha channel
        const shadowBlur = nodeShadowFilter.append("feGaussianBlur")
            .attr("in", "SourceAlpha")
            .attr("stdDeviation", "4")
            .attr("result", "shadowBlur");
        
        // Second: offset the blurred shadow (with smooth transitions)
        const shadowOffset = nodeShadowFilter.append("feOffset")
            .attr("in", "shadowBlur")
            .attr("dx", "0")
            .attr("dy", "8")
            .attr("result", "offsetShadow")
            .style("transition", "dx 0.5s ease, dy 0.5s ease");
        
        // Third: color the shadow (with smooth opacity transitions)
        const shadowFlood = nodeShadowFilter.append("feFlood")
            .attr("flood-color", "rgba(0,0,0,0.7)")
            .attr("flood-opacity", "0.7")
            .attr("result", "shadowColor")
            .style("transition", "flood-opacity 1s ease");
        
        // Fourth: composite color with offset shadow
        const shadowComposite = nodeShadowFilter.append("feComposite")
            .attr("in", "shadowColor")
            .attr("in2", "offsetShadow")
            .attr("operator", "in")
            .attr("result", "shadow");
        
        // Fifth: merge shadow with original graphic
        const shadowMerge = nodeShadowFilter.append("feMerge");
        shadowMerge.append("feMergeNode").attr("in", "shadow");
        shadowMerge.append("feMergeNode").attr("in", "SourceGraphic");
        
        // Function to update shadow angle based on time of day
        function updateShadowAngle(hourOfDay) {
            // Shadow angle calculation:
            // - Morning (5-12): shadow to the RIGHT (positive dx) - sun in east
            // - Midday (12): shadow straight down (dx = 0) - sun overhead
            // - Evening (12-19): shadow to the LEFT (negative dx) - sun in west
            // - Night (19-5): no shadow (faded out)
            
            let dx = 0;
            let dy = 0;
            let shadowOpacity = 0;
            
            // Define sunrise and sunset times with fade zones (using integer hours)
            const sunriseStart = 5;  // 5:00 AM - start fading in
            const sunriseEnd = 6;     // 6:00 AM - fully visible
            const sunsetStart = 18;   // 6:00 PM - start fading out
            const sunsetEnd = 19;     // 7:00 PM - fully faded
            
            if (hourOfDay >= sunriseEnd && hourOfDay < sunsetStart) {
                // Full day: shadows fully visible
                shadowOpacity = 0.7;
                
                // Normalize hour to 0-1 range (6 AM = 0, 6 PM = 1)
                const normalizedHour = (hourOfDay - sunriseEnd) / (sunsetStart - sunriseEnd);
                // Convert to angle: 0 = +90¬∞ (morning, shadow right), 0.5 = 0¬∞ (noon, shadow down), 1 = -90¬∞ (evening, shadow left)
                const angle = (0.5 - normalizedHour) * Math.PI; // +œÄ/2 to -œÄ/2
                
                // Calculate shadow length: longer in morning/evening, shorter at noon
                // Distance from noon (0.5): 0 = noon (short), 0.5 = morning/evening (long)
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                // Shadow length: 8px at noon, up to 24px at morning/evening
                const shadowLength = 8 + (distanceFromNoon * 32); // 8 to 24px
                
                // Calculate dx and dy from angle
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else if (hourOfDay >= sunriseStart && hourOfDay < sunriseEnd) {
                // Sunrise fade-in: gradually increase opacity from 0 to 0.7 over 1 hour
                const fadeProgress = (hourOfDay - sunriseStart) / (sunriseEnd - sunriseStart);
                shadowOpacity = 0.7 * fadeProgress;
                
                // Calculate shadow properties for early morning (normalized to start of day)
                const normalizedHour = (hourOfDay - sunriseStart) / (sunsetStart - sunriseStart);
                const angle = (0.5 - normalizedHour) * Math.PI;
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const shadowLength = 8 + (distanceFromNoon * 32);
                
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else if (hourOfDay >= sunsetStart && hourOfDay < sunsetEnd) {
                // Sunset fade-out: gradually decrease opacity from 0.7 to 0 over 1 hour
                const fadeProgress = (sunsetEnd - hourOfDay) / (sunsetEnd - sunsetStart);
                shadowOpacity = 0.7 * fadeProgress;
                
                // Calculate shadow properties for late evening
                const normalizedHour = (hourOfDay - sunriseStart) / (sunsetStart - sunriseStart);
                const angle = (0.5 - normalizedHour) * Math.PI;
                const distanceFromNoon = Math.abs(normalizedHour - 0.5);
                const shadowLength = 8 + (distanceFromNoon * 32);
                
                dx = Math.sin(angle) * shadowLength;
                dy = Math.abs(Math.cos(angle)) * shadowLength;
                
            } else {
                // Night time: no shadow (dx = 0, dy = 0, opacity = 0)
                dx = 0;
                dy = 0;
                shadowOpacity = 0;
            }
            
            // Update the filter with smooth D3 transitions
            shadowOffset.transition()
                .duration(1000) // 1 second transition
                .ease(d3.easeCubicInOut)
                .attr("dx", dx)
                .attr("dy", dy);
            
            shadowFlood.transition()
                .duration(1500) // 1.5 second transition for opacity (smoother fade)
                .ease(d3.easeCubicInOut)
                .attr("flood-opacity", shadowOpacity);
        }

        // Create a group for all content that should be zoomed
        const zoomGroup = svg.append("g")
            .attr("class", "zoom-group");

        // Apply zoom behavior to SVG
        svg.call(zoom);

        // Add CSS to prevent default touch behavior
        svg.style("touch-action", "none");

        // Handle touch events for two-finger pan
        let lastTouchDistance = null;
        let lastTouchCenter = null;

        svg.on("touchstart", (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                // Calculate initial touch distance and center
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                lastTouchCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
        });

        svg.on("touchmove", (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                // Calculate current touch distance and center
                const currentTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const currentTouchCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };

                if (lastTouchDistance && lastTouchCenter) {
                    // Calculate zoom factor based on touch distance change
                    const scale = currentTouchDistance / lastTouchDistance;
                    
                    // Calculate pan offset
                    const dx = currentTouchCenter.x - lastTouchCenter.x;
                    const dy = currentTouchCenter.y - lastTouchCenter.y;
                    
                    // Apply zoom and pan
                    const newScale = currentZoom.k * scale;
                    if (newScale >= 0.1 && newScale <= 4) {
                        currentZoom = currentZoom
                            .translate(dx / currentZoom.k, dy / currentZoom.k)
                            .scale(newScale);
                        svg.call(zoom.transform, currentZoom);
                    }
                }
                
                // Update last touch values
                lastTouchDistance = currentTouchDistance;
                lastTouchCenter = currentTouchCenter;
            }
        });

        svg.on("touchend", () => {
            lastTouchDistance = null;
            lastTouchCenter = null;
        });

        // Remove right-click pan behavior
        svg.on("contextmenu", (event) => {
            event.preventDefault();
        });

        // Add left-click pan behavior
        svg.on("mousedown", (event) => {
            if (event.button === 0) { // Left mouse button
                isPanning = true;
                lastPanPoint = d3.pointer(event);
            }
        });

        svg.on("mousemove", (event) => {
            if (isPanning && lastPanPoint) {
                const currentPoint = d3.pointer(event);
                const dx = currentPoint[0] - lastPanPoint[0];
                const dy = currentPoint[1] - lastPanPoint[1];
                
                currentZoom = currentZoom.translate(dx / currentZoom.k, dy / currentZoom.k);
                svg.call(zoom.transform, currentZoom);
                
                lastPanPoint = currentPoint;
            }
        });

        svg.on("mouseup", (event) => {
            if (event.button === 0) { // Left mouse button
                isPanning = false;
                lastPanPoint = null;
            }
        });

        svg.on("mouseleave", () => {
            isPanning = false;
            lastPanPoint = null;
        });

        // Add coordinate transformation utilities
        function screenToWorld(x, y) {
            return {
                x: (x - currentZoom.x) / currentZoom.k,
                y: (y - currentZoom.y) / currentZoom.k
            };
        }

        function worldToScreen(x, y) {
            return {
                x: x * currentZoom.k + currentZoom.x,
                y: y * currentZoom.k + currentZoom.y
            };
        }

        // Modified getAbsPortPosition function to work with zoom
        // Helper function to convert old port format to new format
        function convertPortToNewFormat(port, node) {
            const orientation = node.portOrientation || 'vertical';
            const isFlipped = node.flipped || false;
            
            // Create a new port object to avoid mutation issues
            const newPort = {...port};
            
            // If port already has correct format (has xOffsetRatio and side is top/bottom for vertical), return as is
            if (orientation === 'vertical') {
                if (newPort.side === 'top' || newPort.side === 'bottom') {
                    // Already in new format, just ensure xOffsetRatio exists
                    if (!newPort.xOffsetRatio) {
                        newPort.xOffsetRatio = newPort.yOffsetRatio || 0.5;
                    }
                    return newPort;
                }
                // Convert from old left/right format
                if (newPort.side === 'left' || newPort.side === 'right') {
                    newPort.xOffsetRatio = newPort.yOffsetRatio || 0.5;
                    newPort.yOffsetRatio = 0.5;
                    if (newPort.type === 'input') {
                        newPort.side = isFlipped ? 'bottom' : 'top';
                    } else {
                        newPort.side = isFlipped ? 'top' : 'bottom';
                    }
                    return newPort;
                }
            } else {
                if (newPort.side === 'left' || newPort.side === 'right') {
                    // Already in new format, just ensure yOffsetRatio exists
                    if (!newPort.yOffsetRatio) {
                        newPort.yOffsetRatio = newPort.xOffsetRatio || 0.5;
                    }
                    return newPort;
                }
                // Convert from old top/bottom format
                if (newPort.side === 'top' || newPort.side === 'bottom') {
                    newPort.yOffsetRatio = newPort.xOffsetRatio || 0.5;
                    newPort.xOffsetRatio = 0.5;
                    if (newPort.type === 'input') {
                        newPort.side = isFlipped ? 'right' : 'left';
                    } else {
                        newPort.side = isFlipped ? 'left' : 'right';
                    }
                    return newPort;
                }
            }
            return newPort;
        }

        function getAbsPortPosition(node, port) {
            // Phase 3: Memoize port positions
            const cacheKey = `${node.id}-${port.id}-${getZoomKey()}-${node.x.toFixed(1)}-${node.y.toFixed(1)}`;
            
            if (portPositionCache.has(cacheKey)) {
                return portPositionCache.get(cacheKey);
            }
            
            // Calculate position in world coordinates
            const orientation = node.portOrientation || 'vertical';
            let worldX = node.x;
            let worldY = node.y;
            
            if (orientation === 'vertical') {
                // Top/bottom orientation: use xOffsetRatio for X, side for Y
                worldX += node.width * (port.xOffsetRatio || 0.5);
                if (port.side === 'top') {
                    worldY += 0;
                } else if (port.side === 'bottom') {
                    worldY += node.height;
                } else {
                    // Fallback for backwards compatibility
                    worldY += node.height * (port.yOffsetRatio || 0.5);
                }
            } else {
                // Left/right orientation: use yOffsetRatio for Y, side for X
                worldY += node.height * (port.yOffsetRatio || 0.5);
                if (port.side === 'left') {
                    worldX += 0;
                } else if (port.side === 'right') {
                    worldX += node.width;
                } else {
                    // Fallback for backwards compatibility
                    worldX += node.width * (port.xOffsetRatio || 0.5);
                }
            }
            
            // Convert to screen coordinates
            const position = worldToScreen(worldX, worldY);
            portPositionCache.set(cacheKey, position);
            return position;
        }

        // Modified drag behavior to work with zoom
        function dragStarted(e, d) {
            if (e.button !== 0) return; // Only handle left-click drag
            d3.select(this).raise().classed("active", true);
            const worldPos = screenToWorld(e.x, e.y);
            dragOffsetX = worldPos.x - d.x;
            dragOffsetY = worldPos.y - d.y;
        }

        function dragged(e, d) {
            if (e.button !== 0) return; // Only handle left-click drag
            const worldPos = screenToWorld(e.x, e.y);
            d.x = worldPos.x - dragOffsetX;
            d.y = worldPos.y - dragOffsetY;
            // Phase 1: Update transform immediately for smooth dragging, batch full render
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            // Phase 2: Invalidate cache for moved node
            invalidateNodeCache(d.id);
            scheduleRender(); // Batched render instead of immediate
        }

        // Add these utility functions at the top level
        function getMousePosition(event) {
            const transform = d3.zoomTransform(svg.node());
            let x, y;
            
            if (event.type.startsWith('touch')) {
                const touch = event.touches ? event.touches[0] : event;
                const rect = svg.node().getBoundingClientRect();
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                [x, y] = d3.pointer(event, svg.node());
            }
            
            return {
                x: (x - transform.x) / transform.k,
                y: (y - transform.y) / transform.k
            };
        }

        function createBezierPath(start, end, startSide, endSide, startOrientation = 'vertical', endOrientation = 'vertical') {
            const horizontalSpread = Math.abs(end.x - start.x);
            const verticalSpread = Math.abs(end.y - start.y);
            const totalDistance = Math.sqrt(horizontalSpread * horizontalSpread + verticalSpread * verticalSpread);
            
            // Shorter vertical segments with adaptive offset
            // For very short connections (< 150px), use minimal offset (15px)
            // For long connections (> 400px), use moderate offset (35px)
            // Scale proportionally in between
            const maxVerticalOffset = 35;  // Reduced from 80px for shorter, less rigid segments
            const minVerticalOffset = 15;
            const shortDistanceThreshold = 150;
            const longDistanceThreshold = 400;
            
            let verticalOffset;
            if (totalDistance < shortDistanceThreshold) {
                verticalOffset = minVerticalOffset;
            } else if (totalDistance > longDistanceThreshold) {
                verticalOffset = maxVerticalOffset;
            } else {
                // Linear interpolation between min and max
                const ratio = (totalDistance - shortDistanceThreshold) / (longDistanceThreshold - shortDistanceThreshold);
                verticalOffset = minVerticalOffset + (maxVerticalOffset - minVerticalOffset) * ratio;
            }
            
            const path = d3.path();
            path.moveTo(start.x, start.y);
            
            if (startOrientation === 'vertical' && endOrientation === 'vertical') {
                // Both vertical: smooth flowing curve that naturally starts and ends vertically
                // Use control points positioned to create smooth S-curve: vertical -> horizontal -> vertical
                
                // Control points positioned to create natural vertical-to-horizontal-to-vertical flow
                // For bezier curves: cp1 controls direction leaving start, cp2 controls direction approaching end
                
                // For vertical start: cp1 should be directly above/below start (same x) to create vertical tangent
                // For vertical end: cp2 should be directly above/below end (same x) to create vertical tangent
                // But we need horizontal flow in the middle, so we'll use a different approach
                
                const startVerticalDir = startSide === 'top' ? -1 : 1;
                const endVerticalDir = endSide === 'top' ? -1 : 1;
                
                // Control point 1: Start with same X as start point (pure vertical start), but extend further vertically
                const cp1x = start.x; // Same x = vertical start direction
                const cp1y = start.y + (verticalOffset * 1.2 * startVerticalDir); // Extend vertically
                
                // Control point 2: End with same X as end point (pure vertical end), but extend further vertically
                const cp2x = end.x; // Same x = vertical end direction
                const cp2y = end.y + (verticalOffset * 1.2 * endVerticalDir); // Extend vertically
                
                // The curve will naturally flow horizontally between these vertical control points
                
                // Single smooth bezier curve from start to end
                path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, end.x, end.y);
            } else if (startOrientation === 'vertical') {
                // Vertical start, horizontal end
                const startVerticalDir = startSide === 'top' ? -1 : 1;
                const startVerticalPoint = {
                    x: start.x,
                    y: start.y + (verticalOffset * startVerticalDir)
                };
                path.lineTo(startVerticalPoint.x, startVerticalPoint.y);
                
                // Curve to horizontal end
                const horizontalOffset = endSide === 'right' ? 80 : -80;
                const endHorizontalPoint = {
                    x: end.x + horizontalOffset,
                    y: end.y
                };
                
                path.bezierCurveTo(
                    startVerticalPoint.x, (startVerticalPoint.y + endHorizontalPoint.y) / 2,
                    endHorizontalPoint.x, endHorizontalPoint.y,
                    endHorizontalPoint.x, endHorizontalPoint.y
                );
                
                path.lineTo(end.x, end.y);
            } else if (endOrientation === 'vertical') {
                // Horizontal start, vertical end
                const horizontalOffset = startSide === 'right' ? 80 : -80;
                const startHorizontalPoint = {
                    x: start.x + horizontalOffset,
                    y: start.y
                };
                path.lineTo(startHorizontalPoint.x, startHorizontalPoint.y);
                
                // Curve to vertical end
                const endVerticalDir = endSide === 'top' ? -1 : 1;
                const endVerticalPoint = {
                    x: end.x,
                    y: end.y + (verticalOffset * endVerticalDir)
                };
                
                path.bezierCurveTo(
                    startHorizontalPoint.x, (startHorizontalPoint.y + endVerticalPoint.y) / 2,
                    endVerticalPoint.x, endVerticalPoint.y,
                    endVerticalPoint.x, endVerticalPoint.y
                );
                
                path.lineTo(end.x, end.y);
            } else {
                // Both horizontal: use original bezier logic
                const baseOffset = 50;
                const horizontalOffset1 = startSide === 'right' ? baseOffset : -baseOffset;
                const horizontalOffset2 = endSide === 'left' ? -baseOffset : baseOffset;
                const verticalDirection = end.y > start.y ? 1 : -1;
                const verticalOffset = Math.min(verticalSpread * 0.5, 100) * verticalDirection;
                
                path.bezierCurveTo(
                    start.x + horizontalOffset1,
                    start.y + verticalOffset,
                    end.x + horizontalOffset2,
                    end.y + verticalOffset,
                    end.x,
                    end.y
                );
            }
            
            return path.toString();
        }

        // Replace the startConnection function with this new implementation
        function startConnection(event, nodeId, portId) {
            // Handle both mouse and touch events
            if (event.type === 'mousedown' && event.button !== 0) return; // Only handle left-click for mouse
            event.preventDefault(); // Prevent default for both mouse and touch
            event.stopPropagation();
            
            const sourceNode = findNodeById(nodeId);
            const sourcePort = sourceNode.ports.find(p => p.id === portId);
            if (sourcePort.type === 'input') return;
            
            tempConnectionData = {
                sourceNodeId: nodeId,
                sourcePortId: portId,
                sourcePort: sourcePort
            };

            // Create temporary connection group
            const tempConnectionGroup = zoomGroup.append("g")
                .attr("class", "temp-connection-group");

            // Add the path element
            const tempConnection = tempConnectionGroup.append("path")
                .attr("class", "temp-connection")
                .style("vector-effect", "non-scaling-stroke");

            function updateConnection(event) {
                // Get coordinates based on event type
                let mousePos;
                if (event.type.startsWith('touch')) {
                    const touch = event.touches[0];
                    const rect = svg.node().getBoundingClientRect();
                    mousePos = {
                        x: (touch.clientX - rect.left - currentZoom.x) / currentZoom.k,
                        y: (touch.clientY - rect.top - currentZoom.y) / currentZoom.k
                    };
                } else {
                    mousePos = getMousePosition(event);
                }
                
                const sourcePos = getAbsPortPosition(sourceNode, sourcePort);
                
                // Update the path
                const sourceOrientation = sourceNode.portOrientation || 'vertical';
                const estimatedEndSide = sourceOrientation === 'vertical' 
                    ? (mousePos.y > sourcePos.y ? 'bottom' : 'top')
                    : (mousePos.x > sourcePos.x ? 'right' : 'left');
                tempConnection.attr("d", createBezierPath(
                    sourcePos,
                    mousePos,
                    sourcePort.side,
                    estimatedEndSide,
                    sourceOrientation,
                    sourceOrientation  // Assume same orientation for temp connection
                ));
            }

            // Initial position
            updateConnection(event);

            // Add event listeners for both mouse and touch
            svg.on("mousemove.connection touchmove.connection", updateConnection);
            
            function endConnection(e) {
                // Clean up event listeners
                svg.on("mousemove.connection touchmove.connection", null)
                   .on("mouseup.connection touchend.connection", null);
                
                // Remove temporary connection
                tempConnectionGroup.remove();
                
                // Get the target position based on event type
                let targetPos;
                if (e.type.startsWith('touch')) {
                    const touch = e.changedTouches[0];
                    const rect = svg.node().getBoundingClientRect();
                    targetPos = {
                        x: (touch.clientX - rect.left - currentZoom.x) / currentZoom.k,
                        y: (touch.clientY - rect.top - currentZoom.y) / currentZoom.k
                    };
                } else {
                    targetPos = getMousePosition(e);
                }

                // Find the closest node within a reasonable distance
                let closestNode = null;
                let closestDistance = Infinity;
                let closestPort = null;

                nodes.forEach(node => {
                    // Find the closest input port on this node to the target position
                    const inputPorts = node.ports.filter(p => p.type === 'input');
                    if (inputPorts.length > 0) {
                        let closestPortOnNode = null;
                        let closestPortDistance = Infinity;
                        
                        inputPorts.forEach(port => {
                            const portPos = getAbsPortPosition(node, port);
                            const distance = Math.hypot(
                                targetPos.x - portPos.x,
                                targetPos.y - portPos.y
                            );
                            
                            if (distance < closestPortDistance && distance < 100) { // 100 pixel threshold
                                closestPortOnNode = port;
                                closestPortDistance = distance;
                            }
                        });
                        
                        // If we found a close input port, use this node
                        if (closestPortOnNode && closestPortDistance < closestDistance) {
                            closestNode = node;
                            closestDistance = closestPortDistance;
                            closestPort = closestPortOnNode;
                        }
                    }
                });

                // If we found a valid target node with an input port
                if (closestNode && closestPort) {
                    // Validate resource type compatibility
                    const sourcePort = tempConnectionData.sourcePort;
                    if (!canConnectPorts(sourcePort, closestPort)) {
                        console.log(`Cannot connect: ${sourcePort.resourceType} ‚Üí ${closestPort.resourceType} (incompatible types)`);
                        // Don't create connection - types incompatible
                    } else {
                        // Remove any existing connection to this input
                        if (closestNode.type === NODE_TYPES.PROCESSOR || closestNode.type === NODE_TYPES.SOLAR_ARRAY) {
                            const existingConnection = connections.find(c => 
                                c.targetNodeId === closestNode.id && 
                                c.targetPortId === closestPort.id
                            );
                            if (existingConnection) {
                                connections = connections.filter(c => c.id !== existingConnection.id);
                            }
                        }
                        
                        // Create new connection
                        connectionIdCounter++;
                        connections.push({
                            id: `conn-${connectionIdCounter}`,
                            sourceNodeId: tempConnectionData.sourceNodeId,
                            sourcePortId: tempConnectionData.sourcePortId,
                            targetNodeId: closestNode.id,
                            targetPortId: closestPort.id
                        });
                        // Phase 3: Invalidate connection path cache for new connection
                        connectionPathCache.clear();
                    }
                } else {
                    // No target found - auto-create a container node for USER_DEFINED resources
                    const sourcePort = tempConnectionData.sourcePort;
                    const sourceNode = findNodeById(tempConnectionData.sourceNodeId);
                    
                    if (sourcePort && sourcePort.resourceType === RESOURCE_TYPES.USER_DEFINED) {
                        // Create a new container node at the drop position
                        const containerLabel = sourcePort.name || 'Container';
                        const newContainer = createNode(NODE_TYPES.RESOURCE_DISPLAY, {
                            x: targetPos.x,
                            y: targetPos.y,
                            label: containerLabel,
                            value: 0,
                            unit: 'units',
                            resourceType: RESOURCE_TYPES.USER_DEFINED,
                            maxCapacity: 100,
                            subType: 'CustomContainer'
                        });
                        
                        if (newContainer) {
                            nodes.push(newContainer);
                            
                            // Find the appropriate port on the new container
                            const targetPort = newContainer.ports.find(p => p.type === 'input');
                            
                            if (targetPort) {
                                // Create connection to the new container
                                connectionIdCounter++;
                                connections.push({
                                    id: `conn-${connectionIdCounter}`,
                                    sourceNodeId: tempConnectionData.sourceNodeId,
                                    sourcePortId: tempConnectionData.sourcePortId,
                                    targetNodeId: newContainer.id,
                                    targetPortId: targetPort.id
                                });
                                connectionPathCache.clear();
                            }
                        }
                    }
                }
                
                tempConnectionData = null;
                scheduleRender(); // Phase 1: Use batched render
            }

            // Add end connection handlers for both mouse and touch
            svg.on("mouseup.connection touchend.connection", endConnection);
        }

        // Modified createAndConnectContainer function
        function createAndConnectContainer(portData) {
            const sourceNode = portData.parentNode;
            const portPos = getAbsPortPosition(sourceNode, portData);
            
            // Calculate position closer to the source node
            const offsetX = portData.type === 'input' ? -150 : 150;
            const worldPos = screenToWorld(portPos.x + offsetX, portPos.y);
            
            // Ensure the container stays within visible bounds
            const padding = 50;
            const minX = padding;
            const maxX = svgWidth - padding;
            const minY = padding;
            const maxY = svgHeight - padding;
            
            const x = Math.max(minX, Math.min(maxX, worldPos.x));
            const y = Math.max(minY, Math.min(maxY, worldPos.y));

            // Create the container node with explicit port configuration
            const containerNode = {
                id: `node-${++nodeIdCounter}`,
                type: NODE_TYPES.RESOURCE_DISPLAY,
                x: x,
                y: y,
                width: DEFAULT_NODE_WIDTH,
                height: portData.resourceType === RESOURCE_TYPES.POWER ? DEFAULT_NODE_HEIGHT_BATTERY : DEFAULT_NODE_HEIGHT_RESOURCE,
                label: `${portData.resourceType} CONTAINER`,
                resourceType: portData.resourceType,
                unit: getDefaultUnitForResource(portData.resourceType),
                maxCapacity: getDefaultCapacityForResource(portData.resourceType),
                value: 0,
                ports: [
                    {
                        id: `p-${nodeIdCounter}-in-0`,
                        type: 'input',
                        resourceType: portData.resourceType,
                        name: `${portData.resourceType} In`,
                        side: 'left',
                        yOffsetRatio: 0.5
                    },
                    {
                        id: `p-${nodeIdCounter}-out-0`,
                        type: 'output',
                        resourceType: portData.resourceType,
                        name: `${portData.resourceType} Out`,
                        side: 'right',
                        yOffsetRatio: 0.5
                    }
                ]
            };
            
            nodes.push(containerNode);
            
            // Create connection immediately
            connectionIdCounter++;
            const connection = {
                id: `conn-${connectionIdCounter}`,
                sourceNodeId: portData.type === 'input' ? containerNode.id : sourceNode.id,
                sourcePortId: portData.type === 'input' ? containerNode.ports.find(p => p.type === 'output').id : portData.id,
                targetNodeId: portData.type === 'input' ? sourceNode.id : containerNode.id,
                targetPortId: portData.type === 'input' ? portData.id : containerNode.ports.find(p => p.type === 'input').id
            };
            
            connections.push(connection);
            // Phase 3: Invalidate connection path cache for new connection
            connectionPathCache.clear();
            
            // Phase 1: Use batched render
            scheduleRender();
            
            // Ensure the new container is visible by centering the view on it
            const centerX = x - svgWidth / 2;
            const centerY = y - svgHeight / 2;
            currentZoom = d3.zoomIdentity.translate(-centerX, -centerY);
            svg.call(zoom.transform, currentZoom);
        }

        // Phase 2: Viewport culling and change detection
        const nodeValueCache = new Map();
        const nodeStateCache = new Map();
        const selectionCache = {
            zoomGroup: null,
            nodeGroups: null,
            connectionGroup: null
        };

        // Phase 3: Memoization caches
        const portPositionCache = new Map(); // Cache port positions (key: nodeId-portId-zoomKey)
        const connectionPathCache = new Map(); // Cache connection paths (key: connectionId-zoomKey)
        const statsBarCache = new Map(); // Cache stats bar values to avoid unnecessary DOM updates
        
        function getZoomKey() {
            // Create a key based on current zoom transform for cache invalidation
            return `${currentZoom.k.toFixed(2)}-${currentZoom.x.toFixed(0)}-${currentZoom.y.toFixed(0)}`;
        }

        function getZoomGroup() {
            if (!selectionCache.zoomGroup) {
                selectionCache.zoomGroup = d3.select(".zoom-group");
            }
            return selectionCache.zoomGroup;
        }

        let isInitialLoad = true; // Flag to disable viewport culling on first load

        function getVisibleNodes() {
            // Phase 2: On initial load, render all nodes to ensure they're visible
            if (isInitialLoad) {
                return nodes;
            }
            
            const transform = d3.zoomTransform(getZoomGroup().node());
            const viewport = {
                x: -transform.x / transform.k,
                y: -transform.y / transform.k,
                width: svgWidth / transform.k,
                height: svgHeight / transform.k
            };
            
            // Add buffer zone to prevent flickering at edges
            const buffer = 200;
            
            return nodes.filter(node => {
                return node.x + node.width >= viewport.x - buffer &&
                       node.x <= viewport.x + viewport.width + buffer &&
                       node.y + node.height >= viewport.y - buffer &&
                       node.y <= viewport.y + viewport.height + buffer;
            });
        }

        function fitViewToNodes() {
            if (nodes.length === 0) return;
            
            // Calculate bounding box of all nodes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
            });
            
            // Add padding (20% on each side)
            const padding = 0.2;
            const width = maxX - minX;
            const height = maxY - minY;
            const paddedWidth = width * (1 + 2 * padding);
            const paddedHeight = height * (1 + 2 * padding);
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Calculate scale to fit
            const scaleX = svgWidth / paddedWidth;
            const scaleY = svgHeight / paddedHeight;
            const fitScale = Math.min(scaleX, scaleY, 1); // Don't zoom in beyond 1:1
            
            // Zoom out two levels from the fitted scale (same as clicking zoom out button twice)
            // Each zoom out scales by 0.75, so twice is 0.75 * 0.75 = 0.5625
            const finalScale = fitScale * 0.5625;
            
            // Calculate translation to center the view
            const translateX = svgWidth / 2 - centerX * finalScale;
            const translateY = svgHeight / 2 - centerY * finalScale;
            
            // Apply the transform
            currentZoom = d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(finalScale);
            svg.call(zoom.transform, currentZoom);
        }

        function hasNodeValueChanged(nodeId, newValue) {
            const cached = nodeValueCache.get(nodeId);
            if (cached !== newValue) {
                nodeValueCache.set(nodeId, newValue);
                return true;
            }
            return false;
        }

        function hasNodeStateChanged(nodeId, state) {
            const cached = nodeStateCache.get(nodeId);
            const stateKey = JSON.stringify(state);
            if (cached !== stateKey) {
                nodeStateCache.set(nodeId, stateKey);
                return true;
            }
            return false;
        }

        function invalidateNodeCache(nodeId) {
            nodeValueCache.delete(nodeId);
            nodeStateCache.delete(nodeId);
            // Phase 3: Invalidate port position cache for this node
            // Remove all cache entries for this node
            for (const key of portPositionCache.keys()) {
                if (key.startsWith(`${nodeId}-`)) {
                    portPositionCache.delete(key);
                }
            }
            // Invalidate connection paths that involve this node
            for (const key of connectionPathCache.keys()) {
                if (key.includes(nodeId)) {
                    connectionPathCache.delete(key);
                }
            }
        }

        // Modified renderNodes function with Phase 2 optimizations
        function renderNodes() {
            // Phase 2: Viewport culling - only render visible nodes
            const visibleNodes = getVisibleNodes();
            const nodeGroups = getZoomGroup().selectAll(".node")
                .data(visibleNodes, d => d.id)
                .join(
                    enter => {
                        const group = enter.append("g")
                            .attr("class", d => `node ${d.type} ${d.type === NODE_TYPES.SOLAR_ARRAY ? 'solar-array' : ''} ${d.type === NODE_TYPES.RESOURCE_DISPLAY && d.subType === 'BatteryBank' ? 'battery' : ''}`)
                            .attr("transform", d => `translate(${d.x},${d.y})`)
                            .call(d3.drag().on("start", dragStarted).on("drag", dragged).on("end", dragEnded))
                            .on("click", (e, d) => { e.stopPropagation(); selectNode(d.id); });

                        // For resource display nodes, add elements in specific order
                        const rdEnter = group.filter(d => d.type === NODE_TYPES.RESOURCE_DISPLAY);
                        rdEnter.append("rect").attr("class", "node-rect")
                            .style("fill", d => {
                                // Force IBC containers to have gray/white background from the start
                                if (d.subType !== 'BatteryBank') {
                                    return '#e8e8e8';
                                }
                                return null; // Let CSS handle battery
                            })
                            .style("stroke", d => {
                                // Force IBC containers to have gray stroke from the start
                                if (d.subType !== 'BatteryBank') {
                                    return '#999';
                                }
                                return null; // Let CSS handle battery
                            });
                        rdEnter.append("rect").attr("class", "capacity-bar-bg");
                        rdEnter.append("rect").attr("class", "capacity-bar-fill");
                        // Add IBC grid overlay (only for non-battery containers)
                        rdEnter.filter(d => d.subType !== 'BatteryBank')
                            .append("g").attr("class", "ibc-grid-container");
                        rdEnter.append("text").attr("class", "node-title");
                        rdEnter.append("text").attr("class", "node-value");
                        rdEnter.append("text").attr("class", "node-unit");
                        rdEnter.append("image").attr("class", "node-img");
                        rdEnter.append("text").attr("class", "node-emoji");
                        rdEnter.append("text")
                            .attr("class", "close-button")
                            .text("X")
                            .attr("x", d => d.width - 15)
                            .attr("y", 15)
                            .on("click", (e, d) => { e.stopPropagation(); removeNode(d.id); });

                        // For processor nodes
                        const procEnter = group.filter(d => d.type === NODE_TYPES.PROCESSOR);
                        procEnter.append("rect").attr("class", "node-rect")
                            .style("filter", "url(#node-dynamic-shadow)");
                        procEnter.append("text").attr("class", "node-title");
                        procEnter.append("image").attr("class", "node-img");
                        procEnter.append("text").attr("class", "node-emoji");
                        procEnter.append("text").attr("class", "node-wattage");
                        procEnter.append("g")
                            .attr("class", "node-action-button")
                            .style("cursor", "pointer")
                            .style("display", () => challengeMode ? "none" : null)
                            .on("mousedown", (e, d) => { 
                                e.stopPropagation(); 
                                toggleProcessor(d);
                            })
                            .append("rect")
                            .attr("x", d => d.width - 60)
                            .attr("y", d => d.height - 30)
                            .attr("width", 50)
                            .attr("height", 20);
                        procEnter.select(".node-action-button")
                            .append("text")
                            .attr("x", d => d.width - 35)
                            .attr("y", d => d.height - 15)
                            .text(d => d.isRunning ? "Stop" : "Start");
                        procEnter.append("text")
                            .attr("class", "close-button")
                            .text("X")
                            .attr("x", d => d.width - 15)
                            .attr("y", 15)
                            .on("click", (e, d) => { e.stopPropagation(); removeNode(d.id); });

                        // For solar array nodes
                        const solarEnter = group.filter(d => d.type === NODE_TYPES.SOLAR_ARRAY);
                        solarEnter.append("rect").attr("class", "node-rect")
                            .style("filter", "url(#node-dynamic-shadow)");
                        solarEnter.append("rect").attr("class", "power-bar-bg");
                        solarEnter.append("rect").attr("class", "power-bar-fill");
                        solarEnter.append("text").attr("class", "node-title");
                        solarEnter.append("image").attr("class", "node-img");
                        solarEnter.append("text").attr("class", "node-wattage");
                        solarEnter.append("text")
                            .attr("class", "close-button")
                            .text("X")
                            .attr("x", d => d.width - 15)
                            .attr("y", 15)
                            .on("click", (e, d) => { e.stopPropagation(); removeNode(d.id); });
                        
                        // Add ports for all nodes
                        group.selectAll(".port-handle")
                            .data(d => d.ports.map(p => ({...p, parentNode: d})))
                            .enter()
                            .append("circle")
                            .attr("class", p => `port-handle ${p.type}`)
                            .attr("r", 13)  // Slightly larger for better visibility
                            .style("touch-action", "none")  // Prevent default touch actions
                            .on("mousedown", (e, pData) => { 
                                e.stopPropagation(); 
                                startConnection(e, pData.parentNode.id, pData.id); 
                            })
                            .on("touchstart", (e, pData) => {
                                e.preventDefault();  // Prevent default touch behavior
                                e.stopPropagation();
                                startConnection(e, pData.parentNode.id, pData.id);
                            })
                            .on("dblclick", (e, pData) => { 
                                e.stopPropagation(); 
                                createAndConnectContainer(pData);
                            })
                            .append("title")
                            .text(p => `${p.name || 'Port'} (${p.resourceType})`);
                        
                        // Flip button removed - now in inspector panel

                        return group;
                    },
                    update => {
                        // Update node positions and attributes
                        update.attr("transform", d => `translate(${d.x},${d.y})`)
                            .attr("class", d => {
                                let classes = `node ${d.type}`;
                                if (d.type === NODE_TYPES.SOLAR_ARRAY) classes += ' solar-array';
                                if (d.type === NODE_TYPES.RESOURCE_DISPLAY && d.subType === 'BatteryBank') classes += ' battery';
                                return classes;
                            });
                        
                        // Update node elements
                        update.select(".node-rect")
                            .attr("width", d => d.width)
                            .attr("height", d => d.height)
                            .style("filter", "url(#node-dynamic-shadow)")
                            .each(function(d) {
                                const rect = d3.select(this);
                                // Force IBC containers to have gray/white background
                                if (d.type === NODE_TYPES.RESOURCE_DISPLAY && d.subType !== 'BatteryBank') {
                                    rect.style("fill", "#e8e8e8")
                                        .style("stroke", "#999");
                                } else {
                                    // Clear inline styles for non-IBC nodes to let CSS handle them
                                    rect.style("fill", null)
                                        .style("stroke", null);
                                }
                            });
                            
                        update.select(".node-title")
                            .attr("x", d => d.width/2)
                            .attr("y", d => d.type === NODE_TYPES.PROCESSOR ? 28 : 25)
                            .each(function(d) {
                                const title = d3.select(this);
                                // Black text for IBC containers, no stroke
                                if (d.type === NODE_TYPES.RESOURCE_DISPLAY && d.subType !== 'BatteryBank') {
                                    title.style("fill", "#000000")
                                        .style("stroke", "none");
                                } else {
                                    // Let CSS handle others
                                    title.style("fill", null)
                                        .style("stroke", null);
                                }
                            })
                            .call((selection) => {
                                selection.each(function(d) {
                                    const fontSize = d.type === NODE_TYPES.PROCESSOR ? 16 : 15;
                                    const maxWidth = d.width - 30; // Leave padding on sides
                                    wrapText(d3.select(this), d.label, maxWidth, fontSize);
                                });
                            });

                        // Update close button positions
                        update.select(".close-button")
                            .attr("x", d => d.width - 15)
                            .attr("y", 15);
                        
                        // Flip button removed - now in inspector panel

                        // Update resource display nodes with Phase 2: Change detection
                        const rdUpdate = update.filter(d => d.type === NODE_TYPES.RESOURCE_DISPLAY);
                        rdUpdate.each(function(d) {
                            const group = d3.select(this);
                            const isBattery = d.subType === 'BatteryBank';
                            
                            // Make non-battery containers perfectly square
                            if (!isBattery) {
                                d.width = DEFAULT_NODE_WIDTH;
                                d.height = DEFAULT_NODE_HEIGHT_RESOURCE;
                            }
                            
                            // Force IBC containers to have gray/white background
                            if (!isBattery) {
                                const rect = group.select(".node-rect");
                                rect.style("fill", "#e8e8e8")
                                    .style("stroke", "#999")
                                    .attr("fill", "#e8e8e8")  // Also set as attribute for maximum compatibility
                                    .attr("stroke", "#999");
                            }
                            
                            const valueY = d.img ? 75 : (d.height/2 + 5);  // Adjusted for compact height
                            const unitY = d.img ? 110 : (d.height/2 + 35);  // Increased spacing between value and unit
                            
                            // Phase 2: Only update capacity bar if value changed
                            const fillRatio = d.maxCapacity && d.maxCapacity > 0 ? Math.max(0, Math.min(1, d.value / d.maxCapacity)) : 0;
                            const fillHeight = fillRatio * d.height;
                            
                            // Update capacity bar background (only if dimensions changed)
                            const capacityBarBg = group.select(".capacity-bar-bg");
                            const bgState = { width: d.width, height: d.height, maxCapacity: d.maxCapacity };
                            if (hasNodeStateChanged(d.id + '-bg', bgState)) {
                                capacityBarBg
                                    .attr("x", 0)
                                    .attr("y", 0)
                                    .attr("width", d.width)
                                    .attr("height", d.height)
                                    .style("display", d.maxCapacity && d.maxCapacity > 0 ? null : "none")
                                    .style("fill", !isBattery ? "#e8e8e8" : null);
                            }

                            // Update capacity bar fill (only if value changed)
                            if (hasNodeValueChanged(d.id + '-fill', fillHeight)) {
                                group.select(".capacity-bar-fill")
                                    .attr("x", 0)
                                    .attr("y", d.height - fillHeight)
                                    .attr("width", d.width)
                                    .attr("height", fillHeight)
                                    .style("display", d.maxCapacity && d.maxCapacity > 0 ? null : "none")
                                    .style("fill", d.progressColor || '#6fa06c');
                            }
                            
                            // Update IBC grid overlay (only for non-battery containers)
                            if (!isBattery) {
                                let gridContainer = group.select(".ibc-grid-container");
                                if (gridContainer.empty()) {
                                    gridContainer = group.insert("g", ".node-title").attr("class", "ibc-grid-container");
                                }
                                gridContainer.selectAll("*").remove();
                                
                                // Draw IBC cage grid - full area coverage
                                const gridX = 0;
                                const gridY = 0;
                                const gridWidth = d.width;
                                const gridHeight = d.height;
                                const cols = 4;
                                const rows = 4;
                                
                                // Outer frame with rounded corners
                                const cornerRadius = 8;
                                gridContainer.append("rect")
                                    .attr("class", "ibc-grid")
                                    .attr("x", gridX)
                                    .attr("y", gridY)
                                    .attr("width", gridWidth)
                                    .attr("height", gridHeight)
                                    .attr("rx", cornerRadius)
                                    .attr("ry", cornerRadius);
                                
                                // Vertical grid lines - full height
                                for (let i = 1; i < cols; i++) {
                                    const x = gridX + (gridWidth / cols) * i;
                                    gridContainer.append("line")
                                        .attr("class", "ibc-grid")
                                        .attr("x1", x)
                                        .attr("y1", gridY)
                                        .attr("x2", x)
                                        .attr("y2", gridY + gridHeight);
                                }
                                
                                // Horizontal grid lines - full width
                                for (let i = 1; i < rows; i++) {
                                    const y = gridY + (gridHeight / rows) * i;
                                    gridContainer.append("line")
                                        .attr("class", "ibc-grid")
                                        .attr("x1", gridX)
                                        .attr("y1", y)
                                        .attr("x2", gridX + gridWidth)
                                        .attr("y2", y);
                                }
                            }

                            // Phase 2: Update value text only if changed
                            const valueText = d.value.toFixed(1);
                            const nodeValueEl = group.select(".node-value");
                            if (hasNodeValueChanged(d.id + '-value', valueText)) {
                                nodeValueEl.text(valueText);
                            }
                            // Update position if dimensions changed
                            const posState = { width: d.width, valueY: valueY };
                            if (hasNodeStateChanged(d.id + '-value-pos', posState)) {
                                nodeValueEl.attr("x", d.width/2)
                                    .attr("y", valueY);
                            }

                            group.select(".node-unit")
                                .attr("x", d.width/2)
                                .attr("y", unitY)
                                .call((selection) => {
                                    selection.each(function(d) {
                                        const fontSize = 24;
                                        const maxWidth = d.width - 30; // Leave padding on sides
                                        wrapText(d3.select(this), d.unit, maxWidth, fontSize);
                                    });
                                });
                        });

                        // Update processor nodes
                        const procUpdate = update.filter(d => d.type === NODE_TYPES.PROCESSOR);
                        procUpdate.each(function(d) {
                            const group = d3.select(this);
                            
                            // Update node status classes
                            group.classed("is-running", d.isRunning)
                                .classed("is-stalled", !d.canProcessLastStep && d.isRunning)
                                .classed("is-awaiting-batch", d.awaitingBatchInputs);

                            // Update wattage display (power consumption)
                            const continuousPowerDef = d.config && d.config.inputs ? d.config.inputs.find(inp => inp.resourceType === RESOURCE_TYPES.POWER && !inp.isBatchIO) : null;
                            const powerConsumption = (d.isRunning && continuousPowerDef) ? continuousPowerDef.rate * 1000 : 0; // Convert kW to watts
                            const wattageText = powerConsumption > 0 ? `${powerConsumption.toFixed(0)} W` : "0 W";
                            const wattageElement = group.select(".node-wattage");
                            
                            // Calculate optimal font size to fit within node width (with padding)
                            const maxWidth = d.width - 20; // Leave 10px padding on each side
                            let fontSize = 18; // Start with larger font
                            wattageElement
                                .attr("x", d.width / 2)
                                .attr("y", d.height - 60)
                                .style("text-anchor", "middle")
                                .style("font-size", `${fontSize}px`)
                                .style("fill", "#ffdd57")
                                .style("font-weight", "bold")
                                .style("filter", "url(#wattage-drop-shadow)")
                                .text(wattageText);
                            
                            // Auto-scale font if text is too wide
                            const textNode = wattageElement.node();
                            if (textNode) {
                                const textWidth = textNode.getBBox().width;
                                if (textWidth > maxWidth) {
                                    fontSize = Math.floor((maxWidth / textWidth) * fontSize);
                                    wattageElement.style("font-size", `${Math.max(10, fontSize)}px`);
                                }
                            }

                            // Update image or emoji if present
                            if (d.img) {
                                const isEmoji = d.img.length <= 4 && !/^https?:\/\//.test(d.img);
                                if (isEmoji) {
                                    group.select(".node-img").style("display", "none");
                                    group.select(".node-emoji")
                                        .style("display", null)
                                        .attr("x", d.width / 2)
                                        .attr("y", d.height / 2 + 10)
                                        .attr("text-anchor", "middle")
                                        .attr("font-size", "40px")
                                        .text(d.img);
                                } else {
                                    group.select(".node-emoji").style("display", "none");
                                    group.select(".node-img")
                                        .style("display", null)
                                        .attr("x", 10)
                                        .attr("y", 40)
                                        .attr("width", d.width - 20)
                                        .attr("height", d.height - 80)
                                        .attr("xlink:href", d.img);
                                }
                            } else {
                                group.select(".node-img").style("display", "none");
                                group.select(".node-emoji").style("display", "none");
                            }

                            // Update action button
                            if (!group.select(".node-action-button").size()) {
                                const actionButton = group.append("g")
                                    .attr("class", "node-action-button")
                                    .style("cursor", "pointer")
                                    .on("mousedown", (e, d) => { 
                                        e.stopPropagation(); 
                                        toggleProcessor(d);
                                    });
                                
                                actionButton.append("rect")
                                    .attr("x", d.width/2 - 40)
                                    .attr("y", d.height - 40)
                                    .attr("width", 80)
                                    .attr("height", 30);
                                
                                actionButton.append("text")
                                    .attr("x", d.width/2)
                                    .attr("y", d.height - 25)
                                    .text(d.isRunning ? "Stop" : "Start");
                            } else {
                                group.select(".node-action-button")
                                    .style("display", challengeMode ? "none" : null);
                                group.select(".node-action-button rect")
                                    .attr("x", d.width/2 - 40)
                                    .attr("y", d.height - 40)
                                    .attr("width", 80)
                                    .attr("height", 30);
                                
                                group.select(".node-action-button text")
                                    .attr("x", d.width/2)
                                    .attr("y", d.height - 25)
                                    .text(d.isRunning ? "Stop" : "Start");
                            }

                            // Add/update port labels
                            group.selectAll(".port-text-label").remove();
                            d.ports.forEach(port => {
                                const orientation = d.portOrientation || 'vertical';
                                let labelX, labelY, textAnchor;
                                
                                if (orientation === 'vertical') {
                                    // Top/bottom: labels above/below ports
                                    labelX = d.width * (port.xOffsetRatio || 0.5);
                                    labelY = port.side === 'top' ? -PORT_TEXT_OFFSETY : d.height + PORT_TEXT_OFFSETY;
                                    textAnchor = 'middle';
                                } else {
                                    // Left/right: labels to the side
                                    labelX = port.side === 'left' ? PORT_TEXT_OFFSETX : d.width - PORT_TEXT_OFFSETX;
                                    labelY = d.height * (port.yOffsetRatio || 0.5) + PORT_TEXT_OFFSETY;
                                    textAnchor = port.side === 'left' ? 'start' : 'end';
                                }
                                
                                group.append("text")
                                    .attr("class", `port-text-label ${port.type}`)
                                    .attr("x", labelX)
                                    .attr("y", labelY)
                                    .style("text-anchor", textAnchor)
                                    .text(port.name);
                            });
                        });

                        // Update solar array nodes
                        const solarUpdate = update.filter(d => d.type === NODE_TYPES.SOLAR_ARRAY);
                        solarUpdate.each(function(d) {
                            const group = d3.select(this);
                            
                            // Update node status classes
                            group.classed("is-running", d.currentOutput > 0.001);
                            
                            // Update power bar
                            group.select(".power-bar-bg")
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("width", d.width)
                                .attr("height", d.height);

                            const powerRatio = d.currentOutput / d.ratedOutput;
                            const fillHeight = powerRatio * d.height;
                            group.select(".power-bar-fill")
                                .attr("x", 0)
                                .attr("y", d.height - fillHeight)
                                .attr("width", d.width)
                                .attr("height", fillHeight);
                            
                            // Update wattage display (solar output in watts)
                            const wattage = d.currentOutput * 1000; // Convert kW to watts
                            const wattageText = `${wattage.toFixed(0)} W`;
                            const wattageElement = group.select(".node-wattage");
                            
                            // Calculate optimal font size to fit within node width (with padding)
                            const maxWidth = d.width - 20; // Leave 10px padding on each side
                            let fontSize = 18; // Start with larger font
                            wattageElement
                                .attr("x", d.width / 2)
                                .attr("y", d.height - 60)
                                .style("text-anchor", "middle")
                                .style("font-size", `${fontSize}px`)
                                .style("fill", "#ffdd57")
                                .style("font-weight", "bold")
                                .style("filter", "url(#wattage-drop-shadow)")
                                .text(wattageText);
                            
                            // Auto-scale font if text is too wide
                            const textNode = wattageElement.node();
                            if (textNode) {
                                const textWidth = textNode.getBBox().width;
                                if (textWidth > maxWidth) {
                                    fontSize = Math.floor((maxWidth / textWidth) * fontSize);
                                    wattageElement.style("font-size", `${Math.max(10, fontSize)}px`);
                                }
                            }
                            
                            // Update image or emoji if present
                            if (d.img) {
                                const isEmoji = d.img.length <= 4 && !/^https?:\/\//.test(d.img);
                                if (isEmoji) {
                                    group.select(".node-img").style("display", "none");
                                    group.select(".node-emoji")
                                        .style("display", null)
                                        .attr("x", d.width / 2)
                                        .attr("y", d.height / 2 + 10)
                                        .attr("text-anchor", "middle")
                                        .attr("font-size", "40px")
                                        .text(d.img);
                                } else {
                                    group.select(".node-emoji").style("display", "none");
                                    group.select(".node-img")
                                        .style("display", null)
                                        .attr("x", 10)
                                        .attr("y", 40)
                                        .attr("width", d.width - 20)
                                        .attr("height", d.height - 80)
                                        .attr("xlink:href", d.img);
                                }
                            } else {
                                group.select(".node-img").style("display", "none");
                                group.select(".node-emoji").style("display", "none");
                            }

                            // Add/update port labels
                            group.selectAll(".port-text-label").remove();
                            d.ports.forEach(port => {
                                const orientation = d.portOrientation || 'vertical';
                                let labelX, labelY, textAnchor;
                                
                                if (orientation === 'vertical') {
                                    // Top/bottom: labels above/below ports
                                    labelX = d.width * (port.xOffsetRatio || 0.5);
                                    labelY = port.side === 'top' ? -PORT_TEXT_OFFSETY : d.height + PORT_TEXT_OFFSETY;
                                    textAnchor = 'middle';
                                } else {
                                    // Left/right: labels to the side
                                    labelX = port.side === 'left' ? PORT_TEXT_OFFSETX : d.width - PORT_TEXT_OFFSETX;
                                    labelY = d.height * (port.yOffsetRatio || 0.5) + PORT_TEXT_OFFSETY;
                                    textAnchor = port.side === 'left' ? 'start' : 'end';
                                }
                                
                                group.append("text")
                                    .attr("class", `port-text-label ${port.type}`)
                                    .attr("x", labelX)
                                    .attr("y", labelY)
                                    .style("text-anchor", textAnchor)
                                    .text(port.name);
                            });
                        });
                            
                        // Update ports
                        update.selectAll(".port-handle")
                            .data(d => d.ports.map(p => ({...p, parentNode: d})))
                            .join(
                                enter => enter.append("circle")
                                    .attr("class", p => `port-handle ${p.type}`)
                                    .attr("r", 13)  // Slightly larger for better visibility
                                    .style("touch-action", "none")  // Prevent default touch actions
                                    .on("mousedown", (e, pData) => { 
                                        e.stopPropagation(); 
                                        startConnection(e, pData.parentNode.id, pData.id); 
                                    })
                                    .on("touchstart", (e, pData) => {
                                        e.preventDefault();  // Prevent default touch behavior
                                        e.stopPropagation();
                                        startConnection(e, pData.parentNode.id, pData.id);
                                    })
                                    .on("dblclick", (e, pData) => { 
                                        e.stopPropagation(); 
                                        createAndConnectContainer(pData);
                                    })
                                    .append("title")
                                    .text(p => `${p.name || 'Port'} (${p.resourceType})`),
                                update => update,
                                exit => exit.remove()
                            )
                            .attr("cx", p => {
                                const orientation = p.parentNode.portOrientation || 'vertical';
                                if (orientation === 'vertical') {
                                    return p.parentNode.width * (p.xOffsetRatio || 0.5);
                                } else {
                                    return p.side === 'left' ? 0 : p.parentNode.width;
                                }
                            })
                            .attr("cy", p => {
                                const orientation = p.parentNode.portOrientation || 'vertical';
                                if (orientation === 'vertical') {
                                    return p.side === 'top' ? 0 : p.parentNode.height;
                                } else {
                                    return p.parentNode.height * (p.yOffsetRatio || 0.5);
                                }
                            });

                        return update;
                    },
                    exit => exit.remove()
                );
        }

        let nodes = []; let connections = []; let nodeIdCounter = 0; let connectionIdCounter = 0;
        let inspectorIoItemIdCounter = 0; let isPlaying = false; // Phase 1: Removed simulationInterval (using RAF)
        let elapsedHours = 0; let currentSimSpeedMs = 1000; const baseSimSpeedMs = 1000; 
        let selectedNodeId = null;
        let challengeMode = false;
        let weatherDifficulty = 'clear'; // 'clear', 'easy', 'medium', 'hard'
        let currentHourDerating = 1.0; // Derating factor for current hour
        let lastDeratingHour = -1; // Track which hour we last calculated derating for
        let challengeStats = {
            solarKwhGenerated: 0,
            solarKwhCaptured: 0,
            solarKwhPossible: 0,
            totalKwhGenerated: 0,
            totalKwhConsumed: 0,
            resourcesConsumed: {},
            resourcesProduced: {},
            biocharProduced: 0,
            woodgasConsumed: 0
        };
        
        // Live stats tracking (works in both challenge and regular mode)
        // eCO2 calculation factors (user-editable)
        let eco2Factors = {
            biocharCaptureFactor: 1.8,  // kg eCO2 per 1 kg Biochar (sequestered)
            woodgasAvoidanceFactor: 1.2  // kg eCO2 per 1 m3 woodgas (avoided)
        };
        
        let liveStats = {
            solarKwhGenerated: 0,        // Only solar energy generated
            solarKwhCaptured: 0,         // Solar energy actually captured/stored (not lost)
            solarKwhPossible: 0,         // Total possible solar energy (if battery never filled)
            totalKwhGenerated: 0,        // All sources (solar + generator + etc)
            totalKwhConsumed: 0,         // Total energy consumed
            resourcesConsumed: {},
            resourcesProduced: {},
            // eCO2 tracking
            biocharProduced: 0,          // Total kg Biochar produced
            woodgasConsumed: 0,          // Total m3 woodgas consumed (for generator)
            eco2Sequestered: 0,          // eCO2 sequestered from biochar
            eco2Avoided: 0,              // eCO2 avoided from woodgas
            eco2TotalSaved: 0            // Total eCO2 saved (sequestered + avoided)
        };
        
        // Function to check if a resource type is a net resource (for tracking)
        function isNetResource(resourceType) {
            const customProductTypes = [RESOURCE_TYPES.CUSTOM_PRODUCT_A, RESOURCE_TYPES.CUSTOM_PRODUCT_B];
            if (customProductTypes.includes(resourceType)) {
                return false;
            }
            
            const matchingNodes = nodes.filter(n => 
                n.type === NODE_TYPES.RESOURCE_DISPLAY && 
                n.resourceType === resourceType
            );
            
            if (matchingNodes.length === 0) {
                return false;
            }
            
            for (const node of matchingNodes) {
                // Check if this resource has input connections
                const hasInputConnections = connections.some(c => 
                    c.targetNodeId === node.id && 
                    node.ports.some(p => p.id === c.targetPortId && p.type === 'input')
                );
                
                // Check if this resource has output connections
                const hasOutputConnections = connections.some(c => 
                    c.sourceNodeId === node.id && 
                    node.ports.some(p => p.id === c.sourcePortId && p.type === 'output')
                );
                
                // Net resource: either no inputs (net input) OR no outputs (net output)
                // Also track if it has at least one connection (ensures resources like Wind Turbines/Plastic Parts are tracked even if they have both)
                if ((!hasInputConnections && hasOutputConnections) || (hasInputConnections && !hasOutputConnections) || (hasInputConnections && hasOutputConnections)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Function to identify net resources (those with no inputs OR no outputs)
        // Returns array of objects with {resourceType, label} for each net resource
        function getNetResources() {
            const netResources = [];
            const customProductTypes = [RESOURCE_TYPES.CUSTOM_PRODUCT_A, RESOURCE_TYPES.CUSTOM_PRODUCT_B];
            
            nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY).forEach(node => {
                // Skip custom product resources
                if (customProductTypes.includes(node.resourceType)) {
                    return;
                }
                
                // Check if this resource has input connections
                const hasInputConnections = connections.some(c => 
                    c.targetNodeId === node.id && 
                    node.ports.some(p => p.id === c.targetPortId && p.type === 'input')
                );
                
                // Check if this resource has output connections
                const hasOutputConnections = connections.some(c => 
                    c.sourceNodeId === node.id && 
                    node.ports.some(p => p.id === c.sourcePortId && p.type === 'output')
                );
                
                // Net resource: either no inputs (net input) OR no outputs (net output)
                // But not both (that would be an isolated node)
                if ((!hasInputConnections && hasOutputConnections) || (hasInputConnections && !hasOutputConnections)) {
                    netResources.push({
                        resourceType: node.resourceType,
                        label: node.label || node.resourceType
                    });
                }
            });
            
            return netResources;
        }
        
        // Function to auto-scale text to fit within stat item
        function autoScaleStatText(statItem) {
            const label = statItem.querySelector('.stat-label');
            const value = statItem.querySelector('.stat-value');
            const unit = statItem.querySelector('.stat-unit');
            const itemWidth = statItem.offsetWidth - 20; // Account for padding
            
            // Scale label - reset first, then scale down if needed
            if (label && label.textContent.trim()) {
                label.style.fontSize = ''; // Reset to default
                let fontSize = parseFloat(window.getComputedStyle(label).fontSize);
                while (label.scrollWidth > itemWidth && fontSize > 7) {
                    fontSize -= 0.5;
                    label.style.fontSize = fontSize + 'px';
                }
            }
            
            // Scale value - reset first, then scale down if needed
            if (value && value.textContent.trim()) {
                value.style.fontSize = ''; // Reset to default
                const baseSize = value.classList.contains('large') ? 24 : 20;
                let fontSize = baseSize;
                value.style.fontSize = fontSize + 'px';
                while (value.scrollWidth > itemWidth && fontSize > 12) {
                    fontSize -= 1;
                    value.style.fontSize = fontSize + 'px';
                }
            }
            
            // Scale unit - reset first, then scale down if needed
            if (unit && unit.textContent.trim()) {
                unit.style.fontSize = ''; // Reset to default
                let fontSize = parseFloat(window.getComputedStyle(unit).fontSize);
                while (unit.scrollWidth > itemWidth && fontSize > 7) {
                    fontSize -= 0.5;
                    unit.style.fontSize = fontSize + 'px';
                }
            }
        }
        
        // Micro-Kardashev Scale calculation
        // K_micro = 0.1 * (E_used / E_incident)
        // Range: 0 to 0.1 (perfect theoretical capture)
        function computeMicroKardashev(captured, possible) {
            const f = possible > 0 ? captured / possible : 0;
            return 0.1 * f;
        }
        
        // Function to update the live stats bar
        function updateLiveStatsBar() {
            const timeElapsedEl = document.getElementById('liveTimeElapsed');
            const solarKwhEl = document.getElementById('liveSolarKwh');
            const kwhGeneratedEl = document.getElementById('liveKwhGenerated');
            const kwhConsumedEl = document.getElementById('liveKwhConsumed');
            const netKwhEl = document.getElementById('liveNetKwh');
            const efficiencyEl = document.getElementById('liveEfficiency');
            const resourceStatsContainer = document.getElementById('resourceStatsContainer');
            
            // Phase 3: Only update DOM if values changed
            const timeText = `${elapsedHours}`;
            if (statsBarCache.get('time') !== timeText) {
                timeElapsedEl.textContent = timeText;
                statsBarCache.set('time', timeText);
            }
            
            const solarKwhText = liveStats.solarKwhGenerated.toFixed(2);
            if (statsBarCache.get('solarKwh') !== solarKwhText) {
                solarKwhEl.textContent = solarKwhText;
                statsBarCache.set('solarKwh', solarKwhText);
            }
            
            const kwhGenText = liveStats.totalKwhGenerated.toFixed(2);
            if (statsBarCache.get('kwhGen') !== kwhGenText) {
                kwhGeneratedEl.textContent = kwhGenText;
                statsBarCache.set('kwhGen', kwhGenText);
            }
            
            const kwhConsText = liveStats.totalKwhConsumed.toFixed(2);
            if (statsBarCache.get('kwhCons') !== kwhConsText) {
                kwhConsumedEl.textContent = kwhConsText;
                statsBarCache.set('kwhCons', kwhConsText);
            }
            
            // Update net kWh (generated - consumed)
            const netKwh = liveStats.totalKwhGenerated - liveStats.totalKwhConsumed;
            const netKwhText = (netKwh >= 0 ? '+' : '') + netKwh.toFixed(2);
            const netKwhColor = netKwh >= 0 ? '#5cb85c' : '#d9534f';
            if (statsBarCache.get('netKwh') !== netKwhText || statsBarCache.get('netKwhColor') !== netKwhColor) {
                netKwhEl.textContent = netKwhText;
                netKwhEl.style.color = netKwhColor;
                statsBarCache.set('netKwh', netKwhText);
                statsBarCache.set('netKwhColor', netKwhColor);
            }
            
            // Update efficiency (actual captured solar / possible solar)
            const efficiency = liveStats.solarKwhPossible > 0 
                ? (liveStats.solarKwhCaptured / liveStats.solarKwhPossible * 100).toFixed(2)
                : '0.00';
            const efficiencyText = `${efficiency}%`;
            if (statsBarCache.get('efficiency') !== efficiencyText) {
                efficiencyEl.textContent = efficiencyText;
                statsBarCache.set('efficiency', efficiencyText);
            }
            
            // Update Micro-Kardashev score (K_micro = 0.1 * utilization fraction)
            const kMicro = computeMicroKardashev(liveStats.solarKwhCaptured, liveStats.solarKwhPossible);
            const kMicroText = kMicro.toFixed(5);
            const kMicroEl = document.getElementById('liveKMicro');
            if (statsBarCache.get('kMicro') !== kMicroText) {
                kMicroEl.textContent = kMicroText;
                // Color based on K_micro thresholds
                if (kMicro >= 0.02) {
                    kMicroEl.style.color = '#5cb85c'; // Green - good
                } else if (kMicro >= 0.01) {
                    kMicroEl.style.color = '#f0ad4e'; // Yellow - typical
                } else {
                    kMicroEl.style.color = '#d9534f'; // Red - poor
                }
                statsBarCache.set('kMicro', kMicroText);
            }
            
            // Calculate and update eCO2 stats
            // eCO2 sequestered from biochar: biocharProduced * biocharCaptureFactor
            // eCO2 sequestered from biochar (negative = removed from atmosphere)
            liveStats.eco2Sequestered = -(liveStats.biocharProduced * eco2Factors.biocharCaptureFactor);
            const eco2SeqText = liveStats.eco2Sequestered.toFixed(2);
            const eco2SeqEl = document.getElementById('liveEco2Sequestered');
            if (statsBarCache.get('eco2Seq') !== eco2SeqText) {
                eco2SeqEl.textContent = eco2SeqText;
                statsBarCache.set('eco2Seq', eco2SeqText);
            }
            
            // eCO2 avoided from woodgas (negative = removed from atmosphere)
            // Note: woodgas is now tracked in cubic meters (m¬≥)
            liveStats.eco2Avoided = -(liveStats.woodgasConsumed * eco2Factors.woodgasAvoidanceFactor);
            const eco2AvdText = liveStats.eco2Avoided.toFixed(2);
            const eco2AvdEl = document.getElementById('liveEco2Avoided');
            if (statsBarCache.get('eco2Avd') !== eco2AvdText) {
                eco2AvdEl.textContent = eco2AvdText;
                statsBarCache.set('eco2Avd', eco2AvdText);
            }
            
            // Total eCO2 saved: sequestered + avoided (both negative)
            liveStats.eco2TotalSaved = liveStats.eco2Sequestered + liveStats.eco2Avoided;
            const eco2TotalText = liveStats.eco2TotalSaved.toFixed(2);
            const eco2TotalEl = document.getElementById('liveEco2TotalSaved');
            if (statsBarCache.get('eco2Total') !== eco2TotalText) {
                eco2TotalEl.textContent = eco2TotalText;
                statsBarCache.set('eco2Total', eco2TotalText);
            }
            
            // Update eCO2 editor calculations if editor is visible
            if (!eco2FactorsSection.classList.contains('hidden')) {
                updateEco2Calculations();
            }
            
            // Update resource stats (only net resources)
            const netResources = getNetResources();
            const netResourceTypes = netResources.map(r => r.resourceType);
            const existingResourceStats = Array.from(resourceStatsContainer.children);
            
            // Phase 3: Remove stats for resources that are no longer net resources
            existingResourceStats.forEach(statEl => {
                const resType = statEl.getAttribute('data-resource-type');
                if (!netResourceTypes.includes(resType)) {
                    statEl.remove();
                    statsBarCache.delete(`resource-${resType}`);
                }
            });
            
            // Phase 3: Add or update stats for current net resources with change detection
            netResources.forEach(resource => {
                const resType = resource.resourceType;
                let statEl = resourceStatsContainer.querySelector(`[data-resource-type="${resType}"]`);
                
                if (!statEl) {
                    // Create new stat item
                    statEl = document.createElement('div');
                    statEl.className = 'stat-item';
                    statEl.setAttribute('data-resource-type', resType);
                    const unit = getDefaultUnitForResource(resType);
                    statEl.innerHTML = `
                        <div class="stat-label">${resource.label}</div>
                        <div class="stat-value large resource-stat-value">0.00</div>
                        <div class="stat-unit">${unit}</div>
                    `;
                    resourceStatsContainer.appendChild(statEl);
                } else {
                    // Update label in case it changed
                    const labelEl = statEl.querySelector('.stat-label');
                    if (labelEl && labelEl.textContent !== resource.label) {
                        labelEl.textContent = resource.label;
                    }
                    // Ensure unit label exists
                    let unitEl = statEl.querySelector('.stat-unit');
                    if (!unitEl) {
                        unitEl = document.createElement('div');
                        unitEl.className = 'stat-unit';
                        statEl.appendChild(unitEl);
                    }
                    const unit = getDefaultUnitForResource(resType);
                    if (unitEl.textContent !== unit) {
                        unitEl.textContent = unit;
                    }
                }
                
                // Phase 3: Update value (net: produced - consumed) only if changed
                const produced = liveStats.resourcesProduced[resType] || 0;
                const consumed = liveStats.resourcesConsumed[resType] || 0;
                const net = produced - consumed;
                const netText = net.toFixed(2);
                const netColor = net >= 0 ? '#5cb85c' : '#d9534f';
                const cacheKey = `resource-${resType}`;
                const cachedValue = statsBarCache.get(cacheKey);
                
                if (cachedValue !== netText || statsBarCache.get(`${cacheKey}-color`) !== netColor) {
                    const valueEl = statEl.querySelector('.resource-stat-value');
                    valueEl.textContent = netText;
                    valueEl.style.color = netColor;
                    statsBarCache.set(cacheKey, netText);
                    statsBarCache.set(`${cacheKey}-color`, netColor);
                }
            });
            
            // Auto-scale all stat items to fit text (use setTimeout to ensure DOM is updated)
            setTimeout(() => {
                const statsBar = document.getElementById('statsBar');
                const allStatItems = statsBar.querySelectorAll('.stat-item');
                allStatItems.forEach(statItem => {
                    autoScaleStatText(statItem);
                });
            }, 0);
        }

        const NODE_TYPES = { RESOURCE_DISPLAY: 'resource-display', PROCESSOR: 'processor', SOLAR_ARRAY: 'solar-array' };
        
        // Two-tier resource system:
        // - Core types (POWER, WATER, HEAT): Strict type checking, can only connect to same type
        // - USER_DEFINED: Flexible, can connect to any other USER_DEFINED port
        const RESOURCE_TYPES = { 
            // Core types (strict matching)
            POWER: 'Power', 
            WATER: 'Water',
            HEAT: 'Heat',
            // Flexible type (connects to any non-core)
            USER_DEFINED: 'User Defined',
            // Legacy types (mapped to USER_DEFINED for compatibility)
            PLASTIC: 'Plastic', 
            PLASTIC_FLAKES: 'Plastic Flakes', 
            WIND_TURBINES: 'Wind Turbines', 
            BIOMASS: 'Biomass', 
            POOP_GAS: 'Woodgas', 
            BIOCHAR: 'Biochar', 
            CUSTOM_PRODUCT_A: 'Custom Product A', 
            CUSTOM_PRODUCT_B: 'Custom Product B' 
        };
        
        // Core resource types that require strict type matching
        const CORE_RESOURCE_TYPES = [RESOURCE_TYPES.POWER, RESOURCE_TYPES.WATER, RESOURCE_TYPES.HEAT];
        
        // Check if a resource type is a core type (requires strict matching)
        function isCoreResourceType(resourceType) {
            return CORE_RESOURCE_TYPES.includes(resourceType);
        }
        
        // Check if two ports can be connected based on resource type rules
        function canConnectPorts(sourcePort, targetPort) {
            const srcType = sourcePort.resourceType;
            const tgtType = targetPort.resourceType;
            
            const srcIsCore = isCoreResourceType(srcType);
            const tgtIsCore = isCoreResourceType(tgtType);
            
            // If either port is a core type, they must match exactly
            if (srcIsCore || tgtIsCore) {
                return srcType === tgtType;
            }
            
            // Non-core (user-defined, legacy types, custom products) can connect to any other non-core port
            return true;
        }
        
        const DEFAULT_NODE_WIDTH = 220;  // Width for resource display nodes (square for IBC)
        const DEFAULT_NODE_WIDTH_PROCESSOR = 280;  // Wider, more square processors for better image/text display
        const DEFAULT_NODE_HEIGHT_RESOURCE = 220;  // Square height for IBC containers (220x220)
        const DEFAULT_NODE_HEIGHT_BATTERY = 280;  // Keep battery at original height
        const DEFAULT_NODE_HEIGHT_PROCESSOR = 280;  // Square processors (280x280) to distinguish from containers
        const DEFAULT_NODE_HEIGHT_SOLAR = 300;  // Height for solar arrays
        const CAPACITY_BAR_WIDTH = 12; const CAPACITY_BAR_PADDING = 5;
        const PORT_HANDLE_RADIUS = 13; const PORT_TEXT_OFFSETX = PORT_HANDLE_RADIUS + 12; const PORT_TEXT_OFFSETY = 5;  // Larger ports for better visibility 

        // Resource colors - core types get distinct colors, user-defined gets neutral
        const RESOURCE_COLORS = {
            [RESOURCE_TYPES.POWER]: '#ff0000',        // Red for electrical power
            [RESOURCE_TYPES.WATER]: '#0088ff',        // Blue for water
            [RESOURCE_TYPES.HEAT]: '#ff8800',         // Orange for heat
            [RESOURCE_TYPES.USER_DEFINED]: '#888888', // Gray for user-defined
            // Legacy colors for backward compatibility
            [RESOURCE_TYPES.BIOCHAR]: '#333333',      // Dark gray for Biochar
            [RESOURCE_TYPES.POOP_GAS]: '#d3d3d3',     // Light Gray for Woodgas
            [RESOURCE_TYPES.BIOMASS]: '#228b22',      // Forest green for Biomass
            [RESOURCE_TYPES.PLASTIC]: '#daa520',      // Goldenrod for Plastic
            [RESOURCE_TYPES.PLASTIC_FLAKES]: '#daa520', // Goldenrod for Plastic Flakes
            [RESOURCE_TYPES.WIND_TURBINES]: '#708090' // Slate gray for products
        };

        function createNode(type, options = {}) {
            nodeIdCounter++;
            let defaultImg = null;
            if (svgWidth === undefined) updateSvgDimensions();

            const baseNode = {
                id: `node-${nodeIdCounter}`,
                x: options.x || Math.random()*(svgWidth-200)+50,
                y: options.y || Math.random()*(svgHeight-200)+50,
                ports: [],
                width: options.width || (type === NODE_TYPES.PROCESSOR ? DEFAULT_NODE_WIDTH_PROCESSOR : DEFAULT_NODE_WIDTH),
                height: options.height || (type === NODE_TYPES.PROCESSOR ? DEFAULT_NODE_HEIGHT_PROCESSOR : (type === NODE_TYPES.SOLAR_ARRAY ? DEFAULT_NODE_HEIGHT_SOLAR : (type === NODE_TYPES.RESOURCE_DISPLAY && options.subType === 'BatteryBank' ? DEFAULT_NODE_HEIGHT_BATTERY : DEFAULT_NODE_HEIGHT_RESOURCE))),
                label: options.label || 'Default Label',
                img: options.img || defaultImg,
                canProcessLastStep: false,
                type: type,
                maxCapacity: options.maxCapacity || null,
                progressColor: options.progressColor || '#6fa06c',
                // Batch properties (for processors)
                batchDuration: options.batchDuration || 6,
                batchTimeElapsed: 0,
                isInBatch: false,
                awaitingBatchInputs: false,
                automations: options.automations || [],
                flipped: options.flipped || false,
                portOrientation: options.portOrientation || 'vertical',  // 'vertical' (top/bottom) or 'horizontal' (left/right)
                ...options
            };
            let newNode;
            switch (type) {
                case NODE_TYPES.RESOURCE_DISPLAY:
                    newNode = {
                        ...baseNode, 
                        value: options.value || 0, 
                        unit: options.unit || 'Units', 
                        resourceType: options.resourceType || RESOURCE_TYPES.CUSTOM_PRODUCT_A,
                        isExternal: options.isExternal || false,
                        passiveGeneration: options.passiveGeneration || 0,
                        ports: []
                    };

                    // Standardize container node creation
                    if (options.subType) {
                        const containerConfig = {
                            'PlasticTrash': {
                                label: 'PLASTIC TRASH',
                                unit: 'Kilograms',
                                resourceType: RESOURCE_TYPES.PLASTIC,
                                isSource: true,
                                passiveGeneration: 5,
                                ports: [{id: `p-${nodeIdCounter}-out-0`, type: 'output', resourceType: RESOURCE_TYPES.PLASTIC, name: 'Plastic Out', side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}]
                            },
                            'PlasticFlakes': {
                                label: 'PLASTIC FLAKES',
                                unit: 'Kilograms',
                                resourceType: RESOURCE_TYPES.PLASTIC_FLAKES,
                                maxCapacity: 50,
                                ports: [
                                    {id: `p-${nodeIdCounter}-in-0`, type: 'input', resourceType: RESOURCE_TYPES.PLASTIC_FLAKES, name: 'Flakes In', side: 'top', xOffsetRatio: 0.5, yOffsetRatio: 0.5},
                                    {id: `p-${nodeIdCounter}-out-0`, type: 'output', resourceType: RESOURCE_TYPES.PLASTIC_FLAKES, name: 'Flakes Out', side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}
                                ]
                            },
                            'WindTurbines': {
                                label: 'WIND TURBINES',
                                unit: 'Kilograms',
                                resourceType: RESOURCE_TYPES.WIND_TURBINES,
                                ports: [{id: `p-${nodeIdCounter}-in-0`, type: 'input', resourceType: RESOURCE_TYPES.WIND_TURBINES, name: 'Turbines In', side: 'top', xOffsetRatio: 0.5, yOffsetRatio: 0.5}]
                            },
                            'BatteryBank': {
                                label: 'BATTERY BANK',
                                unit: 'kWh',
                                resourceType: RESOURCE_TYPES.POWER,
                                passiveGeneration: 0,
                                maxCapacity: 10.8,
                                ports: [
                                    {id: `p-${nodeIdCounter}-in-power`, type: 'input', resourceType: RESOURCE_TYPES.POWER, name: 'Charge In', side: 'top', xOffsetRatio: 0.5, yOffsetRatio: 0.5},
                                    {id: `p-${nodeIdCounter}-out-power`, type: 'output', resourceType: RESOURCE_TYPES.POWER, name: 'Power Out', side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}
                                ]
                            },
                            'Biomass': {
                                label: 'BIOMASS',
                                unit: 'kg',
                                resourceType: RESOURCE_TYPES.BIOMASS,
                                isSource: true,
                                passiveGeneration: 2,
                                ports: [{id: `p-${nodeIdCounter}-out-0`, type: 'output', resourceType: RESOURCE_TYPES.BIOMASS, name: 'Biomass Out', side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}]
                            },
                            'PoopGas': {
                                label: 'WOODGAS',
                                unit: 'Cubic Meters',
                                resourceType: RESOURCE_TYPES.POOP_GAS,
                                maxCapacity: 10,
                                ports: [
                                    {id: `p-${nodeIdCounter}-in-0`, type: 'input', resourceType: RESOURCE_TYPES.POOP_GAS, name: 'Gas In', side: 'top', xOffsetRatio: 0.5, yOffsetRatio: 0.5},
                                    {id: `p-${nodeIdCounter}-out-0`, type: 'output', resourceType: RESOURCE_TYPES.POOP_GAS, name: 'Gas Out', side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}
                                ]
                            },
                            'Biochar': {
                                label: 'BIOCHAR',
                                unit: 'kg',
                                resourceType: RESOURCE_TYPES.BIOCHAR,
                                maxCapacity: 50,
                                ports: [
                                    {id: `p-${nodeIdCounter}-in-0`, type: 'input', resourceType: RESOURCE_TYPES.BIOCHAR, name: 'Biochar In', side: 'top', xOffsetRatio: 0.5, yOffsetRatio: 0.5},
                                    {id: `p-${nodeIdCounter}-out-0`, type: 'output', resourceType: RESOURCE_TYPES.BIOCHAR, name: 'Biochar Out', side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}
                                ]
                            }
                        };

                        const config = containerConfig[options.subType];
                        if (config) {
                            // Merge config first, then options to allow overrides
                            newNode = { ...newNode, ...config };
                            // Allow options to override config defaults (e.g., maxCapacity, value, label)
                            if (options.maxCapacity !== undefined) newNode.maxCapacity = options.maxCapacity;
                            if (options.value !== undefined) newNode.value = options.value;
                            if (options.label !== undefined) newNode.label = options.label;
                        }
                    } else if (options.subType === 'CustomContainer') {
                        newNode = {
                            ...baseNode,
                            value: 0,
                            unit: options.unit || 'Units',
                            resourceType: options.resourceType || RESOURCE_TYPES.CUSTOM_PRODUCT_A,
                            maxCapacity: options.maxCapacity || null,
                            ports: [
                                {id: `p-${nodeIdCounter}-in-0`, type: 'input', resourceType: options.resourceType || RESOURCE_TYPES.CUSTOM_PRODUCT_A, name: `${options.label || 'Custom'} In`, side: 'top', xOffsetRatio: 0.5, yOffsetRatio: 0.5},
                                {id: `p-${nodeIdCounter}-out-0`, type: 'output', resourceType: options.resourceType || RESOURCE_TYPES.CUSTOM_PRODUCT_A, name: `${options.label || 'Custom'} Out`, side: 'bottom', xOffsetRatio: 0.5, yOffsetRatio: 0.5}
                            ]
                        };
                    }
                    break;
                case NODE_TYPES.PROCESSOR: 
                     newNode = {...baseNode, isRunning:false, config:{inputs:[], outputs:[]}, ...options};
                     if (options.subType === 'Shredder') { newNode = {...newNode, label:'SHREDDER', config:{inputs:[{name:'PLASTIC TRASH',resourceType:RESOURCE_TYPES.PLASTIC,rate:1},{name:'POWER',resourceType:RESOURCE_TYPES.POWER,rate:0.3}], outputs:[{name:'SHREDDED PLASTIC',resourceType:RESOURCE_TYPES.PLASTIC_FLAKES,rate:1}]}}; }
                     if (options.subType === 'TrashPrinter') { newNode = {...newNode, label:'TRASH PRINTER', config:{inputs:[{name:'SHREDDED PLASTIC',resourceType:RESOURCE_TYPES.PLASTIC_FLAKES,rate:0.2},{name:'POWER',resourceType:RESOURCE_TYPES.POWER,rate:0.2}], outputs:[{name:'WIND TURBINES',resourceType:RESOURCE_TYPES.WIND_TURBINES,rate:0.2}]}}; }
                     if (options.subType === 'BiocharReactor') { 
                         newNode = {...newNode, label:'BIOCHAR REACTOR', batchDuration: 6,
                                    config:{inputs:[{name:'POWER',resourceType:RESOURCE_TYPES.POWER,rate:1, isBatchIO: false}, {name:'BIOMASS',resourceType:RESOURCE_TYPES.BIOMASS,rate:5, isBatchIO: true}], 
                                            outputs:[{name:'WOODGAS',resourceType:RESOURCE_TYPES.POOP_GAS,rate:0.25, isBatchIO: false}, {name:'BIOCHAR',resourceType:RESOURCE_TYPES.BIOCHAR,rate:1, isBatchIO: true}]}}; 
                     }
                     // ========== APPLIANCE LIBRARY ==========
                     // Power rates are average kWh consumed per hour when running
                     // Batch appliances: batchDuration = hours to complete, power rate = kW during batch
                     
                     // Kitchen Appliances
                     // Microwave: 1.2kW peak, used ~5min/use, ~3 uses/day = 0.3 kWh/day. Batch: 5min = 0.083hr
                     if (options.subType === 'Microwave') { 
                         newNode = {...newNode, label:'MICROWAVE', img:'üçø', batchDuration:0.067, 
                             recipes: [
                                 { name: 'Popcorn', durationHrs: 0.067, powerRate: 1.2, inputItems: [{name: 'Popcorn Bag', qty: 1}], outputItems: [{name: 'Popped Popcorn', qty: 1}] },
                                 { name: 'Reheat Leftovers', durationHrs: 0.05, powerRate: 1.2, inputItems: [{name: 'Cold Food', qty: 1}], outputItems: [{name: 'Hot Food', qty: 1}] },
                                 { name: 'Frozen Burrito', durationHrs: 0.033, powerRate: 1.2, inputItems: [{name: 'Frozen Burrito', qty: 1}], outputItems: [{name: 'Hot Burrito', qty: 1}] }
                             ],
                             config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.2,isBatchIO:false}], outputs:[]}
                         }; 
                         // Update ports from recipes
                         updateNodePortsFromRecipes(newNode);
                     }
                     // Electric Kettle: 1.5kW, ~5min to boil = 0.125 kWh/use
                     if (options.subType === 'ElectricKettle') { newNode = {...newNode, label:'ELECTRIC KETTLE', img:'ü´ñ', batchDuration:0.083, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.5,isBatchIO:false}], outputs:[{name:'Hot Water (L)',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1.5,isBatchIO:true}]}}; }
                     // Toaster: 0.9kW, ~3min/use
                     if (options.subType === 'Toaster') { 
                         newNode = {...newNode, label:'TOASTER', img:'üçû', batchDuration:0.05, 
                             recipes: [
                                 { name: 'Toast (2 slices)', durationHrs: 0.05, powerRate: 0.9, inputItems: [{name: 'Bread Slices', qty: 2}], outputItems: [{name: 'Toast', qty: 2}] },
                                 { name: 'Bagel', durationHrs: 0.067, powerRate: 0.9, inputItems: [{name: 'Bagel', qty: 1}], outputItems: [{name: 'Toasted Bagel', qty: 1}] }
                             ],
                             config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.9,isBatchIO:false}], outputs:[]}
                         }; 
                         updateNodePortsFromRecipes(newNode);
                     }
                     // Coffee Maker: 0.8kW, ~10min brew cycle
                     if (options.subType === 'CoffeeMaker') { 
                         newNode = {...newNode, label:'COFFEE MAKER', img:'‚òï', batchDuration:0.17, 
                             recipes: [
                                 { name: 'Single Cup', durationHrs: 0.033, powerRate: 0.8, inputItems: [{name: 'Coffee Grounds', qty: 0.02}, {name: 'Water', qty: 0.25}], outputItems: [{name: 'Hot Coffee', qty: 1}] },
                                 { name: 'Full Pot', durationHrs: 0.17, powerRate: 0.8, inputItems: [{name: 'Coffee Grounds', qty: 0.1}, {name: 'Water', qty: 1.5}], outputItems: [{name: 'Hot Coffee', qty: 8}] }
                             ],
                             recipeAutomations: [{recipeIndex: 1, triggerType: 'timeOfDay', startHour: 6, endHour: 7}],
                             config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.8,isBatchIO:false}], outputs:[]}
                         }; 
                         updateNodePortsFromRecipes(newNode);
                     }
                     // Refrigerator: Cycles on/off, averages 0.05kW continuous (1.2 kWh/day)
                     if (options.subType === 'Refrigerator') { newNode = {...newNode, label:'REFRIGERATOR', img:'üßä', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.05}], outputs:[{name:'Cold Storage',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[]}; }
                     // Freezer: Similar to fridge, ~0.04kW average
                     if (options.subType === 'Freezer') { newNode = {...newNode, label:'FREEZER', img:'‚ùÑÔ∏è', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.04}], outputs:[{name:'Frozen Storage',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[]}; }
                     // Dishwasher: 1.8kW, 1hr cycle = 1.8 kWh/load
                     if (options.subType === 'Dishwasher') { newNode = {...newNode, label:'DISHWASHER', img:'üçΩÔ∏è', batchDuration:1, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.8,isBatchIO:false}], outputs:[{name:'Clean Dishes',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:13,endHour:14}]}; }
                     // Electric Stove: 2kW average (burners vary), ~1hr cooking/day
                     if (options.subType === 'ElectricStove') { newNode = {...newNode, label:'ELECTRIC STOVE', img:'üç≥', batchDuration:0.5, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:2.0,isBatchIO:false}], outputs:[{name:'Meals',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:7,endHour:8},{triggerType:'timeOfDay',action:'turnOn',startHour:12,endHour:13},{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:19}]}; }
                     // Blender: 0.4kW, ~2min/use
                     if (options.subType === 'Blender') { newNode = {...newNode, label:'BLENDER', img:'ü•§', batchDuration:0.033, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.4,isBatchIO:false}], outputs:[{name:'Smoothie',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}}; }
                     // Rice Cooker: 0.5kW, 30min cycle
                     if (options.subType === 'RiceCooker') { newNode = {...newNode, label:'RICE COOKER', img:'üçö', batchDuration:0.5, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.5,isBatchIO:false}], outputs:[{name:'Cooked Rice (cups)',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:6,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:17,endHour:18}]}; }
                     
                     // Laundry & Cleaning
                     // Washing Machine: 0.5kW average, 1hr cycle
                     if (options.subType === 'WashingMachine') { newNode = {...newNode, label:'WASHING MACHINE', img:'üëï', batchDuration:1, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.5,isBatchIO:false}], outputs:[{name:'Clean Loads',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:10,endHour:14}]}; }
                     // Clothes Dryer: 3kW, 1hr cycle = 3 kWh/load (biggest energy hog!)
                     if (options.subType === 'ClothesDryer') { newNode = {...newNode, label:'CLOTHES DRYER', img:'üåÄ', batchDuration:1, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:3.0,isBatchIO:false}], outputs:[{name:'Dry Loads',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:11,endHour:15}]}; }
                     // Vacuum: 1.4kW, ~30min/use
                     if (options.subType === 'VacuumCleaner') { newNode = {...newNode, label:'VACUUM CLEANER', img:'üßπ', batchDuration:0.5, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.4,isBatchIO:false}], outputs:[{name:'Rooms Cleaned',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:4,isBatchIO:true}]}}; }
                     // Iron: 1.2kW, ~30min/use
                     if (options.subType === 'Iron') { newNode = {...newNode, label:'IRON', img:'üëî', batchDuration:0.5, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.2,isBatchIO:false}], outputs:[{name:'Pressed Items',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:6,isBatchIO:true}]}}; }
                     
                     // Climate Control (continuous loads - rate = average kW when running)
                     // AC: 1.5kW when compressor runs, but cycles. Avg 0.8kW over an hour of "on" time
                     if (options.subType === 'AirConditioner') { newNode = {...newNode, label:'AIR CONDITIONER', img:'‚ùÑÔ∏è', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.0}], outputs:[{name:'BTU Cooling',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:12000}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:12,endHour:20}]}; }
                     // Space Heater: 1.5kW continuous when on
                     if (options.subType === 'SpaceHeater') { newNode = {...newNode, label:'SPACE HEATER', img:'üî•', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.5}], outputs:[{name:'BTU Heat',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:5000}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:6,endHour:9},{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:22}]}; }
                     // Ceiling Fan: 0.075kW continuous
                     if (options.subType === 'CeilingFan') { newNode = {...newNode, label:'CEILING FAN', img:'üåÄ', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.075}], outputs:[{name:'Air Circulation',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:10,endHour:22}]}; }
                     // Portable Fan: 0.03kW
                     if (options.subType === 'PortableFan') { newNode = {...newNode, label:'PORTABLE FAN', img:'üí®', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.03}], outputs:[{name:'Air Flow',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}}; }
                     // Dehumidifier: 0.3kW continuous
                     if (options.subType === 'Dehumidifier') { newNode = {...newNode, label:'DEHUMIDIFIER', img:'üíß', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.3}], outputs:[{name:'Water Removed (L)',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:0.5}]}}; }
                     // Humidifier: 0.04kW
                     if (options.subType === 'Humidifier') { newNode = {...newNode, label:'HUMIDIFIER', img:'üå´Ô∏è', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.04}], outputs:[{name:'Humidity Added',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}}; }
                     
                     // Water Heating
                     // Tank Water Heater: 4.5kW element, but only runs ~3hrs/day to maintain temp. Avg 0.5kW/hr over 24hrs
                     if (options.subType === 'WaterHeater') { newNode = {...newNode, label:'WATER HEATER', img:'üöø', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.5}], outputs:[{name:'Hot Water (gal)',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:2}]}}; }
                     // Tankless/Instant: 3kW but only when water flows. Batch per shower ~10min
                     if (options.subType === 'InstantWaterHeater') { newNode = {...newNode, label:'TANKLESS HEATER', img:'üî•', batchDuration:0.17, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:3.0,isBatchIO:false}], outputs:[{name:'Hot Showers',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:6,endHour:8},{triggerType:'timeOfDay',action:'turnOn',startHour:20,endHour:22}]}; }
                     // Well Pump: 0.75kW, runs intermittently. ~0.1kW average
                     if (options.subType === 'WaterPump') { newNode = {...newNode, label:'WATER PUMP', img:'üí¶', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.1}], outputs:[{name:'Water (gal)',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:60}]}}; }
                     
                     // Lighting (continuous - rate = kW when on)
                     // LED: 10W bulb
                     if (options.subType === 'LEDLights') { newNode = {...newNode, label:'LED LIGHTS', img:'üí°', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.01}], outputs:[{name:'Lumens',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:800}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:23}]}; }
                     // CFL: 15W
                     if (options.subType === 'CFLBulb') { newNode = {...newNode, label:'CFL BULB', img:'üí°', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.015}], outputs:[{name:'Lumens',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:900}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:23}]}; }
                     // Incandescent: 60W
                     if (options.subType === 'IncandescentBulb') { newNode = {...newNode, label:'INCANDESCENT', img:'üí°', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.06}], outputs:[{name:'Lumens',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:700}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:23}]}; }
                     // Outdoor Floodlight: 50W LED
                     if (options.subType === 'Floodlight') { newNode = {...newNode, label:'FLOODLIGHT', img:'üî¶', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.05}], outputs:[{name:'Lumens',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:4000}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:19,endHour:6}]}; }
                     
                     // Electronics & Office
                     // Phone Charger: 20W for ~2hrs = 0.04 kWh/charge. Batch model
                     if (options.subType === 'PhoneCharger') { newNode = {...newNode, label:'PHONE CHARGER', img:'üì±', batchDuration:2, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.02,isBatchIO:false}], outputs:[{name:'Phones Charged',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:22,endHour:6}]}; }
                     // Laptop: 50W average when in use
                     if (options.subType === 'Laptop') { newNode = {...newNode, label:'LAPTOP', img:'üíª', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.05}], outputs:[{name:'Computing Hours',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:9,endHour:17}]}; }
                     // Desktop PC: 150W average
                     if (options.subType === 'DesktopPC') { newNode = {...newNode, label:'DESKTOP PC', img:'üñ•Ô∏è', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.15}], outputs:[{name:'Computing Hours',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:9,endHour:17}]}; }
                     // Gaming PC: 350W average under load
                     if (options.subType === 'GamingPC') { newNode = {...newNode, label:'GAMING PC', img:'üéÆ', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.35}], outputs:[{name:'Gaming Hours',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:23}]}; }
                     // Monitor: 25W
                     if (options.subType === 'Monitor') { newNode = {...newNode, label:'MONITOR', img:'üñ•Ô∏è', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.025}], outputs:[{name:'Display Hours',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}}; }
                     // TV: 100W for 55" LED
                     if (options.subType === 'TV') { newNode = {...newNode, label:'TELEVISION', img:'üì∫', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.1}], outputs:[{name:'Viewing Hours',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:23}]}; }
                     // Game Console: 120W average
                     if (options.subType === 'GameConsole') { newNode = {...newNode, label:'GAME CONSOLE', img:'üéÆ', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.12}], outputs:[{name:'Gaming Hours',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:18,endHour:22}]}; }
                     // WiFi Router: 10W 24/7
                     if (options.subType === 'WiFiRouter') { newNode = {...newNode, label:'WIFI ROUTER', img:'üì∂', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.01}], outputs:[{name:'Internet Uptime',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1}]}}; }
                     // Printer: 30W when printing, standby 3W. Avg 5W
                     if (options.subType === 'Printer') { newNode = {...newNode, label:'PRINTER', img:'üñ®Ô∏è', batchDuration:0.05, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.03,isBatchIO:false}], outputs:[{name:'Pages',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:10,isBatchIO:true}]}}; }
                     
                     // Personal Care (short duration, batch)
                     // Hair Dryer: 1.8kW, ~10min use
                     if (options.subType === 'HairDryer') { newNode = {...newNode, label:'HAIR DRYER', img:'üíá', batchDuration:0.17, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.8,isBatchIO:false}], outputs:[{name:'Dry Hair',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:7,endHour:8}]}; }
                     // Electric Shaver: 15W, ~5min
                     if (options.subType === 'ElectricShaver') { newNode = {...newNode, label:'ELECTRIC SHAVER', img:'ü™í', batchDuration:0.083, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.015,isBatchIO:false}], outputs:[{name:'Shaves',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:7,endHour:8}]}; }
                     // Curling Iron: 50W, ~15min
                     if (options.subType === 'CurlingIron') { newNode = {...newNode, label:'CURLING IRON', img:'üíá', batchDuration:0.25, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.05,isBatchIO:false}], outputs:[{name:'Styled Hair',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}}; }
                     
                     // Power Tools (intermittent use, batch)
                     // Drill: 800W, ~5min active use per project hour
                     if (options.subType === 'Drill') { newNode = {...newNode, label:'ELECTRIC DRILL', img:'üîß', batchDuration:0.083, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.8,isBatchIO:false}], outputs:[{name:'Holes Drilled',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:20,isBatchIO:true}]}}; }
                     // Circular Saw: 1.4kW, ~10min cuts
                     if (options.subType === 'CircularSaw') { newNode = {...newNode, label:'CIRCULAR SAW', img:'ü™ö', batchDuration:0.17, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.4,isBatchIO:false}], outputs:[{name:'Cuts Made',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:10,isBatchIO:true}]}}; }
                     // Angle Grinder: 1kW, ~10min
                     if (options.subType === 'AngleGrinder') { newNode = {...newNode, label:'ANGLE GRINDER', img:'‚öôÔ∏è', batchDuration:0.17, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.0,isBatchIO:false}], outputs:[{name:'Material Ground',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}}; }
                     // Air Compressor: 1.5kW to fill, then cycles. Avg 0.3kW when in use
                     if (options.subType === 'AirCompressor') { newNode = {...newNode, label:'AIR COMPRESSOR', img:'üí®', config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.3}], outputs:[{name:'PSI Maintained',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:100}]}}; }
                     
                     // EV & Transport (long duration charging)
                     // EV L1: 1.4kW, typically overnight 8hrs = 11 kWh, ~40 miles range
                     if (options.subType === 'EVChargerL1') { newNode = {...newNode, label:'EV CHARGER L1', img:'üîå', batchDuration:8, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:1.4,isBatchIO:false}], outputs:[{name:'Miles Range',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:40,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:22,endHour:6}]}; }
                     // EV L2: 7.2kW, 4hrs for full charge = ~29 kWh, ~100 miles
                     if (options.subType === 'EVChargerL2') { newNode = {...newNode, label:'EV CHARGER L2', img:'‚ö°', batchDuration:4, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:7.2,isBatchIO:false}], outputs:[{name:'Miles Range',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:100,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:22,endHour:6},{triggerType:'batteryLevel',action:'turnOn',targetNodeLabel:'BATTERY BANK',threshold:80,condition:'above'}]}; }
                     // E-Bike: 0.3kW, 4hrs for full charge = 1.2 kWh
                     if (options.subType === 'EBikeCharger') { newNode = {...newNode, label:'E-BIKE CHARGER', img:'üö≤', batchDuration:4, config:{inputs:[{name:'Power',resourceType:RESOURCE_TYPES.POWER,rate:0.3,isBatchIO:false}], outputs:[{name:'Bike Charges',resourceType:RESOURCE_TYPES.CUSTOM_PRODUCT_A,rate:1,isBatchIO:true}]}, automations:[{triggerType:'timeOfDay',action:'turnOn',startHour:22,endHour:6}]}; }
                     // ========== END APPLIANCE LIBRARY ==========
                     if (options.subType === 'CustomProcessor') { newNode = {...newNode, label:options.label||'CUSTOM PROC', config:options.config||{inputs:[],outputs:[]}}; }
                     regeneratePortsForNode(newNode);
                     break;
                case NODE_TYPES.SOLAR_ARRAY: const solarFlipped = options.flipped || false; const solarOrientation = options.portOrientation || 'vertical'; newNode = { ...baseNode, label: 'SOLAR ARRAY', ratedOutput: options.ratedOutput || 2.4, currentOutput: 0, config: { inputs: [], outputs: [{ portId: `p-${nodeIdCounter}-out-solar`, name: 'Solar Power', resourceType: RESOURCE_TYPES.POWER, rate: 0 }] }, ports: [{id:`p-${nodeIdCounter}-out-solar`,type:'output',resourceType:RESOURCE_TYPES.POWER,name:'Power Out',side:solarOrientation === 'vertical' ? (solarFlipped?'top':'bottom') : (solarFlipped?'left':'right'),xOffsetRatio:0.5,yOffsetRatio:0.5}] }; break;
                default: console.error("Unknown type:", type, options); return null; 
            } 
            return newNode; 
        }
        function regeneratePortsForNode(node){ 
            if (node.type !== NODE_TYPES.PROCESSOR) return; 
            node.ports = []; 
            const inputCfgs = node.config.inputs || []; 
            const outputCfgs = node.config.outputs || []; 
            const isFlipped = node.flipped || false;
            const orientation = node.portOrientation || 'vertical';
            
            if (orientation === 'vertical') {
                // Top/bottom orientation: inputs on top, outputs on bottom (flipped reverses)
                let inputPortXRatioStep = 1 / (inputCfgs.length + 1);
                inputCfgs.forEach((inp,idx)=>{
                    inp.portId=`p-${node.id}-in-${idx}`;
                    node.ports.push({
                        id:inp.portId,
                        type:'input',
                        resourceType:inp.resourceType,
                        name:inp.name,
                        side:isFlipped?'bottom':'top',
                        xOffsetRatio:inputPortXRatioStep*(idx+1),
                        yOffsetRatio:0.5
                    });
                });
                let outputPortXRatioStep = 1 / (outputCfgs.length + 1);
                outputCfgs.forEach((out,idx)=>{
                    out.portId=`p-${node.id}-out-${idx}`;
                    node.ports.push({
                        id:out.portId,
                        type:'output',
                        resourceType:out.resourceType,
                        name:out.name,
                        side:isFlipped?'top':'bottom',
                        xOffsetRatio:outputPortXRatioStep*(idx+1),
                        yOffsetRatio:0.5
                    });
                });
            } else {
                // Left/right orientation (horizontal): inputs on left, outputs on right
                let inputPortYRatioStep = 1 / (inputCfgs.length + 1);
                inputCfgs.forEach((inp,idx)=>{
                    inp.portId=`p-${node.id}-in-${idx}`;
                    node.ports.push({
                        id:inp.portId,
                        type:'input',
                        resourceType:inp.resourceType,
                        name:inp.name,
                        side:isFlipped?'right':'left',
                        yOffsetRatio:inputPortYRatioStep*(idx+1),
                        xOffsetRatio:0.5
                    });
                });
                let outputPortYRatioStep = 1 / (outputCfgs.length + 1);
                outputCfgs.forEach((out,idx)=>{
                    out.portId=`p-${node.id}-out-${idx}`;
                    node.ports.push({
                        id:out.portId,
                        type:'output',
                        resourceType:out.resourceType,
                        name:out.name,
                        side:isFlipped?'left':'right',
                        yOffsetRatio:outputPortYRatioStep*(idx+1),
                        xOffsetRatio:0.5
                    });
                });
            }
        }

        // Phase 1: Render batching with requestAnimationFrame
        let renderScheduled = false;
        let pendingRender = false;
        
        function scheduleRender() {
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    render();
                    pendingRender = false;
                    renderScheduled = false;
                });
            } else {
                pendingRender = true;
            }
        }
        
        function render() {
            renderNodes();
            renderConnections();
            updateTimeDisplay();
            pendingRender = false;
        }

        function getAbsPortPosition(node, port) {
            const orientation = node.portOrientation || 'vertical';
            let absX = node.x;
            let absY = node.y;
            
            if (orientation === 'vertical') {
                // Top/bottom orientation
                absX += node.width * (port.xOffsetRatio || 0.5);
                if (port.side === 'top') absY += 0;
                else if (port.side === 'bottom') absY += node.height;
                else {
                    // Fallback: use yOffsetRatio for backwards compatibility
                    absY += node.height * (port.yOffsetRatio || 0.5);
                }
            } else {
                // Left/right orientation (horizontal)
                absY += node.height * (port.yOffsetRatio || 0.5);
                if (port.side === 'left') absX += 0;
                else if (port.side === 'right') absX += node.width;
            }
            return { x: absX, y: absY };
        }

        // Helper function to wrap text and create multi-line SVG text elements
        function wrapText(selection, text, maxWidth, fontSize) {
            selection.each(function() {
                const textElement = d3.select(this);
                if (!text || text.trim() === "") {
                    textElement.text(null);
                    return;
                }
                
                const words = text.split(/\s+/).reverse();
                let word;
                let line = [];
                let lineNumber = 0;
                const lineHeight = fontSize * 1.2; // Line height based on font size
                const x = textElement.attr("x") || 0;
                const y = parseFloat(textElement.attr("y")) || 0;
                const textAnchor = textElement.style("text-anchor") || textElement.attr("text-anchor") || "middle";
                
                // Get parent styles to inherit
                const fill = textElement.style("fill") || textElement.attr("fill") || "#ffffff";
                const fontWeight = textElement.style("font-weight") || textElement.attr("font-weight") || "normal";
                const fontFamily = textElement.style("font-family") || "Arial, sans-serif";
                
                // Clear existing content (including all tspans)
                textElement.selectAll("tspan").remove();
                textElement.text(null);
                
                // Create temporary text element in the same SVG for accurate measurement
                const parentSvg = textElement.node().ownerSVGElement;
                const tempText = d3.select(parentSvg).append("text")
                    .style("font-size", fontSize + "px")
                    .style("font-weight", fontWeight)
                    .style("font-family", fontFamily)
                    .style("visibility", "hidden")
                    .style("position", "absolute");
                
                while (word = words.pop()) {
                    line.push(word);
                    tempText.text(line.join(" "));
                    const node = tempText.node();
                    const textLength = node ? node.getComputedTextLength() : 0;
                    
                    if (textLength > maxWidth && line.length > 1) {
                        line.pop();
                        tempText.text(line.join(" "));
                        const tspan = textElement.append("tspan")
                            .attr("x", x)
                            .style("text-anchor", textAnchor)
                            .style("fill", fill)
                            .style("font-weight", fontWeight)
                            .text(line.join(" "));
                        if (lineNumber === 0) {
                            tspan.attr("y", y);
                        } else {
                            tspan.attr("dy", lineHeight);
                        }
                        line = [word];
                        lineNumber++;
                    }
                }
                
                // Add the last line
                if (line.length > 0) {
                    const tspan = textElement.append("tspan")
                        .attr("x", x)
                        .style("text-anchor", textAnchor)
                        .style("fill", fill)
                        .style("font-weight", fontWeight)
                        .text(line.join(" "));
                    if (lineNumber === 0) {
                        tspan.attr("y", y);
                    } else {
                        tspan.attr("dy", lineHeight);
                    }
                }
                
                tempText.remove();
            });
        }

        // Phase 1: Removed duplicate renderNodes function - using the one defined earlier (line 1248)

        const inspectorSolarArrayFields = document.getElementById("inspectorSolarArrayFields");
        const inspectorBatchDurationField = document.getElementById("inspectorBatchDurationField"); const inspectorBatchDuration = document.getElementById("inspectorBatchDuration");
        const customBatchDuration = document.getElementById("customBatchDuration");
        const inspectorIsExternal = document.getElementById("inspectorIsExternal");


        function isBatchProcessor(node) {
            if (node.type !== NODE_TYPES.PROCESSOR || !node.config) return false;
            return (node.config.inputs || []).some(io => io.isBatchIO) || (node.config.outputs || []).some(io => io.isBatchIO);
        }

        // This selectNode function will be replaced by the one in the view management section
        // Keeping it here for backwards compatibility during initialization 
        function deselectNode(){ selectedNodeId=null;deselectInspector();scheduleRender();} 
        function deselectInspector(){ nodeInspectorSection.classList.add("hidden");nodeBuilderSection.classList.remove("hidden");inspectorNodeName.value="";inspectorNodeImageURL.value="";inspectorInputsContainer.innerHTML="";inspectorOutputsContainer.innerHTML="";inspectorNodeUnit.value="";inspectorPassiveRate.value=""; inspectorMaxCapacity.value = ""; inspectorSolarArrayFields.classList.add("hidden"); inspectorBatchDurationField.classList.add("hidden");} 
        svg.on("click",deselectNode); 
        function populateInspector(node){ inspectorNodeName.value=node.label;inspectorNodeImageURL.value=node.img||"";inspectorPortOrientation.value=node.portOrientation||'vertical';inspectorProcessorFields.classList.add("hidden");inspectorResourceDisplayFields.classList.add("hidden");inspectorSolarArrayFields.classList.add("hidden"); inspectorBatchDurationField.classList.add("hidden"); if(node.type===NODE_TYPES.PROCESSOR){inspectorProcessorFields.classList.remove("hidden"); if(isBatchProcessor(node)) { inspectorBatchDurationField.classList.remove("hidden"); inspectorBatchDuration.value = node.batchDuration || 6;} inspectorInputsContainer.innerHTML="";inspectorOutputsContainer.innerHTML="";(node.config.inputs||[]).forEach(input=>addIOFieldToInspector('input',input));(node.config.outputs||[]).forEach(output=>addIOFieldToInspector('output',output));}else if(node.type===NODE_TYPES.RESOURCE_DISPLAY){inspectorResourceDisplayFields.classList.remove("hidden");inspectorNodeUnit.value=node.unit||"";inspectorPassiveRate.value=node.passiveGeneration===undefined?0:node.passiveGeneration; inspectorMaxCapacity.value = node.maxCapacity || ""; inspectorProgressColor.value = node.progressColor || '#6fa06c'; inspectorIsExternal.checked = node.isExternal || false;}else if(node.type===NODE_TYPES.SOLAR_ARRAY){inspectorSolarArrayFields.classList.remove("hidden");inspectorRatedOutput.value=node.ratedOutput;inspectorCurrentOutput.textContent=`${node.currentOutput.toFixed(2)} kW`;} inspectorAutomationContainer.innerHTML="";(node.automations||[]).forEach(automation=>addAutomationFieldToInspector(automation)); populateRecipeInspector(node);} 
        
        function addIOFieldToInspector(type, data = {}) {
            inspectorIoItemIdCounter++;
            const container = type === 'input' ? inspectorInputsContainer : inspectorOutputsContainer;
            const div = document.createElement("div");
            div.className = 'io-item';
            div.id = `inspector-io-${inspectorIoItemIdCounter}`;
            
            let resOptsHTML = "";
            for (const key in RESOURCE_TYPES) {
                resOptsHTML += `<option value="${RESOURCE_TYPES[key]}" ${data.resourceType === RESOURCE_TYPES[key] ? 'selected' : ''}>${RESOURCE_TYPES[key]}</option>`;
            }
            
            div.dataset.originalPortId = data.portId || '';
            
            // Add color picker for outputs with default color
            const colorPickerHTML = type === 'output' ? 
                `<label>Output Color: <input type="color" name="io_color" value="${data.color || RESOURCE_COLORS[data.resourceType] || '#808080'}"></label>` : '';
            
            div.innerHTML = `
                <label>Port Name: <input type="text" name="io_name" value="${data.name || ''}" placeholder="Port Name"></label>
                <label>Resource Type: <select name="io_resource">${resOptsHTML}</select></label>
                <label>Rate (per hour/batch): <input type="number" name="io_rate" value="${data.rate || 1}" step="0.001" min="0"></label>
                <label><input type="checkbox" name="io_is_batch" ${data.isBatchIO ? 'checked' : ''}> Batch I/O</label>
                ${colorPickerHTML}
                <button class="remove-io-button" style="width:auto;float:right;background-color:#c55;">X</button>`;
            
            container.appendChild(div);
            
            // Add event listener to the remove button to prevent event bubbling
            const removeBtn = div.querySelector('.remove-io-button');
            removeBtn.addEventListener('click', (e) => {
                e.stopImmediatePropagation(); // Stop all other handlers FIRST
                e.stopPropagation();
                e.preventDefault();
                // Mark the event so click-outside handler can check for it
                e.target.setAttribute('data-removing', 'true');
                div.remove();
                // Use setTimeout to ensure save happens after DOM update
                setTimeout(() => {
                    if(typeof saveNodeChanges === 'function') saveNodeChanges();
                }, 0);
                return false;
            }, true); // Use capture phase to catch it early
        }

        document.getElementById("inspectorAddInput").addEventListener("click",()=>{addIOFieldToInspector('input');saveNodeChanges();});
        document.getElementById("inspectorAddOutput").addEventListener("click",()=>{addIOFieldToInspector('output');saveNodeChanges();});
        
        // Automation system
        let automationItemIdCounter = 0;
        
        function addAutomationFieldToInspector(data = {}) {
            automationItemIdCounter++;
            const container = document.getElementById("inspectorAutomationContainer");
            const div = document.createElement("div");
            div.className = 'io-item';
            div.id = `automation-${automationItemIdCounter}`;
            
            const triggerType = data.triggerType || 'timeOfDay';
            const action = data.action || 'turnOn';
            
            // Get all node labels for dropdowns
            let nodeLabelsHTML = '<option value="">-- Select Node --</option>';
            nodes.forEach(node => {
                if (node.type === NODE_TYPES.RESOURCE_DISPLAY && node.resourceType === RESOURCE_TYPES.POWER) {
                    nodeLabelsHTML += `<option value="${node.label}" ${data.targetNodeLabel === node.label ? 'selected' : ''}>${node.label}</option>`;
                }
            });
            
            // Build condition fields based on trigger type
            let conditionFieldsHTML = '';
            if (triggerType === 'timeOfDay') {
                conditionFieldsHTML = `
                    <label>Start Hour (0-23): <input type="number" name="auto_startHour" value="${data.startHour || 18}" min="0" max="23"></label>
                    <label>End Hour (0-23): <input type="number" name="auto_endHour" value="${data.endHour || 6}" min="0" max="23"></label>
                `;
            } else if (triggerType === 'batteryLevel') {
                conditionFieldsHTML = `
                    <label>Battery Node: <select name="auto_batteryNode">${nodeLabelsHTML}</select></label>
                    <label>Threshold (%): <input type="number" name="auto_threshold" value="${data.threshold || 75}" min="0" max="100" step="1"></label>
                    <label>Condition: <select name="auto_condition">
                        <option value="above" ${data.condition === 'above' ? 'selected' : ''}>Above Threshold</option>
                        <option value="below" ${data.condition === 'below' ? 'selected' : ''}>Below Threshold</option>
                    </select></label>
                `;
            } else if (triggerType === 'solarInput') {
                conditionFieldsHTML = `
                    <label>Solar Array Node: <select name="auto_solarNode">
                        <option value="">-- Select Solar Array --</option>
                        ${nodes.filter(n => n.type === NODE_TYPES.SOLAR_ARRAY).map(n => 
                            `<option value="${n.label}" ${data.targetNodeLabel === n.label ? 'selected' : ''}>${n.label}</option>`
                        ).join('')}
                    </select></label>
                    <label>Condition: <select name="auto_condition">
                        <option value="zero" ${data.condition === 'zero' ? 'selected' : ''}>When Solar = 0</option>
                        <option value="aboveZero" ${data.condition === 'aboveZero' ? 'selected' : ''}>When Solar > 0</option>
                    </select></label>
                `;
            } else if (triggerType === 'containerValue') {
                conditionFieldsHTML = `
                    <label>Container Node: <select name="auto_containerNode">
                        <option value="">-- Select Container --</option>
                        ${nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY).map(n => 
                            `<option value="${n.label}" ${data.targetNodeLabel === n.label ? 'selected' : ''}>${n.label}</option>`
                        ).join('')}
                    </select></label>
                    <label>Threshold Value: <input type="number" name="auto_threshold" value="${data.threshold || 0}" step="0.1"></label>
                    <label>Condition: <select name="auto_condition">
                        <option value="above" ${data.condition === 'above' ? 'selected' : ''}>Above Threshold</option>
                        <option value="below" ${data.condition === 'below' ? 'selected' : ''}>Below Threshold</option>
                        <option value="equals" ${data.condition === 'equals' ? 'selected' : ''}>Equals Threshold</option>
                    </select></label>
                `;
            }
            
            div.innerHTML = `
                <label>Trigger Type: <select name="auto_triggerType" onchange="updateAutomationConditionFields(this)">
                    <option value="timeOfDay" ${triggerType === 'timeOfDay' ? 'selected' : ''}>Time of Day</option>
                    <option value="batteryLevel" ${triggerType === 'batteryLevel' ? 'selected' : ''}>Battery Level</option>
                    <option value="solarInput" ${triggerType === 'solarInput' ? 'selected' : ''}>Solar Input</option>
                    <option value="containerValue" ${triggerType === 'containerValue' ? 'selected' : ''}>Container Value</option>
                </select></label>
                <div class="automation-conditions">${conditionFieldsHTML}</div>
                <label>Action: <select name="auto_action">
                    <option value="turnOn" ${action === 'turnOn' ? 'selected' : ''}>Turn On</option>
                    <option value="turnOff" ${action === 'turnOff' ? 'selected' : ''}>Turn Off</option>
                </select></label>
                <button class="remove-automation-button" style="width:auto;float:right;background-color:#c55;">X</button>
            `;
            
            container.appendChild(div);
            
            // Add event listener to the remove button to prevent event bubbling
            const removeBtn = div.querySelector('.remove-automation-button');
            removeBtn.addEventListener('click', (e) => {
                e.stopImmediatePropagation(); // Stop all other handlers FIRST
                e.stopPropagation();
                e.preventDefault();
                // Mark the event so click-outside handler can check for it
                e.target.setAttribute('data-removing', 'true');
                div.remove();
                // Use setTimeout to ensure save happens after DOM update
                setTimeout(() => {
                    if(typeof saveNodeChanges === 'function') saveNodeChanges();
                }, 0);
                return false;
            }, true); // Use capture phase to catch it early
        }
        
        // Function to update condition fields when trigger type changes
        window.updateAutomationConditionFields = function(selectElement) {
            const div = selectElement.closest('.io-item');
            const triggerType = selectElement.value;
            const conditionsDiv = div.querySelector('.automation-conditions');
            
            let nodeLabelsHTML = '<option value="">-- Select Node --</option>';
            nodes.forEach(node => {
                if (node.type === NODE_TYPES.RESOURCE_DISPLAY && node.resourceType === RESOURCE_TYPES.POWER) {
                    nodeLabelsHTML += `<option value="${node.label}">${node.label}</option>`;
                }
            });
            
            let conditionFieldsHTML = '';
            if (triggerType === 'timeOfDay') {
                conditionFieldsHTML = `
                    <label>Start Hour (0-23): <input type="number" name="auto_startHour" value="18" min="0" max="23"></label>
                    <label>End Hour (0-23): <input type="number" name="auto_endHour" value="6" min="0" max="23"></label>
                `;
            } else if (triggerType === 'batteryLevel') {
                conditionFieldsHTML = `
                    <label>Battery Node: <select name="auto_batteryNode">${nodeLabelsHTML}</select></label>
                    <label>Threshold (%): <input type="number" name="auto_threshold" value="75" min="0" max="100" step="1"></label>
                    <label>Condition: <select name="auto_condition">
                        <option value="above">Above Threshold</option>
                        <option value="below">Below Threshold</option>
                    </select></label>
                `;
            } else if (triggerType === 'solarInput') {
                conditionFieldsHTML = `
                    <label>Solar Array Node: <select name="auto_solarNode">
                        <option value="">-- Select Solar Array --</option>
                        ${nodes.filter(n => n.type === NODE_TYPES.SOLAR_ARRAY).map(n => 
                            `<option value="${n.label}">${n.label}</option>`
                        ).join('')}
                    </select></label>
                    <label>Condition: <select name="auto_condition">
                        <option value="zero">When Solar = 0</option>
                        <option value="aboveZero">When Solar > 0</option>
                    </select></label>
                `;
            } else if (triggerType === 'containerValue') {
                conditionFieldsHTML = `
                    <label>Container Node: <select name="auto_containerNode">
                        <option value="">-- Select Container --</option>
                        ${nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY).map(n => 
                            `<option value="${n.label}">${n.label}</option>`
                        ).join('')}
                    </select></label>
                    <label>Threshold Value: <input type="number" name="auto_threshold" value="0" step="0.1"></label>
                    <label>Condition: <select name="auto_condition">
                        <option value="above">Above Threshold</option>
                        <option value="below">Below Threshold</option>
                        <option value="equals">Equals Threshold</option>
                    </select></label>
                `;
            }
            
            conditionsDiv.innerHTML = conditionFieldsHTML;
            // Auto-save after updating condition fields
            if (typeof saveNodeChanges === 'function') {
                saveNodeChanges();
            }
        };
        
        document.getElementById("inspectorAddAutomation").addEventListener("click", () => {addAutomationFieldToInspector();saveNodeChanges();});
        
        // Recipe system for batch processors
        let recipeItemIdCounter = 0;
        
        function populateRecipeInspector(node) {
            const recipeFields = document.getElementById('inspectorRecipeFields');
            const recipeList = document.getElementById('inspectorRecipeList');
            const recipeAutomationContainer = document.getElementById('inspectorRecipeAutomationContainer');
            const processorFields = document.getElementById('inspectorProcessorFields');
            const powerInput = document.getElementById('inspectorContinuousPower');
            
            // For batch processors, show recipe UI and hide traditional I/O
            if (isBatchProcessor(node)) {
                recipeFields.classList.remove('hidden');
                processorFields.classList.add('hidden');
                
                // Set power input value
                const powerDef = node.config?.inputs?.find(i => i.resourceType === RESOURCE_TYPES.POWER && !i.isBatchIO);
                if (powerInput) powerInput.value = powerDef?.rate || 1.0;
                
                // Populate recipe list
                const recipes = node.recipes || [];
                let recipeListHTML = '';
                
                recipes.forEach((recipe, i) => {
                    const energyWh = (recipe.powerRate || node.config?.inputs?.find(inp => inp.resourceType === RESOURCE_TYPES.POWER)?.rate || 1) * (recipe.durationHrs || 0.5) * 1000;
                    const isActive = node.selectedRecipeIndex === i;
                    const isRunning = node.isInBatch && isActive;
                    
                    // Build inputs/outputs display
                    const inputItems = (recipe.inputItems || []).map(item => `${item.qty} ${item.name}`).join(', ') || 'none';
                    const outputItems = (recipe.outputItems || []).map(item => `${item.qty} ${item.name}`).join(', ') || 'none';
                    
                    recipeListHTML += `
                        <div class="recipe-card" data-index="${i}" style="
                            padding: 10px; margin-bottom: 8px; 
                            background: ${isActive ? 'linear-gradient(135deg, #1a3a1a 0%, #0d2a0d 100%)' : 'linear-gradient(135deg, #252535 0%, #1a1a2a 100%)'};
                            border: 1px solid ${isActive ? '#4ade80' : '#333'};
                            border-radius: 6px; font-size: 11px;
                            ${isRunning ? 'box-shadow: 0 0 10px rgba(74, 222, 128, 0.3);' : ''}
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <span style="font-weight: bold; color: ${isActive ? '#4ade80' : '#e94560'}; font-size: 12px;">${recipe.name || 'Unnamed'}</span>
                                <div style="display: flex; gap: 4px;">
                                    <button class="edit-recipe-btn" data-index="${i}" style="background: #333; border: 1px solid #555; color: #aaa; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">‚úèÔ∏è</button>
                                    <button class="remove-recipe-btn" data-index="${i}" style="background: #4a1a1a; border: 1px solid #d9534f; color: #d9534f; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">√ó</button>
                                </div>
                            </div>
                            <div style="color: #888; font-size: 10px; margin-bottom: 4px;">
                                <span style="color: #f59e0b;">‚ñ∂</span> ${inputItems}
                            </div>
                            <div style="color: #888; font-size: 10px; margin-bottom: 6px;">
                                <span style="color: #22c55e;">‚óÄ</span> ${outputItems}
                            </div>
                            <div style="display: flex; justify-content: space-between; color: #666; font-size: 9px; margin-bottom: 8px; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                                <span>‚ö° ${energyWh.toFixed(0)}Wh</span>
                                <span>‚è±Ô∏è ${((recipe.durationHrs || 0.5) * 60).toFixed(0)}min</span>
                            </div>
                            <button class="make-recipe-btn" data-index="${i}" style="
                                width: 100%; padding: 6px; 
                                background: ${isActive ? (isRunning ? '#166534' : '#15803d') : '#0f3460'};
                                border: 1px solid ${isActive ? '#4ade80' : '#e94560'};
                                color: ${isActive ? '#4ade80' : '#e94560'};
                                border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;
                                transition: all 0.2s;
                            ">${isRunning ? '‚è≥ Running...' : (isActive ? '‚ñ∂ Make Again' : '‚ñ∂ Make')}</button>
                        </div>
                    `;
                });
                
                if (recipes.length === 0) {
                    recipeListHTML = `
                        <div style="text-align: center; padding: 20px; color: #666;">
                            <div style="font-size: 24px; margin-bottom: 8px;">üìã</div>
                            <div style="font-size: 11px;">No recipes yet</div>
                            <div style="font-size: 10px; color: #555;">Click "+ New" to add one</div>
                        </div>
                    `;
                }
                recipeList.innerHTML = recipeListHTML;
                
                // Add event listeners for recipe buttons
                recipeList.querySelectorAll('.remove-recipe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const idx = parseInt(btn.dataset.index);
                        node.recipes = node.recipes || [];
                        node.recipes.splice(idx, 1);
                        // Update ports after removing recipe
                        updateNodePortsFromRecipes(node);
                        populateRecipeInspector(node);
                        saveNodeChanges();
                    });
                });
                
                recipeList.querySelectorAll('.edit-recipe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const idx = parseInt(btn.dataset.index);
                        showRecipeEditor(node, idx);
                    });
                });
                
                recipeList.querySelectorAll('.make-recipe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const idx = parseInt(btn.dataset.index);
                        startRecipe(node, idx);
                    });
                });
                
                // Populate recipe automations
                recipeAutomationContainer.innerHTML = '';
                (node.recipeAutomations || []).forEach((auto, i) => addRecipeAutomationField(node, auto, i));
                
            } else {
                // Non-batch processor - show traditional I/O
                recipeFields.classList.add('hidden');
                processorFields.classList.remove('hidden');
            }
        }
        
        // Start a recipe manually
        function startRecipe(node, recipeIndex) {
            if (!node.recipes || !node.recipes[recipeIndex]) return;
            
            const recipe = node.recipes[recipeIndex];
            node.selectedRecipeIndex = recipeIndex;
            node.batchDuration = recipe.durationHrs || 0.5;
            
            // Update power rate
            const powerInput = node.config.inputs.find(i => i.resourceType === RESOURCE_TYPES.POWER && !i.isBatchIO);
            if (powerInput) {
                powerInput.rate = recipe.powerRate || powerInput.rate;
            }
            
            // Turn on and start batch
            node.isRunning = true;
            node.isInBatch = false; // Will start fresh batch on next sim step
            node.batchTimeElapsed = 0;
            
            populateRecipeInspector(node);
            scheduleRender();
        }
        
        // Update node ports based on all recipes' inputs/outputs
        function updateNodePortsFromRecipes(node) {
            if (!isBatchProcessor(node)) return;
            
            const recipes = node.recipes || [];
            const allInputItems = new Map(); // name -> {name, resourceType}
            const allOutputItems = new Map();
            
            // Collect all unique input/output items from all recipes
            recipes.forEach(recipe => {
                (recipe.inputItems || []).forEach(item => {
                    if (!allInputItems.has(item.name)) {
                        allInputItems.set(item.name, { name: item.name, resourceType: RESOURCE_TYPES.USER_DEFINED, rate: item.qty || 1, isBatchIO: true });
                    }
                });
                (recipe.outputItems || []).forEach(item => {
                    if (!allOutputItems.has(item.name)) {
                        allOutputItems.set(item.name, { name: item.name, resourceType: RESOURCE_TYPES.USER_DEFINED, rate: item.qty || 1, isBatchIO: true, color: item.color || '#808080' });
                    }
                });
            });
            
            // Keep power input, add recipe inputs
            const powerInput = node.config.inputs.find(i => i.resourceType === RESOURCE_TYPES.POWER);
            node.config.inputs = powerInput ? [powerInput] : [{ name: 'Power', resourceType: RESOURCE_TYPES.POWER, rate: 1.0, isBatchIO: false }];
            allInputItems.forEach(item => node.config.inputs.push(item));
            
            // Replace outputs with recipe outputs
            node.config.outputs = [];
            allOutputItems.forEach(item => node.config.outputs.push(item));
            
            // Regenerate ports
            regeneratePortsForNode(node);
        }
        
        function addRecipeAutomationField(node, data = {}, index = -1) {
            recipeItemIdCounter++;
            const container = document.getElementById('inspectorRecipeAutomationContainer');
            const div = document.createElement('div');
            div.className = 'io-item';
            div.id = `recipe-auto-${recipeItemIdCounter}`;
            div.style.cssText = 'padding: 8px; margin-bottom: 6px; background: #252525; border-radius: 4px; font-size: 11px;';
            
            const recipes = node.recipes || [];
            let recipeOptionsHTML = '<option value="-1">-- Select Recipe --</option>';
            recipes.forEach((r, i) => {
                recipeOptionsHTML += `<option value="${i}" ${data.recipeIndex === i ? 'selected' : ''}>${r.name || 'Unnamed'}</option>`;
            });
            
            const triggerType = data.triggerType || 'timeOfDay';
            
            let conditionHTML = '';
            if (triggerType === 'timeOfDay') {
                conditionHTML = `
                    <label style="font-size: 10px;">Start Hour: <input type="number" name="ra_startHour" value="${data.startHour || 8}" min="0" max="23" style="width: 50px;"></label>
                    <label style="font-size: 10px;">End Hour: <input type="number" name="ra_endHour" value="${data.endHour || 9}" min="0" max="23" style="width: 50px;"></label>
                `;
            } else if (triggerType === 'containerValue') {
                let containerOptionsHTML = '<option value="">-- Select --</option>';
                nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY).forEach(n => {
                    containerOptionsHTML += `<option value="${n.label}" ${data.targetNodeLabel === n.label ? 'selected' : ''}>${n.label}</option>`;
                });
                conditionHTML = `
                    <label style="font-size: 10px;">Container: <select name="ra_container" style="font-size: 10px;">${containerOptionsHTML}</select></label>
                    <label style="font-size: 10px;">Condition: <select name="ra_condition" style="font-size: 10px;">
                        <option value="above" ${data.condition === 'above' ? 'selected' : ''}>Above</option>
                        <option value="below" ${data.condition === 'below' ? 'selected' : ''}>Below</option>
                    </select></label>
                    <label style="font-size: 10px;">Threshold: <input type="number" name="ra_threshold" value="${data.threshold || 50}" step="0.1" style="width: 60px;"></label>
                `;
            } else if (triggerType === 'batteryLevel') {
                let batteryOptionsHTML = '<option value="">-- Select --</option>';
                nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY && n.resourceType === RESOURCE_TYPES.POWER).forEach(n => {
                    batteryOptionsHTML += `<option value="${n.label}" ${data.targetNodeLabel === n.label ? 'selected' : ''}>${n.label}</option>`;
                });
                conditionHTML = `
                    <label style="font-size: 10px;">Battery: <select name="ra_battery" style="font-size: 10px;">${batteryOptionsHTML}</select></label>
                    <label style="font-size: 10px;">Condition: <select name="ra_condition" style="font-size: 10px;">
                        <option value="above" ${data.condition === 'above' ? 'selected' : ''}>Above %</option>
                        <option value="below" ${data.condition === 'below' ? 'selected' : ''}>Below %</option>
                    </select></label>
                    <label style="font-size: 10px;">Threshold %: <input type="number" name="ra_threshold" value="${data.threshold || 75}" min="0" max="100" style="width: 50px;"></label>
                `;
            }
            
            div.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <label style="font-size: 10px;">Recipe: <select name="ra_recipe" style="font-size: 10px;">${recipeOptionsHTML}</select></label>
                    <button class="remove-ra-btn" style="background: #d9534f; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">√ó</button>
                </div>
                <label style="font-size: 10px;">Trigger: <select name="ra_trigger" style="font-size: 10px;" onchange="updateRecipeAutomationConditions(this)">
                    <option value="timeOfDay" ${triggerType === 'timeOfDay' ? 'selected' : ''}>Time of Day</option>
                    <option value="containerValue" ${triggerType === 'containerValue' ? 'selected' : ''}>Container Value</option>
                    <option value="batteryLevel" ${triggerType === 'batteryLevel' ? 'selected' : ''}>Battery Level</option>
                </select></label>
                <div class="ra-conditions" style="margin-top: 5px;">${conditionHTML}</div>
            `;
            
            container.appendChild(div);
            
            div.querySelector('.remove-ra-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                div.remove();
                saveNodeChanges();
            });
        }
        
        window.updateRecipeAutomationConditions = function(selectElement) {
            const div = selectElement.closest('.io-item');
            const triggerType = selectElement.value;
            const conditionsDiv = div.querySelector('.ra-conditions');
            
            let conditionHTML = '';
            if (triggerType === 'timeOfDay') {
                conditionHTML = `
                    <label style="font-size: 10px;">Start Hour: <input type="number" name="ra_startHour" value="8" min="0" max="23" style="width: 50px;"></label>
                    <label style="font-size: 10px;">End Hour: <input type="number" name="ra_endHour" value="9" min="0" max="23" style="width: 50px;"></label>
                `;
            } else if (triggerType === 'containerValue') {
                let containerOptionsHTML = '<option value="">-- Select --</option>';
                nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY).forEach(n => {
                    containerOptionsHTML += `<option value="${n.label}">${n.label}</option>`;
                });
                conditionHTML = `
                    <label style="font-size: 10px;">Container: <select name="ra_container" style="font-size: 10px;">${containerOptionsHTML}</select></label>
                    <label style="font-size: 10px;">Condition: <select name="ra_condition" style="font-size: 10px;">
                        <option value="above">Above</option>
                        <option value="below">Below</option>
                    </select></label>
                    <label style="font-size: 10px;">Threshold: <input type="number" name="ra_threshold" value="50" step="0.1" style="width: 60px;"></label>
                `;
            } else if (triggerType === 'batteryLevel') {
                let batteryOptionsHTML = '<option value="">-- Select --</option>';
                nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY && n.resourceType === RESOURCE_TYPES.POWER).forEach(n => {
                    batteryOptionsHTML += `<option value="${n.label}">${n.label}</option>`;
                });
                conditionHTML = `
                    <label style="font-size: 10px;">Battery: <select name="ra_battery" style="font-size: 10px;">${batteryOptionsHTML}</select></label>
                    <label style="font-size: 10px;">Condition: <select name="ra_condition" style="font-size: 10px;">
                        <option value="above">Above %</option>
                        <option value="below">Below %</option>
                    </select></label>
                    <label style="font-size: 10px;">Threshold %: <input type="number" name="ra_threshold" value="75" min="0" max="100" style="width: 50px;"></label>
                `;
            }
            conditionsDiv.innerHTML = conditionHTML;
            saveNodeChanges();
        };
        
        function showRecipeEditor(node, recipeIndex) {
            const recipe = recipeIndex >= 0 ? node.recipes[recipeIndex] : { 
                name: '', 
                durationHrs: 0.5, 
                powerRate: 1.0,
                inputItems: [],
                outputItems: []
            };
            const isNew = recipeIndex < 0;
            
            // Build input items HTML
            const buildItemsHTML = (items, type) => {
                if (!items || items.length === 0) {
                    return `<div class="recipe-item-empty" style="color: #666; font-size: 10px; padding: 8px; text-align: center;">No ${type}s yet</div>`;
                }
                return items.map((item, i) => `
                    <div class="recipe-io-item" data-type="${type}" data-index="${i}" style="display: flex; gap: 5px; align-items: center; padding: 5px; background: #1a1a1a; border-radius: 4px; margin-bottom: 4px;">
                        <input type="number" class="item-qty" value="${item.qty || 1}" min="0" step="0.1" style="width: 50px; padding: 3px; font-size: 11px;">
                        <input type="text" class="item-name" value="${item.name || ''}" placeholder="${type} name" style="flex: 1; padding: 3px; font-size: 11px;">
                        <button class="remove-item-btn" style="background: #4a1a1a; border: 1px solid #d9534f; color: #d9534f; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 10px;">√ó</button>
                    </div>
                `).join('');
            };
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 24px; border-radius: 12px; width: 420px; color: #fff; border: 1px solid #0f3460; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                    <h3 style="margin: 0 0 20px 0; color: #e94560; font-size: 18px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 24px;">üìã</span>
                        ${isNew ? 'New Recipe' : 'Edit Recipe'}
                    </h3>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #888; font-size: 11px; margin-bottom: 4px;">Recipe Name</label>
                        <input type="text" id="recipeEditorName" value="${recipe.name || ''}" placeholder="e.g., Popcorn" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #333; background: #0a0a0a; color: #fff; font-size: 13px;">
                    </div>
                    
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1;">
                            <label style="display: block; color: #888; font-size: 11px; margin-bottom: 4px;">‚è±Ô∏è Duration (min)</label>
                            <input type="number" id="recipeEditorDuration" value="${((recipe.durationHrs || 0.5) * 60).toFixed(1)}" step="0.5" min="0.5" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #333; background: #0a0a0a; color: #fff; font-size: 13px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="display: block; color: #888; font-size: 11px; margin-bottom: 4px;">‚ö° Power (kW)</label>
                            <input type="number" id="recipeEditorPower" value="${recipe.powerRate || 1.0}" step="0.1" min="0" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #333; background: #0a0a0a; color: #fff; font-size: 13px;">
                        </div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #2a1a0a 0%, #1a0f05 100%); border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <label style="color: #f59e0b; font-size: 12px; font-weight: bold;">‚ñ∂ Inputs (consumed)</label>
                            <button id="addInputItem" style="background: #1a0f05; border: 1px solid #f59e0b; color: #f59e0b; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">+ Add</button>
                        </div>
                        <div id="recipeInputItems">${buildItemsHTML(recipe.inputItems, 'input')}</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #0a2a1a 0%, #051a0f 100%); border: 1px solid #22c55e; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <label style="color: #22c55e; font-size: 12px; font-weight: bold;">‚óÄ Outputs (produced)</label>
                            <button id="addOutputItem" style="background: #051a0f; border: 1px solid #22c55e; color: #22c55e; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">+ Add</button>
                        </div>
                        <div id="recipeOutputItems">${buildItemsHTML(recipe.outputItems, 'output')}</div>
                    </div>
                    
                    <div id="recipeEnergyCalc" style="background: rgba(0,0,0,0.3); padding: 8px 12px; border-radius: 4px; margin-bottom: 16px; font-size: 11px; color: #888;">
                        Energy per batch: <span style="color: #fbbf24; font-weight: bold;">${((recipe.powerRate || 1) * (recipe.durationHrs || 0.5) * 1000).toFixed(0)} Wh</span>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button id="recipeEditorSave" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #15803d 0%, #166534 100%); border: 1px solid #22c55e; color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold;">üíæ Save Recipe</button>
                        <button id="recipeEditorCancel" style="flex: 1; padding: 10px; background: #333; border: 1px solid #555; color: #aaa; border-radius: 6px; cursor: pointer; font-size: 13px;">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Track current items
            let currentInputItems = [...(recipe.inputItems || [])];
            let currentOutputItems = [...(recipe.outputItems || [])];
            
            const refreshItemsList = () => {
                document.getElementById('recipeInputItems').innerHTML = buildItemsHTML(currentInputItems, 'input');
                document.getElementById('recipeOutputItems').innerHTML = buildItemsHTML(currentOutputItems, 'output');
                attachItemListeners();
                updateEnergyCalc();
            };
            
            const updateEnergyCalc = () => {
                const duration = parseFloat(document.getElementById('recipeEditorDuration').value) / 60 || 0.5;
                const power = parseFloat(document.getElementById('recipeEditorPower').value) || 1;
                const energy = power * duration * 1000;
                document.getElementById('recipeEnergyCalc').innerHTML = `Energy per batch: <span style="color: #fbbf24; font-weight: bold;">${energy.toFixed(0)} Wh</span>`;
            };
            
            const attachItemListeners = () => {
                modal.querySelectorAll('.recipe-io-item').forEach(itemEl => {
                    const type = itemEl.dataset.type;
                    const idx = parseInt(itemEl.dataset.index);
                    const items = type === 'input' ? currentInputItems : currentOutputItems;
                    
                    itemEl.querySelector('.item-qty').addEventListener('input', (e) => {
                        items[idx].qty = parseFloat(e.target.value) || 1;
                    });
                    itemEl.querySelector('.item-name').addEventListener('input', (e) => {
                        items[idx].name = e.target.value;
                    });
                    itemEl.querySelector('.remove-item-btn').addEventListener('click', () => {
                        items.splice(idx, 1);
                        refreshItemsList();
                    });
                });
            };
            
            document.getElementById('addInputItem').addEventListener('click', () => {
                currentInputItems.push({ name: '', qty: 1 });
                refreshItemsList();
            });
            
            document.getElementById('addOutputItem').addEventListener('click', () => {
                currentOutputItems.push({ name: '', qty: 1 });
                refreshItemsList();
            });
            
            document.getElementById('recipeEditorDuration').addEventListener('input', updateEnergyCalc);
            document.getElementById('recipeEditorPower').addEventListener('input', updateEnergyCalc);
            
            attachItemListeners();
            
            modal.querySelector('#recipeEditorSave').addEventListener('click', () => {
                const newRecipe = {
                    name: document.getElementById('recipeEditorName').value || 'Unnamed Recipe',
                    durationHrs: parseFloat(document.getElementById('recipeEditorDuration').value) / 60 || 0.5,
                    powerRate: parseFloat(document.getElementById('recipeEditorPower').value) || 1.0,
                    inputItems: currentInputItems.filter(i => i.name.trim()),
                    outputItems: currentOutputItems.filter(i => i.name.trim())
                };
                
                node.recipes = node.recipes || [];
                if (isNew) {
                    node.recipes.push(newRecipe);
                } else {
                    node.recipes[recipeIndex] = newRecipe;
                }
                
                // Update ports based on recipes
                updateNodePortsFromRecipes(node);
                
                modal.remove();
                populateRecipeInspector(node);
                saveNodeChanges();
            });
            
            modal.querySelector('#recipeEditorCancel').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }
        
        document.getElementById('inspectorAddRecipe').addEventListener('click', () => {
            const node = findNodeById(selectedNodeId);
            if (node) showRecipeEditor(node, -1);
        });
        
        document.getElementById('inspectorAddRecipeAutomation').addEventListener('click', () => {
            const node = findNodeById(selectedNodeId);
            if (node) {
                addRecipeAutomationField(node, {});
                saveNodeChanges();
            }
        });
        
        // Power input change handler
        document.getElementById('inspectorContinuousPower')?.addEventListener('change', (e) => {
            const node = findNodeById(selectedNodeId);
            if (node && node.config?.inputs) {
                const powerInput = node.config.inputs.find(i => i.resourceType === RESOURCE_TYPES.POWER && !i.isBatchIO);
                if (powerInput) {
                    powerInput.rate = parseFloat(e.target.value) || 1.0;
                }
                saveNodeChanges();
            }
        });
        
        // Debounce utility function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Auto-save function - saves changes immediately when fields are modified
        function saveNodeChanges() {
            if (!selectedNodeId) return;
            const node = findNodeById(selectedNodeId);
            if (!node) return;
            
            node.label = inspectorNodeName.value || "Unnamed Node";
            node.img = inspectorNodeImageURL.value.trim() || null;
            const newOrientation = inspectorPortOrientation.value || 'vertical';
            if (node.portOrientation !== newOrientation) {
                node.portOrientation = newOrientation;
                // Regenerate ports for all node types when orientation changes
                if (node.type === NODE_TYPES.PROCESSOR) {
                    regeneratePortsForNode(node);
                } else if (node.type === NODE_TYPES.RESOURCE_DISPLAY || node.type === NODE_TYPES.SOLAR_ARRAY) {
                    // Update existing ports to new orientation
                    const isFlipped = node.flipped || false;
                    node.ports.forEach(port => {
                        if (newOrientation === 'vertical') {
                            // Convert to vertical
                            if (port.side === 'left') {
                                port.side = isFlipped ? 'bottom' : 'top';
                                port.xOffsetRatio = port.yOffsetRatio || 0.5;
                                port.yOffsetRatio = 0.5;
                            } else if (port.side === 'right') {
                                port.side = isFlipped ? 'top' : 'bottom';
                                port.xOffsetRatio = port.yOffsetRatio || 0.5;
                                port.yOffsetRatio = 0.5;
                            }
                        } else {
                            // Convert to horizontal
                            if (port.side === 'top') {
                                port.side = isFlipped ? 'right' : 'left';
                                port.yOffsetRatio = port.xOffsetRatio || 0.5;
                                port.xOffsetRatio = 0.5;
                            } else if (port.side === 'bottom') {
                                port.side = isFlipped ? 'left' : 'right';
                                port.yOffsetRatio = port.xOffsetRatio || 0.5;
                                port.xOffsetRatio = 0.5;
                            }
                        }
                    });
                }
            }
            
            if (node.type === NODE_TYPES.PROCESSOR) {
                if (isBatchProcessor(node)) {
                    node.batchDuration = parseInt(inspectorBatchDuration.value) || 6;
                }
                
                const newInputs = [];
                document.querySelectorAll("#inspectorInputsContainer .io-item").forEach(item => {
                    newInputs.push({
                        name: item.querySelector('[name="io_name"]').value || "Input",
                        resourceType: item.querySelector('[name="io_resource"]').value,
                        rate: parseFloat(item.querySelector('[name="io_rate"]').value) || 1,
                        isBatchIO: item.querySelector('[name="io_is_batch"]').checked
                    });
                });
                
                const newOutputs = [];
                document.querySelectorAll("#inspectorOutputsContainer .io-item").forEach(item => {
                    newOutputs.push({
                        name: item.querySelector('[name="io_name"]').value || "Output",
                        resourceType: item.querySelector('[name="io_resource"]').value,
                        rate: parseFloat(item.querySelector('[name="io_rate"]').value) || 1,
                        isBatchIO: item.querySelector('[name="io_is_batch"]').checked,
                        color: item.querySelector('[name="io_color"]')?.value || '#808080'
                    });
                });
                
                node.config.inputs = newInputs;
                node.config.outputs = newOutputs;
                regeneratePortsForNode(node);
            } else if (node.type === NODE_TYPES.RESOURCE_DISPLAY) {
                node.unit = inspectorNodeUnit.value || "Units";
                node.passiveGeneration = parseFloat(inspectorPassiveRate.value) || 0;
                node.maxCapacity = parseFloat(inspectorMaxCapacity.value) > 0 ? parseFloat(inspectorMaxCapacity.value) : null;
                node.progressColor = inspectorProgressColor.value;
                node.isExternal = inspectorIsExternal.checked;
                if (node.maxCapacity && node.value > node.maxCapacity) node.value = node.maxCapacity;
            } else if (node.type === NODE_TYPES.SOLAR_ARRAY) {
                node.ratedOutput = parseFloat(inspectorRatedOutput.value) || 0;
            }
            
            // Save automation rules
            const automations = [];
            document.querySelectorAll("#inspectorAutomationContainer .io-item").forEach(item => {
                const triggerType = item.querySelector('[name="auto_triggerType"]').value;
                const action = item.querySelector('[name="auto_action"]').value;
                const automation = { triggerType, action };
                
                if (triggerType === 'timeOfDay') {
                    automation.startHour = parseInt(item.querySelector('[name="auto_startHour"]').value) || 18;
                    automation.endHour = parseInt(item.querySelector('[name="auto_endHour"]').value) || 6;
                } else if (triggerType === 'batteryLevel') {
                    automation.targetNodeLabel = item.querySelector('[name="auto_batteryNode"]').value;
                    automation.threshold = parseFloat(item.querySelector('[name="auto_threshold"]').value) || 75;
                    automation.condition = item.querySelector('[name="auto_condition"]').value;
                } else if (triggerType === 'solarInput') {
                    automation.targetNodeLabel = item.querySelector('[name="auto_solarNode"]').value;
                    automation.condition = item.querySelector('[name="auto_condition"]').value;
                } else if (triggerType === 'containerValue') {
                    automation.targetNodeLabel = item.querySelector('[name="auto_containerNode"]').value;
                    automation.threshold = parseFloat(item.querySelector('[name="auto_threshold"]').value) || 0;
                    automation.condition = item.querySelector('[name="auto_condition"]').value;
                }
                
                automations.push(automation);
            });
            node.automations = automations;
            
            // Save recipe automations for batch processors
            if (node.type === NODE_TYPES.PROCESSOR && isBatchProcessor(node)) {
                const recipeAutomations = [];
                document.querySelectorAll("#inspectorRecipeAutomationContainer .io-item").forEach(item => {
                    const triggerType = item.querySelector('[name="ra_trigger"]')?.value || 'timeOfDay';
                    const recipeIndex = parseInt(item.querySelector('[name="ra_recipe"]')?.value) || -1;
                    const auto = { triggerType, recipeIndex };
                    
                    if (triggerType === 'timeOfDay') {
                        auto.startHour = parseInt(item.querySelector('[name="ra_startHour"]')?.value) || 8;
                        auto.endHour = parseInt(item.querySelector('[name="ra_endHour"]')?.value) || 9;
                    } else if (triggerType === 'containerValue') {
                        auto.targetNodeLabel = item.querySelector('[name="ra_container"]')?.value || '';
                        auto.condition = item.querySelector('[name="ra_condition"]')?.value || 'above';
                        auto.threshold = parseFloat(item.querySelector('[name="ra_threshold"]')?.value) || 50;
                    } else if (triggerType === 'batteryLevel') {
                        auto.targetNodeLabel = item.querySelector('[name="ra_battery"]')?.value || '';
                        auto.condition = item.querySelector('[name="ra_condition"]')?.value || 'above';
                        auto.threshold = parseFloat(item.querySelector('[name="ra_threshold"]')?.value) || 75;
                    }
                    
                    recipeAutomations.push(auto);
                });
                node.recipeAutomations = recipeAutomations;
            }
            
            // Visual feedback - briefly highlight the save button
            const saveButton = document.getElementById("saveNodeChanges");
            const originalBg = saveButton.style.backgroundColor;
            saveButton.style.backgroundColor = "#4a9";
            setTimeout(() => {
                saveButton.style.backgroundColor = originalBg || "";
            }, 300);
            
            scheduleRender(); // Phase 1: Use batched render
        }
        
        // Track pending saves for visual feedback
        let hasPendingSave = false;
        let saveTimeout = null;
        
        function updateSaveButtonState() {
            const saveButton = document.getElementById("saveNodeChanges");
            if (hasPendingSave) {
                saveButton.textContent = "Saving...";
                saveButton.style.opacity = "0.5";
            } else {
                saveButton.textContent = "Auto-Save Enabled";
                saveButton.style.opacity = "0.7";
            }
        }
        
        // Debounced version with visual feedback for text inputs
        function debouncedSaveNodeChangesWithFeedback() {
            if (!hasPendingSave) {
                hasPendingSave = true;
                updateSaveButtonState();
            }
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            saveTimeout = setTimeout(() => {
                hasPendingSave = false;
                updateSaveButtonState();
                saveNodeChanges();
            }, 400);
        }
        
        // Keep Apply button for manual save if needed, but also auto-save on changes
        document.getElementById("saveNodeChanges").addEventListener("click", () => {
            if (saveTimeout) {
                clearTimeout(saveTimeout);
                saveTimeout = null;
            }
            hasPendingSave = false;
            updateSaveButtonState();
            saveNodeChanges();
        });
        
        // Auto-save on all input field changes
        // Text inputs: debounced (to reduce render calls while typing)
        inspectorNodeName.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        inspectorNodeImageURL.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        // Selects and checkboxes: immediate (no typing, user expects instant feedback)
        inspectorPortOrientation.addEventListener("change", saveNodeChanges);
        
        // Wire up flip button in inspector
        const inspectorFlipButton = document.getElementById("inspectorFlipButton");
        inspectorFlipButton.addEventListener("click", () => {
            if (!selectedNodeId) return;
            const node = findNodeById(selectedNodeId);
            if (!node) return;
            flipNodeOrientation(node);
            saveNodeChanges(); // Save the flip change
        });
        
        // Text inputs: debounced
        inspectorNodeUnit.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        inspectorPassiveRate.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        inspectorMaxCapacity.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        inspectorRatedOutput.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        inspectorBatchDuration.addEventListener("input", debouncedSaveNodeChangesWithFeedback);
        // Color pickers and checkboxes: immediate (user expects instant visual feedback)
        inspectorProgressColor.addEventListener("change", saveNodeChanges);
        inspectorIsExternal.addEventListener("change", saveNodeChanges);
        
        // Auto-save for dynamically added IO fields (using event delegation)
        // Text inputs and number inputs: debounced
        inspectorInputsContainer.addEventListener("input", (e) => {
            if (e.target.matches('[name="io_name"], [name="io_rate"]')) {
                debouncedSaveNodeChangesWithFeedback();
            } else if (e.target.matches('[name="io_color"]')) {
                // Color picker: immediate (visual feedback expected)
                saveNodeChanges();
            }
        });
        // Selects and checkboxes: immediate
        inspectorInputsContainer.addEventListener("change", (e) => {
            if (e.target.matches('[name="io_resource"], [name="io_is_batch"]')) {
                saveNodeChanges();
            }
        });
        inspectorOutputsContainer.addEventListener("input", (e) => {
            if (e.target.matches('[name="io_name"], [name="io_rate"]')) {
                debouncedSaveNodeChangesWithFeedback();
            } else if (e.target.matches('[name="io_color"]')) {
                // Color picker: immediate (visual feedback expected)
                saveNodeChanges();
            }
        });
        inspectorOutputsContainer.addEventListener("change", (e) => {
            if (e.target.matches('[name="io_resource"], [name="io_is_batch"]')) {
                saveNodeChanges();
            }
        });
        
        // Auto-save for automation fields
        // Number inputs: debounced
        document.getElementById("inspectorAutomationContainer").addEventListener("input", (e) => {
            if (e.target.matches('[name="auto_startHour"], [name="auto_endHour"], [name="auto_threshold"]')) {
                debouncedSaveNodeChangesWithFeedback();
            }
        });
        // Selects: immediate (user expects instant feedback)
        document.getElementById("inspectorAutomationContainer").addEventListener("change", (e) => {
            if (e.target.matches('[name="auto_triggerType"], [name="auto_action"], [name="auto_condition"], [name="auto_batteryNode"], [name="auto_solarNode"], [name="auto_containerNode"]')) {
                saveNodeChanges();
            }
        });
        document.getElementById("cancelNodeChanges").addEventListener("click",deselectNode);
        let dragOffsetX,dragOffsetY,tempConnectionData=null;
        function dragStarted(e,d){d3.select(this).raise().classed("active",true);dragOffsetX=e.x-d.x;dragOffsetY=e.y-d.y;}
        function dragged(e,d){
            d.x=e.x-dragOffsetX;
            d.y=e.y-dragOffsetY;
            // Phase 1: Update transform immediately, batch full render
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            scheduleRender();
        }
        function dragEnded(e,d){d3.select(this).classed("active",false);}
        function getPortById(nodeId,portId){const n=nodes.find(n=>n.id===nodeId);return n?n.ports.find(p=>p.id===portId):null;}
        function removeNode(nodeId){if(selectedNodeId===nodeId)deselectNode();invalidateNodeCache(nodeId);nodes=nodes.filter(n=>n.id!==nodeId);connections=connections.filter(c=>c.sourceNodeId!==nodeId&&c.targetNodeId!==nodeId);scheduleRender();}
        function flipNodeOrientation(node) {
            node.flipped = !node.flipped;
            if (node.type === NODE_TYPES.PROCESSOR) {
                regeneratePortsForNode(node);
            } else if (node.type === NODE_TYPES.RESOURCE_DISPLAY || node.type === NODE_TYPES.SOLAR_ARRAY) {
                const orientation = node.portOrientation || 'vertical';
                node.ports.forEach(port => {
                    if (orientation === 'vertical') {
                        // Flip top/bottom
                        if (port.side === 'top') port.side = 'bottom';
                        else if (port.side === 'bottom') port.side = 'top';
                    } else {
                        // Flip left/right
                        if (port.side === 'left') port.side = 'right';
                        else if (port.side === 'right') port.side = 'left';
                    }
                });
            }
            scheduleRender(); // Phase 1: Use batched render
        }
        
        function toggleProcessor(procNode){ 
            if (challengeMode) return; // Disable manual control in challenge mode
            procNode.isRunning=!procNode.isRunning; 
            if (!procNode.isRunning) {
                procNode.canProcessLastStep = false; 
                // If it's a batch processor and was stopped mid-batch, it remains isInBatch.
                // If it's stopped and was awaiting inputs, reset that.
                // procNode.awaitingBatchInputs = false; // Reset this on manual stop/start toggle
            } else {
                 if (isBatchProcessor(procNode) && !procNode.isInBatch) {
                    procNode.awaitingBatchInputs = true; // Set to await if starting a new batch cycle
                 }
            }
            scheduleRender(); // Phase 1: Use batched render
        }
        function findNodeById(id){return nodes.find(n => n.id === id);}
        
        function simulateStep() {
            if (isPlaying) { elapsedHours++; }
            
            // Update canvas background color based on time of day
            // Adjusted to match solar output timing (starts at 5 AM, ends at 7 PM)
            const hourOfDay = elapsedHours % 24;
            let brightness = 0;
            // Day period: 5 AM to 7 PM (14 hours) to match solar production window
            if (hourOfDay >= 5 && hourOfDay < 19) {
                // Normalize to 0-1 range over 14 hours, then apply sine curve
                const normalizedHour = (hourOfDay - 5) / 14;
                brightness = Math.max(0, Math.sin(normalizedHour * Math.PI));
            }
            
            // Calculate background color based on brightness
            const baseColor = { r: 26, g: 43, b: 60 }; // #1a2b3c
            const maxColor = { r: 173, g: 216, b: 230 }; // #add8e6 (light blue)
            
            const r = Math.round(baseColor.r + (maxColor.r - baseColor.r) * brightness);
            const g = Math.round(baseColor.g + (maxColor.g - baseColor.g) * brightness);
            const b = Math.round(baseColor.b + (maxColor.b - baseColor.b) * brightness);
            
            // Update both the SVG and its container
            const canvasContainer = document.getElementById('canvas-container');
            const newColor = `rgb(${r}, ${g}, ${b})`;
            d3.select('#simulationCanvas').style('background-color', newColor);
            canvasContainer.style.backgroundColor = newColor;
            
            // Update shadow angles based on time of day
            updateShadowAngle(hourOfDay);
            
            if (isPlaying) { 
                nodes.forEach(n => { 
                    if (n.type === NODE_TYPES.RESOURCE_DISPLAY && n.passiveGeneration !== undefined && n.passiveGeneration !== 0) { 
                        let amountToAdd = n.passiveGeneration; 
                        if (n.maxCapacity != null) { 
                            const roomLeft = n.maxCapacity - n.value; 
                            if (n.passiveGeneration > 0) amountToAdd = Math.min(amountToAdd, roomLeft); 
                        } 
                        n.value += amountToAdd; 
                        if (n.value < 0 && !n.isSource && !n.isExternal) n.value = 0; 
                        if (n.maxCapacity != null) n.value = Math.min(n.value, n.maxCapacity); 
                    }
                }); 
            }
            
            nodes.filter(n => n.type === NODE_TYPES.SOLAR_ARRAY).forEach(solarNode => {
                const hourOfDay = elapsedHours % 24;
                
                // Calculate weather derating factor (new random value each hour)
                if (lastDeratingHour !== elapsedHours) {
                    let minDerating, maxDerating;
                    switch(weatherDifficulty) {
                        case 'clear':
                            minDerating = 1.0;
                            maxDerating = 1.0;
                            break;
                        case 'easy':
                            minDerating = 0.8;
                            maxDerating = 1.0;
                            break;
                        case 'medium':
                            minDerating = 0.5;
                            maxDerating = 0.8;
                            break;
                        case 'hard':
                            minDerating = 0.2;
                            maxDerating = 0.6;
                            break;
                        default:
                            minDerating = 1.0;
                            maxDerating = 1.0;
                    }
                    currentHourDerating = minDerating + Math.random() * (maxDerating - minDerating);
                    lastDeratingHour = elapsedHours;
                }
                
                // Calculate solar output based on rated array size and time of day
                // Uses a sinusoidal curve from 5 AM to 7 PM (14-hour solar window)
                // Peak output occurs around solar noon (12 PM)
                let baseOutput = 0;
                if (hourOfDay >= 5 && hourOfDay < 19) {
                    // Normalize hour to 0-1 over the 14-hour solar window
                    const normalizedHour = (hourOfDay - 5) / 14;
                    // Sinusoidal curve peaks at 0.5 (noon)
                    const irradianceFactor = Math.sin(normalizedHour * Math.PI);
                    // Scale by rated output (in kW)
                    // Typical peak efficiency is ~60% of rated due to real-world conditions
                    baseOutput = solarNode.ratedOutput * irradianceFactor * 0.6;
                }
                // Apply weather derating factor
                solarNode.currentOutput = baseOutput * currentHourDerating;
                solarNode.canProcessLastStep = solarNode.currentOutput > 0.001 && isPlaying;
                
                if (isPlaying && solarNode.currentOutput > 0) {
                    const energyGeneratedThisHour = solarNode.currentOutput;
                    // Track total possible solar kWh (always track in liveStats)
                    liveStats.solarKwhPossible += energyGeneratedThisHour;
                    liveStats.solarKwhGenerated += energyGeneratedThisHour; // All solar generated
                    if (challengeMode) {
                        challengeStats.solarKwhPossible += energyGeneratedThisHour;
                        challengeStats.solarKwhGenerated += energyGeneratedThisHour;
                    }
                    connections.filter(c => c.sourceNodeId === solarNode.id && solarNode.ports.find(p => p.id === c.sourcePortId))
                        .forEach(conn => {
                            const targetNode = findNodeById(conn.targetNodeId);
                            if (targetNode && targetNode.type === NODE_TYPES.RESOURCE_DISPLAY && targetNode.resourceType === RESOURCE_TYPES.POWER) {
                                const targetPort = targetNode.ports.find(p => p.id === conn.targetPortId);
                                if (targetPort && targetPort.type === 'input') {
                                    let amountToAdd = energyGeneratedThisHour;
                                    const roomLeftBefore = targetNode.maxCapacity != null ? (targetNode.maxCapacity - targetNode.value) : Infinity;
                                    if (targetNode.maxCapacity != null) {
                                        const roomLeft = targetNode.maxCapacity - targetNode.value;
                                        amountToAdd = Math.max(0, Math.min(amountToAdd, roomLeft));
                                    }
                                    targetNode.value += amountToAdd;
                                    // Track actual captured solar (only what was stored, not lost)
                                    liveStats.solarKwhCaptured += amountToAdd;
                                    // Track total kWh generated (all sources)
                                    liveStats.totalKwhGenerated += amountToAdd;
                                    if (challengeMode) {
                                        challengeStats.solarKwhCaptured += amountToAdd;
                                        challengeStats.totalKwhGenerated += amountToAdd;
                                    }
                                }
                            }
                        });
                }
                if (solarNode.config && solarNode.config.outputs && solarNode.config.outputs.length > 0) {
                    solarNode.config.outputs[0].rate = solarNode.currentOutput;
                }
            });

            // Execute automation rules for processors
            if (isPlaying) {
                const hourOfDay = elapsedHours % 24;
                nodes.filter(n => n.type === NODE_TYPES.PROCESSOR && n.automations && n.automations.length > 0).forEach(procNode => {
                    procNode.automations.forEach(automation => {
                        let shouldTrigger = false;
                        
                        if (automation.triggerType === 'timeOfDay') {
                            const startHour = automation.startHour || 18;
                            const endHour = automation.endHour || 6;
                            // Handle time ranges that cross midnight
                            if (startHour > endHour) {
                                shouldTrigger = hourOfDay >= startHour || hourOfDay < endHour;
                            } else {
                                shouldTrigger = hourOfDay >= startHour && hourOfDay < endHour;
                            }
                        } else if (automation.triggerType === 'batteryLevel') {
                            const targetNode = nodes.find(n => n.label === automation.targetNodeLabel);
                            if (targetNode && targetNode.maxCapacity && targetNode.maxCapacity > 0) {
                                const percentage = (targetNode.value / targetNode.maxCapacity) * 100;
                                if (automation.condition === 'above') {
                                    shouldTrigger = percentage > automation.threshold;
                                } else if (automation.condition === 'below') {
                                    shouldTrigger = percentage < automation.threshold;
                                }
                            }
                        } else if (automation.triggerType === 'solarInput') {
                            const targetNode = nodes.find(n => n.label === automation.targetNodeLabel && n.type === NODE_TYPES.SOLAR_ARRAY);
                            if (targetNode) {
                                if (automation.condition === 'zero') {
                                    shouldTrigger = targetNode.currentOutput <= 0.001;
                                } else if (automation.condition === 'aboveZero') {
                                    shouldTrigger = targetNode.currentOutput > 0.001;
                                }
                            }
                        } else if (automation.triggerType === 'containerValue') {
                            const targetNode = nodes.find(n => n.label === automation.targetNodeLabel);
                            if (targetNode) {
                                if (automation.condition === 'above') {
                                    shouldTrigger = targetNode.value > automation.threshold;
                                } else if (automation.condition === 'below') {
                                    shouldTrigger = targetNode.value < automation.threshold;
                                } else if (automation.condition === 'equals') {
                                    shouldTrigger = Math.abs(targetNode.value - automation.threshold) < 0.1;
                                }
                            }
                        }
                        
                        if (shouldTrigger) {
                            if (automation.action === 'turnOn' && !procNode.isRunning) {
                                procNode.isRunning = true;
                            } else if (automation.action === 'turnOff' && procNode.isRunning) {
                                procNode.isRunning = false;
                            }
                        } else {
                            // If trigger condition is false, reverse the action
                            // This allows a single "turnOn" rule to turn off when condition is false
                            if (automation.action === 'turnOn' && procNode.isRunning) {
                                procNode.isRunning = false;
                            } else if (automation.action === 'turnOff' && !procNode.isRunning) {
                                procNode.isRunning = true;
                            }
                        }
                    });
                });
                
                // Execute recipe automations for batch processors
                nodes.filter(n => n.type === NODE_TYPES.PROCESSOR && n.recipeAutomations && n.recipeAutomations.length > 0).forEach(procNode => {
                    procNode.recipeAutomations.forEach(auto => {
                        let shouldTrigger = false;
                        
                        if (auto.triggerType === 'timeOfDay') {
                            const startHour = auto.startHour || 8;
                            const endHour = auto.endHour || 9;
                            if (startHour > endHour) {
                                shouldTrigger = hourOfDay >= startHour || hourOfDay < endHour;
                            } else {
                                shouldTrigger = hourOfDay >= startHour && hourOfDay < endHour;
                            }
                        } else if (auto.triggerType === 'batteryLevel') {
                            const targetNode = nodes.find(n => n.label === auto.targetNodeLabel);
                            if (targetNode && targetNode.maxCapacity && targetNode.maxCapacity > 0) {
                                const percentage = (targetNode.value / targetNode.maxCapacity) * 100;
                                if (auto.condition === 'above') {
                                    shouldTrigger = percentage > auto.threshold;
                                } else if (auto.condition === 'below') {
                                    shouldTrigger = percentage < auto.threshold;
                                }
                            }
                        } else if (auto.triggerType === 'containerValue') {
                            const targetNode = nodes.find(n => n.label === auto.targetNodeLabel);
                            if (targetNode) {
                                if (auto.condition === 'above') {
                                    shouldTrigger = targetNode.value > auto.threshold;
                                } else if (auto.condition === 'below') {
                                    shouldTrigger = targetNode.value < auto.threshold;
                                }
                            }
                        }
                        
                        // When triggered, switch to the specified recipe and turn on
                        if (shouldTrigger && auto.recipeIndex >= 0 && procNode.recipes && procNode.recipes[auto.recipeIndex]) {
                            const recipe = procNode.recipes[auto.recipeIndex];
                            procNode.selectedRecipeIndex = auto.recipeIndex;
                            procNode.batchDuration = recipe.durationHrs;
                            // Update power rate
                            const powerInput = procNode.config.inputs.find(i => i.resourceType === RESOURCE_TYPES.POWER && !i.isBatchIO);
                            if (powerInput) {
                                powerInput.rate = recipe.powerRate;
                            }
                            procNode.isRunning = true;
                        }
                    });
                });
            }

            let batteryFailed = false; // Flag to track battery failure
            
            if (isPlaying) {
                nodes.filter(n => n.type === NODE_TYPES.PROCESSOR).forEach(procNode => { 
                    if (batteryFailed) return; // Skip if battery already failed
                    procNode.canProcessLastStep = false; 
                    if (!procNode.isRunning) return; 

                    let hasContinuousPower = true;
                    const continuousPowerDef = procNode.config.inputs.find(inp => inp.resourceType === RESOURCE_TYPES.POWER && !inp.isBatchIO);
                    if (continuousPowerDef) {
                        const powerConn = connections.find(c => c.targetNodeId === procNode.id && c.targetPortId === continuousPowerDef.portId);
                        if (!powerConn) { hasContinuousPower = false; }
                        else {
                            const powerSrc = findNodeById(powerConn.sourceNodeId);
                            if (!powerSrc || (powerSrc.type === NODE_TYPES.RESOURCE_DISPLAY && powerSrc.value < continuousPowerDef.rate && !powerSrc.isExternal) || (powerSrc.type === NODE_TYPES.SOLAR_ARRAY && powerSrc.currentOutput < continuousPowerDef.rate)) {
                                hasContinuousPower = false;
                            }
                        }
                    }
                    if (!hasContinuousPower) { procNode.isRunning = false; procNode.canProcessLastStep = false; return; }

                    // Determine if this is a batch processor and calculate time-based power consumption
                    const isCurrentProcessorBatchType = isBatchProcessor(procNode);
                    
                    // For batch processors, power consumption is proportional to actual batch duration
                    // Each simulation step = 1 hour. If batch takes 0.067 hours (4 min), only consume 0.067 of hourly rate
                    let powerMultiplier = 1.0; // Default: full hour of power consumption
                    
                    if (isCurrentProcessorBatchType && procNode.isInBatch) {
                        // Calculate remaining time in this batch
                        const remainingBatchTime = procNode.batchDuration - procNode.batchTimeElapsed;
                        // Only consume power for the time actually spent this step (max 1 hour)
                        powerMultiplier = Math.min(1.0, remainingBatchTime);
                    } else if (isCurrentProcessorBatchType && !procNode.isInBatch && procNode.isRunning) {
                        // Starting a new batch - consume power for the batch duration (or 1 hour max)
                        powerMultiplier = Math.min(1.0, procNode.batchDuration);
                    }

                    // Consume continuous power if available (scaled by powerMultiplier for batch processors)
                    if (continuousPowerDef && hasContinuousPower) {
                        const powerConn = connections.find(c => c.targetNodeId === procNode.id && c.targetPortId === continuousPowerDef.portId);
                        const powerSrc = findNodeById(powerConn.sourceNodeId);
                        const actualPowerConsumed = continuousPowerDef.rate * powerMultiplier;
                        if (powerSrc.type === NODE_TYPES.RESOURCE_DISPLAY) {
                            powerSrc.value -= actualPowerConsumed;
                            if (!powerSrc.isExternal && powerSrc.value < 0) powerSrc.value = 0;
                            // Check for battery failure immediately in challenge mode (after clamping)
                            if (challengeMode && isPlaying && !powerSrc.isExternal && powerSrc.resourceType === RESOURCE_TYPES.POWER) {
                                // Check if battery is effectively empty (displays as 0.0)
                                // Since values are displayed with 1 decimal place, check if value <= 0.05
                                if (powerSrc.value <= 0.05 || powerSrc.value === 0 || Math.abs(powerSrc.value) < 0.0001) {
                                    batteryFailed = true;
                                }
                            }
                        }
                        // Track power consumption (always track in liveStats) - for both RESOURCE_DISPLAY and SOLAR_ARRAY sources
                        const resType = RESOURCE_TYPES.POWER;
                        liveStats.resourcesConsumed[resType] = (liveStats.resourcesConsumed[resType] || 0) + actualPowerConsumed;
                        liveStats.totalKwhConsumed += actualPowerConsumed;
                        // If consuming directly from solar array, also count it as generated (it was generated and used)
                        if (powerSrc.type === NODE_TYPES.SOLAR_ARRAY) {
                            liveStats.totalKwhGenerated += actualPowerConsumed;
                        }
                        if (challengeMode) {
                            challengeStats.resourcesConsumed[resType] = (challengeStats.resourcesConsumed[resType] || 0) + actualPowerConsumed;
                            challengeStats.totalKwhConsumed += actualPowerConsumed;
                        }
                        procNode.canProcessLastStep = true;
                    } else if (!continuousPowerDef) {
                        procNode.canProcessLastStep = true;
                    }

                    if (isCurrentProcessorBatchType) {
                        if (!procNode.isInBatch) {
                            procNode.awaitingBatchInputs = true;
                            let allBatchInputsAvailable = true;
                            const batchInputs = procNode.config.inputs.filter(inp => inp.isBatchIO);
                            for (const batchInputDef of batchInputs) {
                                const conn = connections.find(c => c.targetNodeId === procNode.id && c.targetPortId === batchInputDef.portId);
                                if (!conn) { allBatchInputsAvailable = false; break; }
                                const srcNode = findNodeById(conn.sourceNodeId);
                                if (!srcNode || (srcNode.value < batchInputDef.rate && !srcNode.isExternal)) { allBatchInputsAvailable = false; break; }
                            }

                            if (allBatchInputsAvailable && batchInputs.length > 0) {
                                batchInputs.forEach(batchInputDef => {
                                    const conn = connections.find(c => c.targetNodeId === procNode.id && c.targetPortId === batchInputDef.portId);
                                    const srcNode = findNodeById(conn.sourceNodeId);
                                    srcNode.value -= batchInputDef.rate;
                                    if (!srcNode.isExternal && srcNode.value < 0) srcNode.value = 0;
                                    // Track resource consumption (only track net resources)
                                    const resType = batchInputDef.resourceType;
                                    if (isNetResource(resType)) {
                                        liveStats.resourcesConsumed[resType] = (liveStats.resourcesConsumed[resType] || 0) + batchInputDef.rate;
                                    }
                                    // Track power consumption separately
                                    if (resType === RESOURCE_TYPES.POWER) {
                                        liveStats.totalKwhConsumed += batchInputDef.rate;
                                        if (challengeMode) {
                                            challengeStats.totalKwhConsumed += batchInputDef.rate;
                                        }
                                    }
                                    if (challengeMode) {
                                        challengeStats.resourcesConsumed[resType] = (challengeStats.resourcesConsumed[resType] || 0) + batchInputDef.rate;
                                    }
                                });
                                procNode.isInBatch = true;
                                procNode.awaitingBatchInputs = false;
                                procNode.batchTimeElapsed = 0;
                                procNode.canProcessLastStep = true;
                            } else if (batchInputs.length > 0) {
                                procNode.canProcessLastStep = false;
                            }
                        }

                        if (procNode.isInBatch) { // Process active batch
                            procNode.canProcessLastStep = true; // If in batch and has power, it's processing
                             // Produce continuous outputs (scaled by time in batch this step)
                            const timeInBatchThisStep = Math.min(1.0, procNode.batchDuration - procNode.batchTimeElapsed);
                            procNode.config.outputs.filter(out => !out.isBatchIO).forEach(outputDef => {
                                connections.filter(c => c.sourceNodeId === procNode.id && c.sourcePortId === outputDef.portId)
                                    .forEach(conn => {
                                        const tgtNode = findNodeById(conn.targetNodeId);
                                        if (tgtNode && tgtNode.type === NODE_TYPES.RESOURCE_DISPLAY && tgtNode.resourceType === outputDef.resourceType) {
                                            let amountToAdd = outputDef.rate * timeInBatchThisStep;
                                            if (tgtNode.maxCapacity != null) {
                                                const roomLeft = tgtNode.maxCapacity - tgtNode.value;
                                                amountToAdd = Math.max(0, Math.min(amountToAdd, roomLeft));
                                            }
                                            tgtNode.value += amountToAdd;
                                            // Track resource production (only track net resources)
                                            const resType = outputDef.resourceType;
                                            if (isNetResource(resType)) {
                                                liveStats.resourcesProduced[resType] = (liveStats.resourcesProduced[resType] || 0) + amountToAdd;
                                            }
                                            // Track biochar production for eCO2 calculation
                                            if (resType === RESOURCE_TYPES.BIOCHAR) {
                                                liveStats.biocharProduced += amountToAdd;
                                                if (challengeMode) {
                                                    challengeStats.biocharProduced += amountToAdd;
                                                }
                                            }
                                            // Track power generation from non-solar sources (generators, etc)
                                            if (resType === RESOURCE_TYPES.POWER) {
                                                liveStats.totalKwhGenerated += amountToAdd;
                                            }
                                            if (challengeMode) {
                                                challengeStats.resourcesProduced[resType] = (challengeStats.resourcesProduced[resType] || 0) + amountToAdd;
                                            }
                                        }
                                    });
                            });
                            
                            // Advance batch time by 1 hour (1 simulation step)
                            procNode.batchTimeElapsed += 1;
                            // Check if batch is complete (batch duration is in hours)
                            if (procNode.batchTimeElapsed >= procNode.batchDuration) {
                                // Produce batch outputs
                                procNode.config.outputs.filter(out => out.isBatchIO).forEach(outputDef => {
                                    // Get the actual output rate from the selected recipe if available
                                    let outputRate = outputDef.rate;
                                    if (procNode.selectedRecipeIndex >= 0 && procNode.recipes && procNode.recipes[procNode.selectedRecipeIndex]) {
                                        const recipe = procNode.recipes[procNode.selectedRecipeIndex];
                                        const recipeOutput = (recipe.outputItems || []).find(o => o.name === outputDef.name);
                                        if (recipeOutput) outputRate = recipeOutput.qty || 1;
                                    }
                                    
                                    connections.filter(c => c.sourceNodeId === procNode.id && c.sourcePortId === outputDef.portId)
                                        .forEach(conn => {
                                            const tgtNode = findNodeById(conn.targetNodeId);
                                            // Allow USER_DEFINED to connect to any USER_DEFINED container
                                            const resourceMatch = tgtNode.resourceType === outputDef.resourceType || 
                                                (outputDef.resourceType === RESOURCE_TYPES.USER_DEFINED && tgtNode.resourceType === RESOURCE_TYPES.USER_DEFINED);
                                            if (tgtNode && tgtNode.type === NODE_TYPES.RESOURCE_DISPLAY && resourceMatch) {
                                                let amountToAdd = outputRate;
                                                if (tgtNode.maxCapacity != null) {
                                                    const roomLeft = tgtNode.maxCapacity - tgtNode.value;
                                                    amountToAdd = Math.max(0, Math.min(amountToAdd, roomLeft));
                                                }
                                                tgtNode.value += amountToAdd;
                                            // Track resource production (only track net resources)
                                            const resType = outputDef.resourceType;
                                            if (isNetResource(resType)) {
                                                liveStats.resourcesProduced[resType] = (liveStats.resourcesProduced[resType] || 0) + amountToAdd;
                                            }
                                            // Track biochar production for eCO2 calculation
                                            if (resType === RESOURCE_TYPES.BIOCHAR) {
                                                liveStats.biocharProduced += amountToAdd;
                                                if (challengeMode) {
                                                    challengeStats.biocharProduced += amountToAdd;
                                                }
                                            }
                                            // Track power generation from non-solar sources (generators, etc)
                                            if (resType === RESOURCE_TYPES.POWER) {
                                                liveStats.totalKwhGenerated += amountToAdd;
                                            }
                                            if (challengeMode) {
                                                challengeStats.resourcesProduced[resType] = (challengeStats.resourcesProduced[resType] || 0) + amountToAdd;
                                            }
                                        }
                                    });
                                });
                                procNode.isInBatch = false;
                                procNode.batchTimeElapsed = 0;
                                procNode.isRunning = false; // Batch complete, turn off
                                procNode.awaitingBatchInputs = false;
                            }
                        }
                    } else { // Standard continuous processor
                        let canProcessContinuousInputs = true;
                        for (const inputDef of procNode.config.inputs.filter(inp => !inp.isBatchIO)) {
                            const conn = connections.find(c => c.targetNodeId === procNode.id && c.targetPortId === inputDef.portId);
                            if (!conn) { canProcessContinuousInputs = false; break; }
                            const srcNode = findNodeById(conn.sourceNodeId);
                            if (!srcNode || srcNode.resourceType !== inputDef.resourceType) { canProcessContinuousInputs = false; break; }
                            if (srcNode.type === NODE_TYPES.RESOURCE_DISPLAY) {
                                if (!srcNode.isSource && srcNode.value < inputDef.rate && !srcNode.isExternal) { canProcessContinuousInputs = false; break; }
                            } else if (srcNode.type === NODE_TYPES.SOLAR_ARRAY && srcNode.currentOutput < inputDef.rate) {
                                canProcessContinuousInputs = false;
                                break;
                            }
                        }
                        
                        if (canProcessContinuousInputs) {
                            procNode.canProcessLastStep = true;
                            procNode.config.inputs.filter(inp => !inp.isBatchIO).forEach(inputDef => {
                                // Skip power consumption if it was already consumed in the continuous power section
                                if (inputDef.resourceType === RESOURCE_TYPES.POWER && continuousPowerDef) {
                                    // Power was already consumed above, skip to avoid double consumption
                                    return;
                                }
                                const conn = connections.find(c => c.targetNodeId === procNode.id && c.targetPortId === inputDef.portId);
                                const srcNode = findNodeById(conn.sourceNodeId);
                                if (srcNode.type === NODE_TYPES.RESOURCE_DISPLAY) {
                                    srcNode.value -= inputDef.rate;
                                    if (!srcNode.isSource && !srcNode.isExternal && srcNode.value < 0) srcNode.value = 0;
                                    // Check for battery failure immediately in challenge mode (after clamping)
                                    if (challengeMode && isPlaying && !srcNode.isExternal && srcNode.resourceType === RESOURCE_TYPES.POWER) {
                                        // Check if battery is effectively empty (displays as 0.0)
                                        // Since values are displayed with 1 decimal place, check if value <= 0.05
                                        if (srcNode.value <= 0.05 || srcNode.value === 0 || Math.abs(srcNode.value) < 0.0001) {
                                            batteryFailed = true;
                                        }
                                    }
                                }
                                // Track resource consumption (only track net resources) - for both RESOURCE_DISPLAY and SOLAR_ARRAY sources
                                const resType = inputDef.resourceType;
                                if (isNetResource(resType)) {
                                    liveStats.resourcesConsumed[resType] = (liveStats.resourcesConsumed[resType] || 0) + inputDef.rate;
                                }
                                // Track woodgas consumption for eCO2 calculation (woodgas is in cubic meters)
                                if (resType === RESOURCE_TYPES.POOP_GAS) {
                                    liveStats.woodgasConsumed += inputDef.rate;
                                    if (challengeMode) {
                                        challengeStats.woodgasConsumed += inputDef.rate;
                                    }
                                }
                                // Track power consumption separately
                                if (resType === RESOURCE_TYPES.POWER) {
                                    liveStats.totalKwhConsumed += inputDef.rate;
                                    // If consuming directly from solar array, also count it as generated (it was generated and used)
                                    if (srcNode.type === NODE_TYPES.SOLAR_ARRAY) {
                                        liveStats.totalKwhGenerated += inputDef.rate;
                                    }
                                    if (challengeMode) {
                                        challengeStats.totalKwhConsumed += inputDef.rate;
                                    }
                                }
                                if (challengeMode) {
                                    challengeStats.resourcesConsumed[resType] = (challengeStats.resourcesConsumed[resType] || 0) + inputDef.rate;
                                }
                            });
                            procNode.config.outputs.filter(out => !out.isBatchIO).forEach(outputDef => {
                                connections.filter(c => c.sourceNodeId === procNode.id && c.sourcePortId === outputDef.portId)
                                    .forEach(conn => {
                                        const tgtNode = findNodeById(conn.targetNodeId);
                                        if (tgtNode && tgtNode.type === NODE_TYPES.RESOURCE_DISPLAY && tgtNode.resourceType === outputDef.resourceType) {
                                            let amountToAdd = outputDef.rate;
                                            if (tgtNode.maxCapacity != null) {
                                                const roomLeft = tgtNode.maxCapacity - tgtNode.value;
                                                amountToAdd = Math.max(0, Math.min(amountToAdd, roomLeft));
                                            }
                                            tgtNode.value += amountToAdd;
                                                // Track resource production (only track net resources)
                                                const resType = outputDef.resourceType;
                                                if (isNetResource(resType)) {
                                                    liveStats.resourcesProduced[resType] = (liveStats.resourcesProduced[resType] || 0) + amountToAdd;
                                                }
                                                // Track biochar production for eCO2 calculation
                                                if (resType === RESOURCE_TYPES.BIOCHAR) {
                                                    liveStats.biocharProduced += amountToAdd;
                                                    if (challengeMode) {
                                                        challengeStats.biocharProduced += amountToAdd;
                                                    }
                                                }
                                                // Track power generation from non-solar sources (generators, etc)
                                                if (resType === RESOURCE_TYPES.POWER) {
                                                    liveStats.totalKwhGenerated += amountToAdd;
                                                }
                                                if (challengeMode) {
                                                    challengeStats.resourcesProduced[resType] = (challengeStats.resourcesProduced[resType] || 0) + amountToAdd;
                                                }
                                            }
                                        });
                                });
                        } else {
                            procNode.canProcessLastStep = false;
                            procNode.isRunning = false; // Auto-stop if continuous inputs fail
                        }
                    }
                    if (!procNode.canProcessLastStep && procNode.isRunning && !procNode.awaitingBatchInputs) {
                        procNode.isRunning = false;
                    }
                });
            }
            
            // Check for battery failure in challenge mode (at end of step, after all consumption)
            if (challengeMode && isPlaying) {
                // Check if battery failed during processing or check all batteries now
                if (!batteryFailed) {
                    const batteryNodes = nodes.filter(n => n.type === NODE_TYPES.RESOURCE_DISPLAY && n.resourceType === RESOURCE_TYPES.POWER && !n.isExternal);
                    batteryFailed = batteryNodes.some(b => {
                        const val = b.value || 0; // Handle undefined/null
                        // Check if battery is effectively empty (displays as 0.0)
                        // Since values are displayed with 1 decimal place, check if value <= 0.05
                        // Also check for exactly 0 or very close to 0 (accounting for floating point precision)
                        return val <= 0.05 || val === 0 || Math.abs(val) < 0.0001;
                    });
                }
                
                if (batteryFailed) {
                    // Stop simulation immediately
                    isPlaying = false;
                    // Phase 1: RAF loop handles stopping automatically when isPlaying is false
                    // Show failure screen
                    showChallengeFailure();
                    scheduleRender(); // Phase 1: Use batched render
                    return;
                }
            }
            
            // Update live stats bar
            updateLiveStatsBar();
            
            render();
        }
        
        // Phase 1: RAF-based simulation loop
        let lastFrameTime = 0;
        let animationFrameId = null;
        
        function animationLoop(currentTime) {
            if (isPlaying) {
                const deltaTime = currentTime - lastFrameTime;
                if (deltaTime >= currentSimSpeedMs) {
                    simulateStep();
                    lastFrameTime = currentTime;
                }
            }
            animationFrameId = requestAnimationFrame(animationLoop);
        }
        
        const playPauseBtn=document.getElementById("playPauseButton"); 
        const speedSlider=document.getElementById("speedSlider"); 
        const speedLabel=document.querySelector(".speed-label"); 
        
        function setSimulationSpeed(){ 
            currentSimSpeedMs = baseSimSpeedMs / (parseInt(speedSlider.value) / 1000); 
            currentSimSpeedMs = Math.max(50, Math.min(4000, currentSimSpeedMs)); 
            let multiplier = baseSimSpeedMs / currentSimSpeedMs; 
            speedLabel.textContent = `${multiplier.toFixed(1)}x`; 
            // Phase 1: RAF loop handles timing, no need to restart interval
        } 
        speedSlider.addEventListener("input",setSimulationSpeed); 
        
        function playPauseSimulation(){ 
            isPlaying=!isPlaying; 
            playPauseBtn.innerHTML=isPlaying?"&#10074;&#10074;":"&#9658;"; 
            if(isPlaying){ 
                // Phase 1: Start RAF loop if not already running
                if (!animationFrameId) {
                    lastFrameTime = performance.now();
                    animationFrameId = requestAnimationFrame(animationLoop);
                }
            } else { 
                // Phase 1: Stop RAF loop
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                scheduleRender(); // Use batched render
            } 
        }
        
        // Phase 1: Initialize RAF loop (always running, but only simulates when isPlaying)
        lastFrameTime = performance.now();
        animationFrameId = requestAnimationFrame(animationLoop); 
        // Initialize button text to match initial state (paused = play button)
        playPauseBtn.innerHTML = isPlaying ? "&#10074;&#10074;" : "&#9658;";
        playPauseBtn.addEventListener("click",playPauseSimulation);
        function updateTimeDisplay(){ const day = Math.floor(elapsedHours / 24) + 1; const hourInDay = elapsedHours % 24; d3.select(".time-display").text(`${elapsedHours} total hours (Day ${day}, ${String(hourInDay).padStart(2,'0')}:00)`); updateLiveStatsBar(); } 
        // Phase 1: Replace render() with scheduleRender() for all add node buttons
        document.getElementById("addPlasticTrash").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'PlasticTrash'}));scheduleRender();}); 
        document.getElementById("addShredder").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Shredder'}));scheduleRender();}); 
        document.getElementById("addSolarArray").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.SOLAR_ARRAY));scheduleRender();}); 
        document.getElementById("addBiocharReactor").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'BiocharReactor'}));scheduleRender();}); 
        document.getElementById("addPlasticFlakes").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'PlasticFlakes'}));scheduleRender();}); 
        document.getElementById("addTrashPrinter").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'TrashPrinter'}));scheduleRender();}); 
        document.getElementById("addWindTurbines").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'WindTurbines'}));scheduleRender();}); 
        document.getElementById("addBatteryBank").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'BatteryBank'}));scheduleRender();}); 
        document.getElementById("addBiomass").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'Biomass'}));scheduleRender();}); 
        document.getElementById("addPoopGas").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'PoopGas'}));scheduleRender();}); 
        document.getElementById("addBiochar").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.RESOURCE_DISPLAY, {subType: 'Biochar'}));scheduleRender();});
        
        // ========== APPLIANCE LIBRARY EVENT LISTENERS ==========
        // Kitchen Appliances
        document.getElementById("addMicrowave").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Microwave'}));scheduleRender();});
        document.getElementById("addElectricKettle").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'ElectricKettle'}));scheduleRender();});
        document.getElementById("addToaster").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Toaster'}));scheduleRender();});
        document.getElementById("addCoffeeMaker").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'CoffeeMaker'}));scheduleRender();});
        document.getElementById("addRefrigerator").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Refrigerator'}));scheduleRender();});
        document.getElementById("addFreezer").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Freezer'}));scheduleRender();});
        document.getElementById("addDishwasher").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Dishwasher'}));scheduleRender();});
        document.getElementById("addElectricStove").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'ElectricStove'}));scheduleRender();});
        document.getElementById("addBlender").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Blender'}));scheduleRender();});
        document.getElementById("addRiceCooker").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'RiceCooker'}));scheduleRender();});
        // Laundry & Cleaning
        document.getElementById("addWashingMachine").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'WashingMachine'}));scheduleRender();});
        document.getElementById("addClothesDryer").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'ClothesDryer'}));scheduleRender();});
        document.getElementById("addVacuumCleaner").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'VacuumCleaner'}));scheduleRender();});
        document.getElementById("addIron").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Iron'}));scheduleRender();});
        // Climate Control
        document.getElementById("addAirConditioner").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'AirConditioner'}));scheduleRender();});
        document.getElementById("addSpaceHeater").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'SpaceHeater'}));scheduleRender();});
        document.getElementById("addCeilingFan").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'CeilingFan'}));scheduleRender();});
        document.getElementById("addPortableFan").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'PortableFan'}));scheduleRender();});
        document.getElementById("addDehumidifier").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Dehumidifier'}));scheduleRender();});
        document.getElementById("addHumidifier").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Humidifier'}));scheduleRender();});
        // Water Heating
        document.getElementById("addWaterHeater").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'WaterHeater'}));scheduleRender();});
        document.getElementById("addInstantWaterHeater").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'InstantWaterHeater'}));scheduleRender();});
        document.getElementById("addWaterPump").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'WaterPump'}));scheduleRender();});
        // Lighting
        document.getElementById("addLEDLights").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'LEDLights'}));scheduleRender();});
        document.getElementById("addCFLBulb").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'CFLBulb'}));scheduleRender();});
        document.getElementById("addIncandescentBulb").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'IncandescentBulb'}));scheduleRender();});
        document.getElementById("addFloodlight").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Floodlight'}));scheduleRender();});
        // Electronics & Office
        document.getElementById("addPhoneCharger").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'PhoneCharger'}));scheduleRender();});
        document.getElementById("addLaptop").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Laptop'}));scheduleRender();});
        document.getElementById("addDesktopPC").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'DesktopPC'}));scheduleRender();});
        document.getElementById("addGamingPC").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'GamingPC'}));scheduleRender();});
        document.getElementById("addMonitor").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Monitor'}));scheduleRender();});
        document.getElementById("addTV").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'TV'}));scheduleRender();});
        document.getElementById("addGameConsole").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'GameConsole'}));scheduleRender();});
        document.getElementById("addWiFiRouter").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'WiFiRouter'}));scheduleRender();});
        document.getElementById("addPrinter").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Printer'}));scheduleRender();});
        // Personal Care
        document.getElementById("addHairDryer").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'HairDryer'}));scheduleRender();});
        document.getElementById("addElectricShaver").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'ElectricShaver'}));scheduleRender();});
        document.getElementById("addCurlingIron").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'CurlingIron'}));scheduleRender();});
        // Power Tools
        document.getElementById("addDrill").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'Drill'}));scheduleRender();});
        document.getElementById("addCircularSaw").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'CircularSaw'}));scheduleRender();});
        document.getElementById("addAngleGrinder").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'AngleGrinder'}));scheduleRender();});
        document.getElementById("addAirCompressor").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'AirCompressor'}));scheduleRender();});
        // EV & Transport
        document.getElementById("addEVChargerL1").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'EVChargerL1'}));scheduleRender();});
        document.getElementById("addEVChargerL2").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'EVChargerL2'}));scheduleRender();});
        document.getElementById("addEBikeCharger").addEventListener("click",()=>{nodes.push(createNode(NODE_TYPES.PROCESSOR, {subType: 'EBikeCharger'}));scheduleRender();});
        // ========== END APPLIANCE LIBRARY EVENT LISTENERS ==========
        
        const customNodeImageURL=document.getElementById("customNodeImageURL");const customInputsContainer=document.getElementById("customInputsContainer");const customOutputsContainer=document.getElementById("customOutputsContainer"); const customBatchDurationInput = document.getElementById("customBatchDuration"); function addCustomIOField(type){inspectorIoItemIdCounter++;const container=type==='input'?customInputsContainer:customOutputsContainer;const div=document.createElement("div");div.className='io-item';div.id=`custom-io-${inspectorIoItemIdCounter}`;let resOptsHTML="";for(const key in RESOURCE_TYPES){resOptsHTML+=`<option value="${RESOURCE_TYPES[key]}">${RESOURCE_TYPES[key]}</option>`;}div.innerHTML=`<label>Port Name: <input type="text" name="io_name" placeholder="e.g., Raw Material"></label><label>Resource Type: <select name="io_resource">${resOptsHTML}</select></label><label>Rate (per hour/batch): <input type="number" name="io_rate" value="1" step="0.001" min="0"></label><label><input type="checkbox" name="io_is_batch"> Batch I/O</label><button onclick="event.stopPropagation(); this.parentElement.remove()" style="width:auto;float:right;background-color:#c55;">X</button>`;container.appendChild(div);}document.getElementById("addCustomInput").addEventListener("click",()=>addCustomIOField('input'));document.getElementById("addCustomOutput").addEventListener("click",()=>addCustomIOField('output'));document.getElementById("createCustomNodeInstance").addEventListener("click",()=>{const nodeName=document.getElementById("customNodeName").value||"Custom Processor";const imgURL=customNodeImageURL.value.trim()||null;const batchDuration = parseInt(customBatchDurationInput.value) || 6; const cfg={inputs:[],outputs:[]};document.querySelectorAll("#customInputsContainer .io-item").forEach(item=>{cfg.inputs.push({name:item.querySelector('[name="io_name"]').value||"Input",resourceType:item.querySelector('[name="io_resource"]').value,rate:parseFloat(item.querySelector('[name="io_rate"]').value)||1, isBatchIO: item.querySelector('[name="io_is_batch"]').checked});});document.querySelectorAll("#customOutputsContainer .io-item").forEach(item=>{cfg.outputs.push({name:item.querySelector('[name="io_name"]').value||"Output",resourceType:item.querySelector('[name="io_resource"]').value,rate:parseFloat(item.querySelector('[name="io_rate"]').value)||1, isBatchIO: item.querySelector('[name="io_is_batch"]').checked});});const newNode=createNode(NODE_TYPES.PROCESSOR, {subType: 'CustomProcessor', label:nodeName,img:imgURL,config:cfg, batchDuration: batchDuration});if(newNode){nodes.push(newNode);render();}});
        // Embedded default system state from ecosystem_simulation JSON
        const defaultSystemState = {"nodes":[{"id":"node-1","x":1207.6202993392944,"y":-836.9216022491455,"ports":[{"id":"p-1-out-solar","type":"output","resourceType":"Power","name":"Power Out","side":"bottom","yOffsetRatio":0.5}],"width":200,"height":300,"label":"SOLAR ARRAY","img":"https://5.imimg.com/data5/SELLER/Default/2023/6/318119700/PH/RI/RQ/191218348/solar-panels-250x250.jpg","canProcessLastStep":false,"type":"solar-array","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"ratedOutput":3.75,"currentOutput":0,"config":{"inputs":[],"outputs":[{"portId":"p-1-out-solar","name":"Solar Power","resourceType":"Power","rate":0}]},"isRunning":false,"automations":[],"portOrientation":"vertical","flipped":false},{"id":"node-2","x":1209.3341369628906,"y":-369.39020919799805,"ports":[{"id":"p-2-in-power","type":"input","resourceType":"Power","name":"Charge In","side":"top","yOffsetRatio":0.5},{"id":"p-2-out-power","type":"output","resourceType":"Power","name":"Power Out","side":"bottom","yOffsetRatio":0.5}],"width":200,"height":280,"label":"BATTERY BANK","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":5.2,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"BatteryBank","value":5,"unit":"kWh","resourceType":"Power","isExternal":false,"passiveGeneration":0,"isRunning":false,"portOrientation":"vertical","flipped":false},{"id":"node-3","x":824.0451974868774,"y":-819.1492576599121,"ports":[{"id":"p-3-out-0","type":"output","resourceType":"Plastic","name":"Plastic Out","side":"bottom","yOffsetRatio":0.5}],"width":220,"height":220,"label":"PLASTIC TRASH","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"PlasticTrash","value":0,"unit":"Kilograms","resourceType":"Plastic","isExternal":true,"passiveGeneration":0,"isSource":true,"isRunning":false,"automations":[],"portOrientation":"vertical","flipped":false},{"id":"node-4","x":380.1853942871094,"y":-380.66625213623047,"ports":[{"id":"p-node-4-in-0","type":"input","resourceType":"Plastic","name":"PLASTIC TRASH","side":"top","yOffsetRatio":0.5},{"id":"p-node-4-in-1","type":"input","resourceType":"Power","name":"POWER","side":"top","yOffsetRatio":0.5},{"id":"p-node-4-out-0","type":"output","resourceType":"Plastic Flakes","name":"SHREDDED PLASTIC","side":"bottom","yOffsetRatio":0.5}],"width":200,"height":320,"label":"PLASTIC SHREDDER","img":"https://bazar.preciousplastic.com/images/thumbnails/500/502/detailed/21/ShredderBasic.png","canProcessLastStep":false,"type":"processor","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"Shredder","isRunning":false,"config":{"inputs":[{"name":"PLASTIC TRASH","resourceType":"Plastic","rate":1,"isBatchIO":false,"portId":"p-node-4-in-0"},{"name":"POWER","resourceType":"Power","rate":0.3,"isBatchIO":false,"portId":"p-node-4-in-1"}],"outputs":[{"name":"SHREDDED PLASTIC","resourceType":"Plastic Flakes","rate":1,"isBatchIO":false,"color":"#ffff00","portId":"p-node-4-out-0"}]},"automations":[{"triggerType":"batteryLevel","action":"turnOn","targetNodeLabel":"BATTERY BANK","threshold":60,"condition":"above"},{"triggerType":"containerValue","action":"turnOn","targetNodeLabel":"PLASTIC FLAKES","threshold":1,"condition":"below"},{"triggerType":"batteryLevel","action":"turnOff","targetNodeLabel":"BATTERY BANK","threshold":75,"condition":"below"}],"portOrientation":"vertical","flipped":false},{"id":"node-5","x":106.8870849609375,"y":10.236340522766113,"ports":[{"id":"p-5-in-0","type":"input","resourceType":"Plastic Flakes","name":"Flakes In","side":"top","yOffsetRatio":0.5},{"id":"p-5-out-0","type":"output","resourceType":"Plastic Flakes","name":"Flakes Out","side":"bottom","yOffsetRatio":0.5}],"width":220,"height":220,"label":"PLASTIC FLAKES","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":50,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"PlasticFlakes","value":0,"unit":"Kilograms","resourceType":"Plastic Flakes","isExternal":false,"passiveGeneration":0,"isRunning":false,"portOrientation":"vertical","flipped":false},{"id":"node-6","x":428.310791015625,"y":321.9262466430664,"ports":[{"id":"p-node-6-in-0","type":"input","resourceType":"Plastic Flakes","name":"SHREDDED PLASTIC","side":"top","yOffsetRatio":0.5},{"id":"p-node-6-in-1","type":"input","resourceType":"Power","name":"POWER","side":"top","yOffsetRatio":0.5},{"id":"p-node-6-out-0","type":"output","resourceType":"Wind Turbines","name":"Recyled Plastic","side":"bottom","yOffsetRatio":0.5}],"width":200,"height":320,"label":"TRASH PRINTER","img":"https://cdn.hackaday.io/images/resize/600x600/6327351654226121140.jpg","canProcessLastStep":false,"type":"processor","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"TrashPrinter","isRunning":false,"config":{"inputs":[{"name":"SHREDDED PLASTIC","resourceType":"Plastic Flakes","rate":0.2,"isBatchIO":false,"portId":"p-node-6-in-0"},{"name":"POWER","resourceType":"Power","rate":0.2,"isBatchIO":false,"portId":"p-node-6-in-1"}],"outputs":[{"name":"Recyled Plastic","resourceType":"Wind Turbines","rate":0.2,"isBatchIO":false,"color":"#2dae2f","portId":"p-node-6-out-0"}]},"automations":[{"triggerType":"containerValue","action":"turnOn","targetNodeLabel":"PLASTIC FLAKES","threshold":25,"condition":"above"},{"triggerType":"batteryLevel","action":"turnOff","targetNodeLabel":"BATTERY BANK","threshold":60,"condition":"below"}],"portOrientation":"vertical","flipped":false},{"id":"node-7","x":426.605712890625,"y":677.1534576416016,"ports":[{"id":"p-7-in-0","type":"input","resourceType":"Wind Turbines","name":"Turbines In","side":"top","yOffsetRatio":0.5}],"width":220,"height":220,"label":"PLASTIC PARTS","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"WindTurbines","value":0,"unit":"Kilograms","resourceType":"Wind Turbines","isExternal":false,"passiveGeneration":0,"isRunning":false,"portOrientation":"vertical","flipped":false},{"id":"node-8","x":1602.5217599868774,"y":-830.0430603027344,"ports":[{"id":"p-8-out-0","type":"output","resourceType":"Biomass","name":"Biomass Out","side":"bottom","yOffsetRatio":0.5}],"width":220,"height":220,"label":"BIOMASS WASTE","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"Biomass","value":0,"unit":"Kilograms","resourceType":"Biomass","isExternal":true,"passiveGeneration":0,"isSource":true,"isRunning":false,"automations":[],"portOrientation":"vertical","flipped":false},{"id":"node-9","x":1815.5245971679688,"y":293.75970458984375,"ports":[{"id":"p-node-9-in-0","type":"input","resourceType":"Power","name":"POWER","side":"top","yOffsetRatio":0.5},{"id":"p-node-9-in-1","type":"input","resourceType":"Biomass","name":"BIOMASS","side":"top","yOffsetRatio":0.5},{"id":"p-node-9-out-0","type":"output","resourceType":"Woodgas","name":"WOODGAS","side":"bottom","yOffsetRatio":0.5},{"id":"p-node-9-out-1","type":"output","resourceType":"Biochar","name":"BIOCHAR","side":"bottom","yOffsetRatio":0.5}],"width":200,"height":320,"label":"BIOCHAR REACTOR","img":"https://c10.patreonusercontent.com/4/patreon-media/p/post/135336097/de7e396e205546f99fb3f32e0a29c66c/eyJhIjoxLCJ3Ijo4MjB9/1.jpg?token-hash=8Dzz0gAvxBAcw6Fu1QaVnfbzQQTdu-08x4g5KRv0fuc%3D&token-time=1764806400","canProcessLastStep":false,"type":"processor","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"BiocharReactor","isRunning":false,"config":{"inputs":[{"name":"POWER","resourceType":"Power","rate":1,"isBatchIO":false,"portId":"p-node-9-in-0"},{"name":"BIOMASS","resourceType":"Biomass","rate":5,"isBatchIO":true,"portId":"p-node-9-in-1"}],"outputs":[{"name":"WOODGAS","resourceType":"Woodgas","rate":0.25,"isBatchIO":false,"color":"#d3d3d3","portId":"p-node-9-out-0"},{"name":"BIOCHAR","resourceType":"Biochar","rate":1,"isBatchIO":true,"color":"#000000","portId":"p-node-9-out-1"}]},"automations":[{"triggerType":"timeOfDay","action":"turnOn","startHour":10,"endHour":16}],"portOrientation":"vertical","flipped":false},{"id":"node-10","x":2005.1778564453125,"y":702.9992065429688,"ports":[{"id":"p-10-in-0","type":"input","resourceType":"Woodgas","name":"Gas In","side":"left","yOffsetRatio":0.5},{"id":"p-10-out-0","type":"output","resourceType":"Woodgas","name":"Gas Out","side":"right","yOffsetRatio":0.5}],"width":220,"height":220,"label":"WOODGAS","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":10,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"PoopGas","value":0,"unit":"Cubic Meters","resourceType":"Woodgas","isExternal":false,"passiveGeneration":0,"isRunning":false,"automations":[],"portOrientation":"horizontal","flipped":false},{"id":"node-11","x":1605.122314453125,"y":699.0422058105469,"ports":[{"id":"p-11-in-0","type":"input","resourceType":"Biochar","name":"Biochar In","side":"top","yOffsetRatio":0.5},{"id":"p-11-out-0","type":"output","resourceType":"Biochar","name":"Biochar Out","side":"bottom","yOffsetRatio":0.5}],"width":220,"height":220,"label":"BIOCHAR","img":null,"canProcessLastStep":false,"type":"resource-display","maxCapacity":50,"progressColor":"#6fa06c","batchDuration":6,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"Biochar","value":0,"unit":"Kilograms","resourceType":"Biochar","isExternal":false,"passiveGeneration":0,"isRunning":false,"automations":[],"portOrientation":"vertical","flipped":false},{"id":"node-14","x":778.1149065352583,"y":307.9825326881794,"ports":[{"id":"p-node-14-in-0","type":"input","resourceType":"Power","name":"Power","side":"top","yOffsetRatio":0.5}],"width":200,"height":320,"label":"LED Path Lights","img":"https://media.diy.com/is/image/Kingfisher/smart-garden-festoon-solar-powered-20-led-outdoor-string-lights-pack-of-1~5050642088503_01i_bq?$MOB_PREV$&$width=600&$height=600","canProcessLastStep":false,"type":"processor","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":1,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"CustomProcessor","config":{"inputs":[{"name":"Power","resourceType":"Power","rate":0.04,"isBatchIO":false,"portId":"p-node-14-in-0"}],"outputs":[]},"isRunning":false,"automations":[{"triggerType":"timeOfDay","action":"turnOn","startHour":18,"endHour":6}],"portOrientation":"vertical","flipped":false},{"id":"node-16","x":1208.8170502624434,"y":311.860613248233,"ports":[{"id":"p-node-16-in-0","type":"input","resourceType":"Power","name":"Power","side":"top","yOffsetRatio":0.5},{"id":"p-node-16-out-0","type":"output","resourceType":"Custom Product A","name":"Charged Devices","side":"bottom","yOffsetRatio":0.5}],"width":200,"height":320,"label":"Charging Station","img":"https://m.media-amazon.com/images/I/61dRrt1VsaL._AC_SL1291_.jpg","canProcessLastStep":false,"type":"processor","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":1,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"CustomProcessor","config":{"inputs":[{"name":"Power","resourceType":"Power","rate":0.2,"isBatchIO":false,"portId":"p-node-16-in-0"}],"outputs":[{"name":"Charged Devices","resourceType":"Custom Product A","rate":2,"isBatchIO":false,"color":"#808080","portId":"p-node-16-out-0"}]},"isRunning":false,"automations":[{"triggerType":"batteryLevel","action":"turnOn","targetNodeLabel":"BATTERY BANK","threshold":75,"condition":"above"},{"triggerType":"batteryLevel","action":"turnOff","targetNodeLabel":"BATTERY BANK","threshold":75,"condition":"below"}],"portOrientation":"vertical","flipped":false},{"id":"node-17","type":"resource-display","x":1210.4491489234924,"y":693.3931732177734,"width":220,"height":220,"label":"CHARGED DEVICES","resourceType":"Custom Product A","unit":"Charged Phones","maxCapacity":null,"value":0,"ports":[{"id":"p-17-in-0","type":"input","resourceType":"Custom Product A","name":"Custom Product A In","side":"top","yOffsetRatio":0.5},{"id":"p-17-out-0","type":"output","resourceType":"Custom Product A","name":"Custom Product A Out","side":"bottom","yOffsetRatio":0.5}],"img":null,"passiveGeneration":0,"progressColor":"#6fa06c","isExternal":false,"canProcessLastStep":false,"isRunning":false,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"portOrientation":"vertical","flipped":false},{"id":"node-18","x":2134.1281889915936,"y":-362.4044654059078,"ports":[{"id":"p-node-18-in-0","type":"input","resourceType":"Woodgas","name":"Woodgas","side":"bottom","yOffsetRatio":0.5},{"id":"p-node-18-out-0","type":"output","resourceType":"Power","name":"Power","side":"top","yOffsetRatio":0.5}],"width":200,"height":320,"label":"Modified Generator","img":"https://i.ebayimg.com/images/g/POcAAOSwdYNi3Bi7/s-l1600.webp","canProcessLastStep":false,"type":"processor","maxCapacity":null,"progressColor":"#6fa06c","batchDuration":1,"batchTimeElapsed":0,"isInBatch":false,"awaitingBatchInputs":false,"subType":"CustomProcessor","config":{"inputs":[{"name":"Woodgas","resourceType":"Woodgas","rate":1,"isBatchIO":false,"portId":"p-node-18-in-0"}],"outputs":[{"name":"Power","resourceType":"Power","rate":0.7,"isBatchIO":false,"color":"#ff0000","portId":"p-node-18-out-0"}]},"isRunning":false,"automations":[{"triggerType":"containerValue","action":"turnOn","targetNodeLabel":"WOODGAS","threshold":2,"condition":"above"},{"triggerType":"batteryLevel","action":"turnOff","targetNodeLabel":"BATTERY BANK","threshold":75,"condition":"above"}],"portOrientation":"vertical","flipped":true}],"connections":[{"id":"conn-1","sourceNodeId":"node-1","sourcePortId":"p-1-out-solar","targetNodeId":"node-2","targetPortId":"p-2-in-power"},{"id":"conn-2","sourceNodeId":"node-2","sourcePortId":"p-2-out-power","targetNodeId":"node-4","targetPortId":"p-node-4-in-1"},{"id":"conn-3","sourceNodeId":"node-2","sourcePortId":"p-2-out-power","targetNodeId":"node-6","targetPortId":"p-node-6-in-1"},{"id":"conn-4","sourceNodeId":"node-2","sourcePortId":"p-2-out-power","targetNodeId":"node-9","targetPortId":"p-node-9-in-0"},{"id":"conn-5","sourceNodeId":"node-3","sourcePortId":"p-3-out-0","targetNodeId":"node-4","targetPortId":"p-node-4-in-0"},{"id":"conn-6","sourceNodeId":"node-4","sourcePortId":"p-node-4-out-0","targetNodeId":"node-5","targetPortId":"p-5-in-0"},{"id":"conn-7","sourceNodeId":"node-5","sourcePortId":"p-5-out-0","targetNodeId":"node-6","targetPortId":"p-node-6-in-0"},{"id":"conn-9","sourceNodeId":"node-8","sourcePortId":"p-8-out-0","targetNodeId":"node-9","targetPortId":"p-node-9-in-1"},{"id":"conn-10","sourceNodeId":"node-9","sourcePortId":"p-node-9-out-0","targetNodeId":"node-10","targetPortId":"p-10-in-0"},{"id":"conn-11","sourceNodeId":"node-9","sourcePortId":"p-node-9-out-1","targetNodeId":"node-11","targetPortId":"p-11-in-0"},{"id":"conn-14","sourceNodeId":"node-2","sourcePortId":"p-2-out-power","targetNodeId":"node-14","targetPortId":"p-node-14-in-0"},{"id":"conn-15","sourceNodeId":"node-2","sourcePortId":"p-2-out-power","targetNodeId":"node-16","targetPortId":"p-node-16-in-0"},{"id":"conn-16","sourceNodeId":"node-16","sourcePortId":"p-node-16-out-0","targetNodeId":"node-17","targetPortId":"p-17-in-0"},{"id":"conn-17","sourceNodeId":"node-10","sourcePortId":"p-10-out-0","targetNodeId":"node-18","targetPortId":"p-node-18-in-0"},{"id":"conn-18","sourceNodeId":"node-18","sourcePortId":"p-node-18-out-0","targetNodeId":"node-2","targetPortId":"p-2-in-power"},{"id":"conn-21","sourceNodeId":"node-6","sourcePortId":"p-node-6-out-0","targetNodeId":"node-7","targetPortId":"p-7-in-0"}],"elapsedHours":0,"nodeIdCounter":20,"connectionIdCounter":21};

        function setupInitialScene() {
            updateSvgDimensions();
            
            // Reset current state
            nodes = [];
            connections = [];
            
            // Check if coming from Solar Builder with specs
            const urlParams = new URLSearchParams(window.location.search);
            const fromBuilder = urlParams.get('fromBuilder') === 'true';
            const builderSpecs = localStorage.getItem('solarBuilderSpecs');
            
            if (fromBuilder && builderSpecs) {
                // Setup scene from Solar Builder specs
                setupFromBuilderSpecs(JSON.parse(builderSpecs));
                localStorage.removeItem('solarBuilderSpecs'); // Clean up
            } else {
                // Restore nodes from embedded default system state
                nodes = defaultSystemState.nodes.map(node => {
                    // Ensure portOrientation exists (default to 'vertical')
                    if (!node.portOrientation) {
                        node.portOrientation = 'vertical';
                    }
                    const restoredNode = {
                        ...node,
                        // Restore any necessary properties that might have been lost in serialization
                        canProcessLastStep: false,
                        isRunning: node.isRunning || false,
                        batchTimeElapsed: 0,
                        isInBatch: false,
                        awaitingBatchInputs: false,
                        portOrientation: node.portOrientation || 'vertical'
                    };
                    
                    // Convert old port format to new format
                    if (restoredNode.ports) {
                        restoredNode.ports = restoredNode.ports.map(port => convertPortToNewFormat(port, restoredNode));
                    }
                    
                    // Regenerate ports for processors
                    if (restoredNode.type === NODE_TYPES.PROCESSOR) {
                        regeneratePortsForNode(restoredNode);
                    }
                    
                    return restoredNode;
                });
                
                // Restore connections
                connections = defaultSystemState.connections;
                
                // Restore counters
                nodeIdCounter = defaultSystemState.nodeIdCounter;
                connectionIdCounter = defaultSystemState.connectionIdCounter;
            }
            
            // Start simulation time at zero
            elapsedHours = 0;
            
            // Set simulation speed
            speedSlider.value = "1000";
            setSimulationSpeed();
            
            // Update UI
            updateTimeDisplay();
            // Initialize shadow angle
            if (typeof updateShadowAngle === 'function') {
                updateShadowAngle(elapsedHours % 24);
            }
            
            // Fit view to all nodes with zoom out
            fitViewToNodes();
            
            // Phase 1: Initial render on setup - use immediate render for first load
            render();
            
            // After first render, enable viewport culling
            setTimeout(() => {
                isInitialLoad = false;
                scheduleRender(); // Re-render with viewport culling enabled
            }, 100);
        }
        
        function setupFromBuilderSpecs(specs) {
            // Create a simple solar array + battery scene from builder specs
            nodeIdCounter = 0;
            connectionIdCounter = 0;
            
            const centerX = svgWidth / 2;
            const centerY = svgHeight / 2;
            
            // Create Solar Array node with builder's array wattage
            const solarArrayKw = specs.solarRatedKw || (specs.arrayWmp / 1000) || 2.4;
            const solarNode = createNode(NODE_TYPES.SOLAR_ARRAY, {
                x: centerX - 100,
                y: centerY - 350,
                ratedOutput: solarArrayKw,
                label: `SOLAR ARRAY (${specs.arrayConfig || '1P1S'})`
            });
            nodes.push(solarNode);
            
            // Create Battery Bank node with builder's battery capacity
            const batteryKwh = specs.batteryKwh || 10.8;
            const batteryNode = createNode(NODE_TYPES.RESOURCE_DISPLAY, {
                subType: 'BatteryBank',
                x: centerX - 100,
                y: centerY + 50,
                maxCapacity: batteryKwh,
                value: batteryKwh * 0.8, // Start at 80% charge
                label: `BATTERY BANK (${specs.batteryVoltage || 12}V)`
            });
            nodes.push(batteryNode);
            
            // Connect solar array to battery
            const solarOutputPort = solarNode.ports.find(p => p.type === 'output');
            const batteryInputPort = batteryNode.ports.find(p => p.type === 'input');
            
            if (solarOutputPort && batteryInputPort) {
                connectionIdCounter++;
                connections.push({
                    id: `conn-${connectionIdCounter}`,
                    sourceNodeId: solarNode.id,
                    sourcePortId: solarOutputPort.id,
                    targetNodeId: batteryNode.id,
                    targetPortId: batteryInputPort.id
                });
            }
            
            // Create load nodes from builder specs
            if (specs.loads && specs.loads.length > 0) {
                const loadStartX = centerX + 150;
                const loadStartY = centerY - 150;
                const loadSpacingX = 160;
                const loadSpacingY = 130;
                const loadsPerRow = 3;
                
                specs.loads.forEach((load, i) => {
                    const col = i % loadsPerRow;
                    const row = Math.floor(i / loadsPerRow);
                    
                    // Convert behavior to simulator node config
                    const nodeConfig = convertLoadBehaviorToNodeConfig(load);
                    
                    const loadNode = createNode(NODE_TYPES.PROCESSOR, {
                        x: loadStartX + col * loadSpacingX,
                        y: loadStartY + row * loadSpacingY,
                        label: load.name.toUpperCase(),
                        img: load.icon,
                        subType: 'ACLoad',
                        batchDuration: nodeConfig.batchDuration,
                        automations: nodeConfig.automations,
                        config: nodeConfig.config,
                        // Store original behavior for reference
                        builderBehavior: load.behavior
                    });
                    nodes.push(loadNode);
                    
                    // Connect load to battery output
                    const loadInputPort = loadNode.ports.find(p => p.type === 'input' && p.resourceType === RESOURCE_TYPES.POWER);
                    const batteryOutputPort = batteryNode.ports.find(p => p.type === 'output');
                    
                    if (loadInputPort && batteryOutputPort) {
                        connectionIdCounter++;
                        connections.push({
                            id: `conn-${connectionIdCounter}`,
                            sourceNodeId: batteryNode.id,
                            sourcePortId: batteryOutputPort.id,
                            targetNodeId: loadNode.id,
                            targetPortId: loadInputPort.id
                        });
                    }
                });
            }
            
            // Update node and connection counters
            nodeIdCounter = nodes.length;
            connectionIdCounter = connections.length;
            
            // Start simulation at hour 6 (sunrise) and paused
            elapsedHours = 6;
            isPlaying = false;
        }
        
        // Convert builder load behavior to simulator node configuration
        function convertLoadBehaviorToNodeConfig(load) {
            const behavior = load.behavior || { type: 'constant' };
            const powerRateKw = load.maxWatts / 1000;
            
            let config = {
                batchDuration: 1, // default 1 hour
                automations: [],
                config: {
                    inputs: [{ name: 'Power', resourceType: RESOURCE_TYPES.POWER, rate: powerRateKw, isBatchIO: false }],
                    outputs: []
                }
            };
            
            switch (behavior.type) {
                case 'constant':
                    // Continuous power draw
                    config.config.inputs[0].rate = (load.avgWatts || load.maxWatts) / 1000;
                    break;
                    
                case 'scheduled':
                    // Add automation for on/off schedule
                    config.automations = [{
                        type: 'schedule',
                        onTrigger: behavior.schedule?.onTrigger || 'sunset',
                        offTrigger: behavior.schedule?.offTrigger || 'sunrise'
                    }];
                    break;
                    
                case 'batch':
                    // Use first recipe as default, or calculate average
                    if (behavior.recipes && behavior.recipes.length > 0) {
                        const recipe = behavior.recipes[0];
                        config.batchDuration = recipe.durationMin / 60; // Convert minutes to hours
                        config.config.inputs[0].rate = recipe.energyWh / 1000 / config.batchDuration; // kW during batch
                        config.config.inputs[0].isBatchIO = false;
                        config.config.outputs = [{
                            name: recipe.outputs || 'Product',
                            resourceType: RESOURCE_TYPES.CUSTOM_PRODUCT_A,
                            rate: 1,
                            isBatchIO: true
                        }];
                        // Store all recipes for potential future use
                        config.recipes = behavior.recipes;
                    }
                    break;
                    
                case 'thermostat':
                    // Cycling behavior - use duty cycle to calculate effective power
                    const dutyPercent = behavior.dutyPercent || 50;
                    config.config.inputs[0].rate = powerRateKw; // Full power when on
                    config.automations = [{
                        type: 'thermostat',
                        setpoint: behavior.setpoint || 72,
                        deadband: behavior.deadband || 2,
                        dutyPercent: dutyPercent
                    }];
                    break;
                    
                case 'charging':
                    // Battery charging behavior
                    config.config.inputs[0].rate = behavior.chargeRateKw || powerRateKw;
                    config.automations = [{
                        type: 'charging',
                        batteryKwh: behavior.batteryKwh || 1,
                        dailyDepletionKwh: behavior.dailyDepletionKwh || 0.5
                    }];
                    break;
            }
            
            return config;
        }
        document.addEventListener("DOMContentLoaded", () => { updateSvgDimensions(); window.addEventListener('resize', () => { updateSvgDimensions(); scheduleRender(); }); setupInitialScene(); });

        function saveSystem() {
            const systemState = {
                nodes: nodes.map(node => ({
                    ...node,
                    // Remove any circular references or functions
                    ports: node.ports.map(port => ({
                        id: port.id,
                        type: port.type,
                        resourceType: port.resourceType,
                        name: port.name,
                        side: port.side,
                        yOffsetRatio: port.yOffsetRatio
                    }))
                })),
                connections: connections,
                elapsedHours: elapsedHours,
                nodeIdCounter: nodeIdCounter,
                connectionIdCounter: connectionIdCounter
            };

            const saveData = JSON.stringify(systemState);
            const blob = new Blob([saveData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `ecosystem_simulation_${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadSystem() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const systemState = JSON.parse(event.target.result);
                        
                        // Reset current state
                        nodes = [];
                        connections = [];
                        
                        // Restore nodes
                        nodes = systemState.nodes.map(node => {
                            // Ensure portOrientation exists (default to 'vertical')
                            if (!node.portOrientation) {
                                node.portOrientation = 'vertical';
                            }
                            const restoredNode = {
                                ...node,
                                // Restore any necessary properties that might have been lost in serialization
                                canProcessLastStep: false,
                                isRunning: false,
                                batchTimeElapsed: 0,
                                isInBatch: false,
                                awaitingBatchInputs: false,
                                flipped: node.flipped || false,
                                portOrientation: node.portOrientation || 'vertical'
                            };
                            
                            // Convert old port format to new format
                            if (restoredNode.ports) {
                                restoredNode.ports = restoredNode.ports.map(port => convertPortToNewFormat(port, restoredNode));
                            }
                            
                            return restoredNode;
                        });
                        
                        // Regenerate ports for processors to respect flipped state and orientation
                        nodes.forEach(node => {
                            if (node.type === NODE_TYPES.PROCESSOR) {
                                regeneratePortsForNode(node);
                            }
                        });
                        
                        // Restore connections
                        connections = systemState.connections;
                        
                        // Restore counters
                        nodeIdCounter = systemState.nodeIdCounter;
                        connectionIdCounter = systemState.connectionIdCounter;
                        
                        // Restore simulation time
                        elapsedHours = systemState.elapsedHours;
                        
                        // Update UI
                        scheduleRender(); // Phase 1: Use batched render
                        updateTimeDisplay();
                        
                        // Stop simulation if it was running
                        if (isPlaying) {
                            playPauseSimulation();
                        }
                    } catch (error) {
                        console.error('Error loading save file:', error);
                        alert('Error loading save file. The file might be corrupted or incompatible.');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Challenge mode functions
        function showChallengeFailure() {
            const overlay = document.getElementById('challengeOverlay');
            
            // Update all stat cards
            document.getElementById('challengeTimeElapsed').textContent = elapsedHours;
            document.getElementById('challengeSolarKwh').textContent = challengeStats.solarKwhGenerated.toFixed(2);
            document.getElementById('challengeKwhGenerated').textContent = challengeStats.totalKwhGenerated.toFixed(2);
            document.getElementById('challengeKwhConsumed').textContent = challengeStats.totalKwhConsumed.toFixed(2);
            
            // Calculate and display net kWh with color coding
            const netKwh = challengeStats.totalKwhGenerated - challengeStats.totalKwhConsumed;
            const netKwhCard = document.getElementById('challengeNetKwhCard');
            const netKwhEl = document.getElementById('challengeNetKwh');
            netKwhEl.textContent = (netKwh >= 0 ? '+' : '') + netKwh.toFixed(2);
            netKwhCard.className = 'stat-card ' + (netKwh >= 0 ? 'positive' : 'negative');
            
            // Calculate and display efficiency
            const efficiency = challengeStats.solarKwhPossible > 0 
                ? (challengeStats.solarKwhCaptured / challengeStats.solarKwhPossible * 100).toFixed(2)
                : '0.00';
            document.getElementById('challengeKwhEfficiency').textContent = efficiency;
            
            // Calculate and display K_micro score
            const kMicro = computeMicroKardashev(challengeStats.solarKwhCaptured, challengeStats.solarKwhPossible);
            const kMicroEl = document.getElementById('challengeKMicro');
            kMicroEl.textContent = kMicro.toFixed(5);
            // Color based on K_micro thresholds
            if (kMicro >= 0.02) {
                kMicroEl.style.color = '#5cb85c'; // Green - good
            } else if (kMicro >= 0.01) {
                kMicroEl.style.color = '#f0ad4e'; // Yellow - typical
            } else {
                kMicroEl.style.color = '#d9534f'; // Red - poor
            }
            
            // Calculate and display eCO2 stats
            // eCO2 values are negative (removed from atmosphere)
            const eco2Sequestered = -(challengeStats.biocharProduced * eco2Factors.biocharCaptureFactor);
            const eco2Avoided = -(challengeStats.woodgasConsumed * eco2Factors.woodgasAvoidanceFactor);
            const eco2TotalSaved = eco2Sequestered + eco2Avoided;
            
            document.getElementById('challengeEco2Sequestered').textContent = eco2Sequestered.toFixed(2);
            document.getElementById('challengeEco2Avoided').textContent = eco2Avoided.toFixed(2);
            document.getElementById('challengeEco2TotalSaved').textContent = eco2TotalSaved.toFixed(2);
            
            // Build resource details with units
            const resourceDetails = document.getElementById('challengeResourceDetails');
            let detailsHTML = '';
            
            // Resources Consumed
            const consumedEntries = Object.entries(challengeStats.resourcesConsumed);
            if (consumedEntries.length > 0) {
                detailsHTML += '<div style="margin-bottom: 20px;"><h4 style="color: #d9534f; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Resources Consumed</h4>';
                consumedEntries.forEach(([resType, amount]) => {
                    const unit = getDefaultUnitForResource(resType);
                    detailsHTML += `<div class="resource-item"><span class="resource-name">${resType}</span><span class="resource-value">${amount.toFixed(2)} ${unit}</span></div>`;
                });
                detailsHTML += '</div>';
            }
            
            // Resources Produced
            const producedEntries = Object.entries(challengeStats.resourcesProduced);
            if (producedEntries.length > 0) {
                detailsHTML += '<div><h4 style="color: #5cb85c; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Resources Produced</h4>';
                producedEntries.forEach(([resType, amount]) => {
                    const unit = getDefaultUnitForResource(resType);
                    detailsHTML += `<div class="resource-item"><span class="resource-name">${resType}</span><span class="resource-value">${amount.toFixed(2)} ${unit}</span></div>`;
                });
                detailsHTML += '</div>';
            }
            
            if (detailsHTML === '') {
                detailsHTML = '<div style="color: #888; font-style: italic;">No resources tracked</div>';
            }
            
            resourceDetails.innerHTML = detailsHTML;
            
            overlay.classList.add('visible');
        }
        
        function resetChallengeMode() {
            challengeMode = false;
            challengeStats = {
                solarKwhGenerated: 0,
                solarKwhCaptured: 0,
                solarKwhPossible: 0,
                totalKwhGenerated: 0,
                totalKwhConsumed: 0,
                resourcesConsumed: {},
                resourcesProduced: {},
                biocharProduced: 0,
                woodgasConsumed: 0
            };
            liveStats = {
                solarKwhGenerated: 0,
                solarKwhCaptured: 0,
                solarKwhPossible: 0,
                totalKwhGenerated: 0,
                totalKwhConsumed: 0,
                resourcesConsumed: {},
                resourcesProduced: {},
                biocharProduced: 0,
                woodgasConsumed: 0,
                eco2Sequestered: 0,
                eco2Avoided: 0,
                eco2TotalSaved: 0
            };
            elapsedHours = 0;
            isPlaying = false;
            // Phase 1: RAF loop handles stopping automatically when isPlaying is false
            
            // Reset nodes to their initial state from defaultSystemState
            nodes = defaultSystemState.nodes.map(node => ({
                ...node,
                canProcessLastStep: false,
                isRunning: node.isRunning || false,
                batchTimeElapsed: 0,
                isInBatch: false,
                awaitingBatchInputs: false,
                flipped: node.flipped || false
            }));
            
            // Regenerate ports for processors to respect flipped state
            nodes.forEach(node => {
                if (node.type === NODE_TYPES.PROCESSOR) {
                    regeneratePortsForNode(node);
                }
            });
            
            // Reset connections
            connections = defaultSystemState.connections;
            
            // Reset counters
            nodeIdCounter = defaultSystemState.nodeIdCounter;
            connectionIdCounter = defaultSystemState.connectionIdCounter;
            
            document.getElementById('challengeOverlay').classList.remove('visible');
            document.getElementById('challengeMode').textContent = 'Challenge Mode';
            updateTimeDisplay();
            scheduleRender(); // Phase 1: Use batched render
        }
        
        function toggleChallengeMode() {
            if (challengeMode) {
                // Disable challenge mode
                challengeMode = false;
                document.getElementById('challengeMode').textContent = 'Challenge Mode';
            } else {
                // Enable challenge mode
                challengeMode = true;
                challengeStats = {
                    solarKwhGenerated: 0,
                    solarKwhCaptured: 0,
                    solarKwhPossible: 0,
                    totalKwhGenerated: 0,
                    totalKwhConsumed: 0,
                    resourcesConsumed: {},
                    resourcesProduced: {},
                    biocharProduced: 0,
                    woodgasConsumed: 0
                };
                liveStats = {
                    solarKwhGenerated: 0,
                    solarKwhCaptured: 0,
                    solarKwhPossible: 0,
                    totalKwhGenerated: 0,
                    totalKwhConsumed: 0,
                    resourcesConsumed: {},
                    resourcesProduced: {},
                    biocharProduced: 0,
                    woodgasConsumed: 0,
                    eco2Sequestered: 0,
                    eco2Avoided: 0,
                    eco2TotalSaved: 0
                };
                elapsedHours = 0;
                document.getElementById('challengeMode').textContent = 'Challenge Mode: ON';
                updateTimeDisplay();
                scheduleRender(); // Phase 1: Use batched render
            }
        }
        
        // Add event listeners for save/load buttons
        document.getElementById('saveSystem').addEventListener('click', saveSystem);
        document.getElementById('loadSystem').addEventListener('click', loadSystem);
        
        // Back to Builder button
        document.getElementById('backToBuilder').addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        document.getElementById('challengeMode').addEventListener('click', toggleChallengeMode);
        document.getElementById('challengeRestart').addEventListener('click', resetChallengeMode);
        document.getElementById('weatherDifficulty').addEventListener('change', (e) => {
            weatherDifficulty = e.target.value;
            // Reset derating so it recalculates on next step
            lastDeratingHour = -1;
        });

        function getDefaultUnitForResource(resourceType) {
            switch(resourceType) {
                case RESOURCE_TYPES.POWER: return 'kWh';
                case RESOURCE_TYPES.PLASTIC: return 'kg';
                case RESOURCE_TYPES.PLASTIC_FLAKES: return 'kg';
                case RESOURCE_TYPES.WIND_TURBINES: return 'kg';
                case RESOURCE_TYPES.BIOMASS: return 'kg';
                case RESOURCE_TYPES.POOP_GAS: return 'Cubic Meters';
                case RESOURCE_TYPES.BIOCHAR: return 'kg';
                default: return 'Units';
            }
        }

        function getDefaultCapacityForResource(resourceType) {
            switch(resourceType) {
                case RESOURCE_TYPES.POWER: return 10.8;
                case RESOURCE_TYPES.PLASTIC: return 100;
                case RESOURCE_TYPES.PLASTIC_FLAKES: return 50;
                case RESOURCE_TYPES.WIND_TURBINES: return 50;
                case RESOURCE_TYPES.BIOMASS: return 100;
                case RESOURCE_TYPES.POOP_GAS: return 10;
                case RESOURCE_TYPES.BIOCHAR: return 50;
                default: return 100;
            }
        }

        // Add zoom control event listeners
        document.getElementById('zoomIn').addEventListener('click', () => {
            currentZoom = currentZoom.scale(1.5);
            svg.call(zoom.transform, currentZoom);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            currentZoom = currentZoom.scale(0.75);
            svg.call(zoom.transform, currentZoom);
        });

        document.getElementById('resetZoom').addEventListener('click', () => {
            currentZoom = d3.zoomIdentity;
            svg.call(zoom.transform, currentZoom);
        });

        document.getElementById('resetTime').addEventListener('click', () => {
            elapsedHours = 0;
            liveStats = {
                solarKwhGenerated: 0,
                solarKwhCaptured: 0,
                solarKwhPossible: 0,
                totalKwhGenerated: 0,
                totalKwhConsumed: 0,
                resourcesConsumed: {},
                resourcesProduced: {},
                biocharProduced: 0,
                woodgasConsumed: 0,
                eco2Sequestered: 0,
                eco2Avoided: 0,
                eco2TotalSaved: 0
            };
            updateTimeDisplay();
        });
        
        document.getElementById('resetValues').addEventListener('click', () => {
            // Reset all resource display node values to zero (except batteries)
            nodes.forEach(node => {
                if (node.type === NODE_TYPES.RESOURCE_DISPLAY && node.resourceType !== RESOURCE_TYPES.POWER) {
                    node.value = 0;
                }
            });
            liveStats = {
                solarKwhGenerated: 0,
                solarKwhCaptured: 0,
                solarKwhPossible: 0,
                totalKwhGenerated: 0,
                totalKwhConsumed: 0,
                resourcesConsumed: {},
                resourcesProduced: {},
                biocharProduced: 0,
                woodgasConsumed: 0,
                eco2Sequestered: 0,
                eco2Avoided: 0,
                eco2TotalSaved: 0
            };
            updateLiveStatsBar();
            scheduleRender(); // Phase 1: Use batched render
        });

        // Add renderConnections function back
        function getVisibleConnections() {
            // Phase 3: Viewport culling for connections - only render connections between visible nodes
            if (isInitialLoad) {
                return connections; // Render all on initial load
            }
            
            const visibleNodeIds = new Set(getVisibleNodes().map(n => n.id));
            return connections.filter(conn => 
                visibleNodeIds.has(conn.sourceNodeId) || visibleNodeIds.has(conn.targetNodeId)
            );
        }

        function renderConnections() {
            // Phase 2: Use cached zoomGroup
            // Phase 3: Only render visible connections
            const visibleConnections = getVisibleConnections();
            const connectionGroups = getZoomGroup().selectAll(".connection")
                .data(visibleConnections, d => d.id);

            // Remove old connections
            connectionGroups.exit().remove();

            // Add new connections
            const newConnections = connectionGroups.enter()
                .append("path")
                .attr("class", d => {
                    const sourceNode = findNodeById(d.sourceNodeId);
                    const sourcePort = sourceNode.ports.find(p => p.id === d.sourcePortId);
                    let resourceClass = 'default-connection';
                    
                    if (sourcePort) {
                        switch(sourcePort.resourceType) {
                            case RESOURCE_TYPES.POWER: resourceClass = 'power'; break;
                            case RESOURCE_TYPES.PLASTIC: resourceClass = 'plastic'; break;
                            case RESOURCE_TYPES.PLASTIC_FLAKES: resourceClass = 'plastic-flakes'; break;
                            case RESOURCE_TYPES.WIND_TURBINES: resourceClass = 'wind-turbines'; break;
                            case RESOURCE_TYPES.BIOMASS: resourceClass = 'biomass'; break;
                            case RESOURCE_TYPES.POOP_GAS: resourceClass = 'woodgas'; break;
                            case RESOURCE_TYPES.BIOCHAR: resourceClass = 'biochar'; break;
                        }
                    }
                    return `connection ${resourceClass}`;
                })
                .style("stroke", d => {
                    const sourceNode = findNodeById(d.sourceNodeId);
                    const sourcePort = sourceNode.ports.find(p => p.id === d.sourcePortId);
                    const resourceType = sourcePort?.resourceType;
                    // Use defined color, or gray for user-defined/unknown types
                    return RESOURCE_COLORS[resourceType] || RESOURCE_COLORS[RESOURCE_TYPES.USER_DEFINED] || '#888888';
                })
                .style("stroke-width", d => {
                    // Calculate flow rate for thickness
                    const sourceNode = findNodeById(d.sourceNodeId);
                    const sourcePort = sourceNode.ports.find(p => p.id === d.sourcePortId);
                    let flowRate = 0;
                    
                    // Get flow rate from source node
                    if (sourceNode.type === NODE_TYPES.PROCESSOR && sourceNode.isRunning) {
                        const outputDef = sourceNode.config.outputs.find(o => o.portId === d.sourcePortId);
                        flowRate = outputDef ? outputDef.rate : 0;
                    } else if (sourceNode.type === NODE_TYPES.SOLAR_ARRAY) {
                        flowRate = sourceNode.currentOutput || 0;
                    } else if (sourceNode.type === NODE_TYPES.RESOURCE_DISPLAY) {
                        // For resource displays, use a base rate or value-based calculation
                        flowRate = sourceNode.value > 0 ? 1 : 0;  // Simple: active if has value
                    }
                    
                    // Scale thickness based on flow rate (min 5px, max 10px)
                    const baseThickness = 5;  // Increased from 3px to 5px
                    const maxThickness = 10;  // Increased from 8px to 10px
                    const thickness = Math.min(maxThickness, baseThickness + (flowRate * 2));
                    return `${thickness}px`;
                })
                .style("vector-effect", "non-scaling-stroke")
                .style("cursor", "pointer")
                .style("pointer-events", "stroke")  // Only make the stroke clickable, not the fill
                .on("click", (e, d) => {
                    e.stopPropagation();
                    deleteConnection(d.id);
                });

            // Update all connections (both new and existing)
            connectionGroups.merge(newConnections)
                .style("stroke-width", d => {
                    // Calculate flow rate for thickness (update existing connections too)
                    const sourceNode = findNodeById(d.sourceNodeId);
                    const sourcePort = sourceNode.ports.find(p => p.id === d.sourcePortId);
                    let flowRate = 0;
                    
                    // Get flow rate from source node
                    if (sourceNode.type === NODE_TYPES.PROCESSOR && sourceNode.isRunning) {
                        const outputDef = sourceNode.config.outputs.find(o => o.portId === d.sourcePortId);
                        flowRate = outputDef ? outputDef.rate : 0;
                    } else if (sourceNode.type === NODE_TYPES.SOLAR_ARRAY) {
                        flowRate = sourceNode.currentOutput || 0;
                    } else if (sourceNode.type === NODE_TYPES.RESOURCE_DISPLAY) {
                        // For resource displays, use a base rate or value-based calculation
                        flowRate = sourceNode.value > 0 ? 1 : 0;  // Simple: active if has value
                    }
                    
                    // Scale thickness based on flow rate (min 5px, max 10px)
                    const baseThickness = 5;  // Increased from 3px to 5px
                    const maxThickness = 10;  // Increased from 8px to 10px
                    const thickness = Math.min(maxThickness, baseThickness + (flowRate * 2));
                    return `${thickness}px`;
                })
                .attr("d", d => {
                    const sn = findNodeById(d.sourceNodeId);
                    const tn = findNodeById(d.targetNodeId);
                    if (!sn || !tn) return "";
                    
                    // Phase 3: Cache connection paths - include node positions in cache key
                    const cacheKey = `${d.id}-${getZoomKey()}-${sn.x}-${sn.y}-${tn.x}-${tn.y}`;
                    
                    if (connectionPathCache.has(cacheKey)) {
                        return connectionPathCache.get(cacheKey);
                    }
                    
                    const sp = sn.ports.find(p => p.id === d.sourcePortId);
                    const tp = tn.ports.find(p => p.id === d.targetPortId);
                    if (!sp || !tp) return "";
                    
                    const spos = getAbsPortPosition(sn, sp);
                    const epos = getAbsPortPosition(tn, tp);
                    
                    const sOrientation = sn.portOrientation || 'vertical';
                    const tOrientation = tn.portOrientation || 'vertical';
                    
                    // Phase 3: Use createBezierPath function instead of inline calculation
                    const pathString = createBezierPath(spos, epos, sp.side, tp.side, sOrientation, tOrientation);
                    connectionPathCache.set(cacheKey, pathString);
                    return pathString;
                })
                .classed("is-flowing", d => {
                    // Only animate if simulation is playing
                    if (!isPlaying) return false;
                    
                    const sourceNode = findNodeById(d.sourceNodeId);
                    const targetNode = findNodeById(d.targetNodeId);
                    
                    // Check if source is a processor that's running
                    if (sourceNode.type === NODE_TYPES.PROCESSOR && sourceNode.isRunning) {
                        return true;
                    }
                    
                    // Check if source is a solar array that's producing power
                    if (sourceNode.type === NODE_TYPES.SOLAR_ARRAY && sourceNode.currentOutput > 0.001) {
                        return true;
                    }
                    
                    // Check if target is a processor that's running and consuming resources
                    if (targetNode.type === NODE_TYPES.PROCESSOR && targetNode.isRunning && targetNode.canProcessLastStep) {
                        return true;
                    }
                    
                    return false;
                })
                .classed("connection-active", d => {
                    // Fade inactive connections to darker shade
                    const sourceNode = findNodeById(d.sourceNodeId);
                    const targetNode = findNodeById(d.targetNodeId);
                    let isActive = false;
                    
                    // Check if connection is active
                    if (sourceNode.type === NODE_TYPES.PROCESSOR && sourceNode.isRunning) {
                        isActive = true;
                    } else if (sourceNode.type === NODE_TYPES.SOLAR_ARRAY && sourceNode.currentOutput > 0.001) {
                        isActive = true;
                    } else if (targetNode.type === NODE_TYPES.PROCESSOR && targetNode.isRunning && targetNode.canProcessLastStep) {
                        isActive = true;
                    }
                    
                    return isActive;
                });
        }

        // Consolidated view management
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const moduleLibrary = document.getElementById('module-library');
        const moduleLibraryToggle = document.getElementById('module-library-toggle');

        function collapseModuleLibrary() {
            moduleLibrary.classList.add('collapsed');
            moduleLibraryToggle.textContent = '‚ñ∂';
            moduleLibraryToggle.title = 'Expand Module Library';
        }

        function expandModuleLibrary() {
            moduleLibrary.classList.remove('collapsed');
            moduleLibraryToggle.textContent = '‚óÄ';
            moduleLibraryToggle.title = 'Collapse Module Library';
        }

        function toggleModuleLibrary() {
            if (moduleLibrary.classList.contains('collapsed')) {
                expandModuleLibrary();
            } else {
                collapseModuleLibrary();
            }
        }

        function collapseSidebar() {
            sidebar.classList.add('collapsed');
            sidebarToggle.textContent = '‚óÄ';
            sidebarToggle.title = 'Expand Component Editor';
        }

        function expandSidebar() {
            sidebar.classList.remove('collapsed');
            sidebarToggle.textContent = '‚ñ∂';
            sidebarToggle.title = 'Collapse Component Editor';
        }

        function toggleSidebar() {
            if (sidebar.classList.contains('collapsed')) {
                expandSidebar();
                // When manually opening, show the node builder by default if no node is selected
                if (!selectedNodeId) {
                    showBuilderView();
                } else {
                    // If a node is selected, show the inspector
                    showInspectorView();
                }
            } else {
                collapseSidebar();
            }
        }

        // Wire up toggle buttons
        moduleLibraryToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleModuleLibrary();
        });

        sidebarToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSidebar();
        });

        // Initialize: Start with both panels collapsed
        if (moduleLibrary.classList.contains('collapsed')) {
            moduleLibraryToggle.textContent = '‚ñ∂';
            moduleLibraryToggle.title = 'Expand Module Library';
        }
        if (sidebar.classList.contains('collapsed')) {
            sidebarToggle.textContent = '‚óÄ';
            sidebarToggle.title = 'Expand Component Editor';
        }

        function showBuilderView() {
            expandSidebar();
            nodeBuilderSection.classList.remove('hidden');
            nodeInspectorSection.classList.add('hidden');
            eco2FactorsSection.classList.add('hidden');
        }

        function showLibraryView() {
            // Don't change sidebar state, just show library content if sidebar is open
            nodeBuilderSection.classList.add('hidden');
            nodeInspectorSection.classList.add('hidden');
            eco2FactorsSection.classList.add('hidden');
        }

        function showInspectorView() {
            expandSidebar();
            nodeBuilderSection.classList.add('hidden');
            nodeInspectorSection.classList.remove('hidden');
            eco2FactorsSection.classList.add('hidden');
        }

        // Update the cancel button
        document.getElementById('cancelNodeChanges').addEventListener('click', () => {
            deselectNode();
        });

        // Update click-outside handler - use capture phase and check early
        document.addEventListener('click', (e) => {
            // Don't trigger if this is a remove button click (check attribute set by handler)
            if (e.target.hasAttribute('data-removing') || e.target.closest('[data-removing]')) {
                return;
            }
            // Don't trigger if clicking on remove buttons or their parents
            const removeBtn = e.target.closest('.remove-io-button, .remove-automation-button');
            if (removeBtn) {
                return;
            }
            // Don't trigger if clicking inside the inspector section or any of its containers
            if (nodeInspectorSection && nodeInspectorSection.contains(e.target)) {
                return;
            }
            // Don't trigger if clicking inside input/output containers
            if ((inspectorInputsContainer && inspectorInputsContainer.contains(e.target)) ||
                (inspectorOutputsContainer && inspectorOutputsContainer.contains(e.target)) ||
                (document.getElementById('inspectorAutomationContainer') && document.getElementById('inspectorAutomationContainer').contains(e.target))) {
                return;
            }
            // Don't trigger if clicking on toggle buttons
            if (e.target === sidebarToggle || e.target === moduleLibraryToggle || 
                e.target.closest('#sidebar-toggle') || e.target.closest('#module-library-toggle')) {
                return;
            }
        }, true); // Use capture phase

        // Update the selectNode function to show inspector view
        function selectNode(nodeId) {
            const node = findNodeById(nodeId);
            if (!node) {
                deselectNode();
                return;
            }
            selectedNodeId = nodeId;
            showInspectorView();
            populateInspector(node);
            // Initialize save button state
            hasPendingSave = false;
            if (saveTimeout) {
                clearTimeout(saveTimeout);
                saveTimeout = null;
            }
            updateSaveButtonState();
            scheduleRender(); // Phase 1: Use batched render
        }

        // Update the deselectNode function
        function deselectNode() {
            selectedNodeId = null;
            deselectInspector();
            scheduleRender(); // Phase 1: Use batched render
        }

        // Update the deselectInspector function
        function deselectInspector() {
            nodeInspectorSection.classList.add('hidden');
            nodeBuilderSection.classList.add('hidden');
            inspectorNodeName.value = "";
            inspectorNodeImageURL.value = "";
            inspectorInputsContainer.innerHTML = "";
            inspectorOutputsContainer.innerHTML = "";
            inspectorNodeUnit.value = "";
            inspectorPassiveRate.value = "";
            inspectorMaxCapacity.value = "";
            inspectorSolarArrayFields.classList.add('hidden');
            inspectorBatchDurationField.classList.add('hidden');
            document.getElementById('inspectorRecipeFields').classList.add('hidden');
        }

        // eCO2 Factors Editor Functions
        const eco2FactorsSection = document.getElementById('eco2FactorsSection');
        const eco2BiocharFactorInput = document.getElementById('eco2BiocharFactor');
        const eco2WoodgasFactorInput = document.getElementById('eco2WoodgasFactor');
        
        function showEco2FactorsEditor() {
            expandSidebar();
            nodeBuilderSection.classList.add('hidden');
            nodeInspectorSection.classList.add('hidden');
            eco2FactorsSection.classList.remove('hidden');
            
            // Populate current values
            eco2BiocharFactorInput.value = eco2Factors.biocharCaptureFactor;
            eco2WoodgasFactorInput.value = eco2Factors.woodgasAvoidanceFactor;
            updateEco2Calculations();
        }
        
        function hideEco2FactorsEditor() {
            eco2FactorsSection.classList.add('hidden');
        }
        
        function updateEco2Calculations() {
            // eCO2 values are negative (removed from atmosphere)
            const biocharSeq = -(liveStats.biocharProduced * eco2Factors.biocharCaptureFactor);
            // woodgas is now tracked in cubic meters (m¬≥), no conversion needed
            const woodgasAvd = -(liveStats.woodgasConsumed * eco2Factors.woodgasAvoidanceFactor);
            const total = biocharSeq + woodgasAvd;
            
            document.getElementById('eco2BiocharCalc').textContent = biocharSeq.toFixed(2);
            document.getElementById('eco2WoodgasCalc').textContent = woodgasAvd.toFixed(2);
            document.getElementById('eco2TotalCalc').textContent = total.toFixed(2);
        }
        
        function saveEco2Factors() {
            eco2Factors.biocharCaptureFactor = parseFloat(eco2BiocharFactorInput.value) || 1.8;
            eco2Factors.woodgasAvoidanceFactor = parseFloat(eco2WoodgasFactorInput.value) || 1.2;
            updateEco2Calculations();
            updateLiveStatsBar(); // Refresh stats bar with new calculations
            scheduleRender();
        }
        
        // Wire up eCO2 editor buttons
        document.getElementById('saveEco2Factors').addEventListener('click', saveEco2Factors);
        document.getElementById('cancelEco2Factors').addEventListener('click', hideEco2FactorsEditor);
        
        // Auto-update calculations when factors change
        eco2BiocharFactorInput.addEventListener('input', updateEco2Calculations);
        eco2WoodgasFactorInput.addEventListener('input', updateEco2Calculations);
        
        // Double-click handlers for eCO2 stats
        document.getElementById('eco2SequesteredStat').addEventListener('dblclick', showEco2FactorsEditor);
        document.getElementById('eco2AvoidedStat').addEventListener('dblclick', showEco2FactorsEditor);
        document.getElementById('eco2TotalSavedStat').addEventListener('dblclick', showEco2FactorsEditor);
        
        // Update the svg click handler to properly handle deselection
        svg.on("click", (e) => {
            if (e.target === svg.node()) {
                deselectNode();
            }
        });

        // Add event listener for createCustomNodeInstance button
        const createCustomNodeInstanceBtn = document.getElementById('createCustomNodeInstance');
        if (createCustomNodeInstanceBtn) {
            createCustomNodeInstanceBtn.addEventListener('click', () => {
                showBuilderView();
            });
        }
        
        // Add event listener for openCustomBuilder button
        const openCustomBuilderBtn = document.getElementById('openCustomBuilder');
        if (openCustomBuilderBtn) {
            openCustomBuilderBtn.addEventListener('click', () => {
                showBuilderView();
            });
        }

        // Add these functions after the existing save/load functions
        function saveCustomModule() {
            const moduleName = document.getElementById("customNodeName").value || "Custom Module";
            const imgURL = customNodeImageURL.value.trim() || null;
            const batchDuration = parseInt(customBatchDurationInput.value) || 6;
            
            const moduleDefinition = {
                name: moduleName,
                img: imgURL,
                batchDuration: batchDuration,
                inputs: [],
                outputs: []
            };

            // Collect inputs
            document.querySelectorAll("#customInputsContainer .io-item").forEach(item => {
                moduleDefinition.inputs.push({
                    name: item.querySelector('[name="io_name"]').value || "Input",
                    resourceType: item.querySelector('[name="io_resource"]').value,
                    rate: parseFloat(item.querySelector('[name="io_rate"]').value) || 1,
                    isBatchIO: item.querySelector('[name="io_is_batch"]').checked
                });
            });

            // Collect outputs
            document.querySelectorAll("#customOutputsContainer .io-item").forEach(item => {
                moduleDefinition.outputs.push({
                    name: item.querySelector('[name="io_name"]').value || "Output",
                    resourceType: item.querySelector('[name="io_resource"]').value,
                    rate: parseFloat(item.querySelector('[name="io_rate"]').value) || 1,
                    isBatchIO: item.querySelector('[name="io_is_batch"]').checked
                });
            });

            // Create and download the JSON file
            const saveData = JSON.stringify(moduleDefinition, null, 2);
            const blob = new Blob([saveData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `custom_module_${moduleName.toLowerCase().replace(/\s+/g, '_')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadCustomModule() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const moduleDefinition = JSON.parse(event.target.result);
                        
                        // Clear existing fields
                        document.getElementById("customNodeName").value = moduleDefinition.name || "";
                        customNodeImageURL.value = moduleDefinition.img || "";
                        customBatchDurationInput.value = moduleDefinition.batchDuration || 6;
                        
                        // Clear existing I/O fields
                        customInputsContainer.innerHTML = "";
                        customOutputsContainer.innerHTML = "";
                        
                        // Add inputs
                        moduleDefinition.inputs.forEach(input => {
                            const div = document.createElement("div");
                            div.className = 'io-item';
                            div.id = `custom-io-${inspectorIoItemIdCounter++}`;
                            
                            let resOptsHTML = "";
                            for(const key in RESOURCE_TYPES) {
                                resOptsHTML += `<option value="${RESOURCE_TYPES[key]}" ${input.resourceType === RESOURCE_TYPES[key] ? 'selected' : ''}>${RESOURCE_TYPES[key]}</option>`;
                            }
                            
                            div.innerHTML = `
                                <label>Port Name: <input type="text" name="io_name" value="${input.name}" placeholder="e.g., Raw Material"></label>
                                <label>Resource Type: <select name="io_resource">${resOptsHTML}</select></label>
                                <label>Rate (per hour/batch): <input type="number" name="io_rate" value="${input.rate}" step="0.001" min="0"></label>
                                <label><input type="checkbox" name="io_is_batch" ${input.isBatchIO ? 'checked' : ''}> Batch I/O</label>
                                <button onclick="event.stopPropagation(); this.parentElement.remove()" style="width:auto;float:right;background-color:#c55;">X</button>`;
                            
                            customInputsContainer.appendChild(div);
                        });
                        
                        // Add outputs
                        moduleDefinition.outputs.forEach(output => {
                            const div = document.createElement("div");
                            div.className = 'io-item';
                            div.id = `custom-io-${inspectorIoItemIdCounter++}`;
                            
                            let resOptsHTML = "";
                            for(const key in RESOURCE_TYPES) {
                                resOptsHTML += `<option value="${RESOURCE_TYPES[key]}" ${output.resourceType === RESOURCE_TYPES[key] ? 'selected' : ''}>${RESOURCE_TYPES[key]}</option>`;
                            }
                            
                            div.innerHTML = `
                                <label>Port Name: <input type="text" name="io_name" value="${output.name}" placeholder="e.g., Processed Material"></label>
                                <label>Resource Type: <select name="io_resource">${resOptsHTML}</select></label>
                                <label>Rate (per hour/batch): <input type="number" name="io_rate" value="${output.rate}" step="0.001" min="0"></label>
                                <label><input type="checkbox" name="io_is_batch" ${output.isBatchIO ? 'checked' : ''}> Batch I/O</label>
                                <button onclick="event.stopPropagation(); this.parentElement.remove()" style="width:auto;float:right;background-color:#c55;">X</button>`;
                            
                            customOutputsContainer.appendChild(div);
                        });
                        
                    } catch (error) {
                        console.error('Error loading module file:', error);
                        alert('Error loading module file. The file might be corrupted or incompatible.');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Add event listeners for the save/load module buttons (buttons already exist in HTML)
        document.getElementById('saveCustomModule').addEventListener('click', saveCustomModule);
        document.getElementById('loadCustomModule').addEventListener('click', loadCustomModule);

        // ... existing code ...
        function deleteConnection(connectionId) {
            // Remove from connections array
            connections = connections.filter(c => c.id !== connectionId);
            // Phase 3: Invalidate connection path cache for removed connection
            connectionPathCache.clear();
            // Phase 1: Use batched render
            scheduleRender();
        }

    </script>

</body></html>
